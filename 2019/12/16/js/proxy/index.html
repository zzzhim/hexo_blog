<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    代理与反射接口 |  
  </title>
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/css/style.css">
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
<script src="/js/pace.min.js"></script>


  

  

<meta name="generator" content="Hexo 4.1.1"><link rel="alternate" href="/atom.xml" title="" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    <main class="content">
      <section class="outer">
  <article id="es6-js/proxy" class="article article-type-es6" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  代理与反射接口
</h1>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2019/12/16/js/proxy/" class="article-date">
  <time datetime="2019-12-16T12:48:06.000Z" itemprop="datePublished">2019-12-16</time>
</a>
      
    </div>
    

    
    
    <div class="tocbot"></div>





    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="代理与反射接口"><a href="#代理与反射接口" class="headerlink" title="代理与反射接口"></a>代理与反射接口</h1><!-- **ES5** 与 **ES6** 都推进了 **JS** 功能的公开。例如，**JS** 运行环境包含一些不可枚举、不可写入的对象属性，然而在 **ES5** 之前我们无法定义它们自己的不可枚举属性或者不可写入属性。 -->
<p><strong>ES6</strong> 为了让开发者能进一步接近 <strong>JS</strong> 引擎的能力，这些能力原先只存在于内置对象上。JS通过代理（<strong>proxy</strong>）暴露了在对象上的内部工作，代理是一种封装，能够拦截并改变 <strong>JS</strong> 引擎的底层操作。</p>
<!-- ### 数组的问题
在 **ES6** 之前， **JS** 的数组对象拥有特定的行为方式，无法被开发者在自定义对象中进行模拟。当 -->

<h3 id="代理与反射是什么？"><a href="#代理与反射是什么？" class="headerlink" title="代理与反射是什么？"></a>代理与反射是什么？</h3><p>通过调用 <code>new proxy()</code> ，我们可以创建一个代理用来代替另一个对象（被称为代理目标），这个代理对目标对象进行了虚拟，因此该代理与该目标对象表面上可以被当作同一个对象来对待。</p>
<p>代理允许你拦截在目标对象上的底层操作，而这原本是 <strong>JS</strong> 引擎的内部能力。拦截行为使用了一个能够响应特定操作的函数（被称为陷阱）。</p>
<p>被 <code>Reflect</code> 对象所代表的反射接口，是给底层操作提供默认行为的方法的集合，这些操作是能够被代理重写的。每个代理陷阱都有一个对应的反射方法，每个方法都与对应的陷阱函数同名，并且接收的参数也与之一致。并且接收的参数也与之一致。下表总结了这些行为：</p>
<blockquote>
<p><img src="/img.png" alt="Reflect"> </p>
</blockquote>
<h3 id="创建一个简单的代理"><a href="#创建一个简单的代理" class="headerlink" title="创建一个简单的代理"></a>创建一个简单的代理</h3><p>当使用 <code>Proxy</code> 构造器来创建一个代理时，需要传递两个参数：目标对象以及一个处理器（<strong>handler</strong>），后者是定义了一个或多个陷阱函数的对象。如果未提供陷阱函数，代理会对所有操作采取默认行为。</p>
<p>为了创建一个仅进行传递的代理，你需要使用不包含任何陷阱函数的处理器：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;&#125;)</span><br><span class="line"></span><br><span class="line">proxy.name = <span class="string">"proxy"</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name)  <span class="comment">// proxy</span></span><br><span class="line"><span class="built_in">console</span>.log(target.name) <span class="comment">// proxy</span></span><br><span class="line"></span><br><span class="line">proxy.name = <span class="string">"target"</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name)  <span class="comment">// target</span></span><br><span class="line"><span class="built_in">console</span>.log(target.name) <span class="comment">// target</span></span><br></pre></td></tr></table></figure>

<p>该例中的 <code>proxy</code> 代理对象进行的所有操作最终都会传递给 <code>target</code> 目标对象。因此当我们为 <code>proxy</code> 代理对象添加 <code>name</code> 属性时，<code>target</code> 目标对象也会进行相应的变化。当然，缺少陷阱函数的代理没有什么用处，但是如果我们为它定义一个陷阱函数呢？</p>
<h3 id="使用-set-陷阱函数验证属性值"><a href="#使用-set-陷阱函数验证属性值" class="headerlink" title="使用 set 陷阱函数验证属性值"></a>使用 set 陷阱函数验证属性值</h3><p>假如我们想要创建一个对象，并且规定该对象的属性值必须是数值，这就意味着我们每次新增属性的时候都要进行验证，并且在属性值不为数值类型的时候抛出错误。</p>
<p>我们可以使用 <code>set</code> 陷阱函数来重写设置属性值时的默认行为，该陷阱函数能接受四个参数：</p>
<ol>
<li><code>trapTarget</code>：将接收属性的对象（即代理的目标对象）；</li>
<li><code>key</code>：需要写入的属性的键（字符串类型或符号类型）；</li>
<li><code>value</code>：将被写入属性的值；</li>
<li><code>receiver</code>：操作发生的对象（通常是代理对象）；</li>
</ol>
<p><code>Reflect.set()</code> 是 <code>set</code> 陷阱函数对应的反射方法，同时也是 <code>set</code> 操作的默认行为。<br><code>Reflect.set()</code> 方法与 <code>set</code> 陷阱函数一样，能接受这四个参数，让该方法能在陷阱函数内部被方便使用。。该陷阱函数需要在属性被设置完成的情况下返回 <code>true</code> ，否则就要返回 <code>false</code>，而 <code>Reflect.set()</code> 也会基于操作是否成功而返回相应的结果。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">    name: <span class="string">"target"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="keyword">set</span>(trapTarget, key, value, receiver) &#123;</span><br><span class="line">        <span class="comment">// 忽略已有属性，避免影响它们</span></span><br><span class="line">        <span class="keyword">if</span>(!trapTarget.hasOwnProperty(key)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isNaN</span>(value)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Property must be a number."</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加属性</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(trapTarget, key, value, receiver)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个新属性，且添加的属性值为 number 类型</span></span><br><span class="line">proxy.count = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.count)  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(target.count) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为已存在属性 name 赋值一个非数值类型的值</span></span><br><span class="line">proxy.name = <span class="string">"name"</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name)  <span class="comment">// name</span></span><br><span class="line"><span class="built_in">console</span>.log(target.name) <span class="comment">// name</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出错误</span></span><br><span class="line">proxy.num = <span class="string">"num"</span></span><br></pre></td></tr></table></figure>

<p>这段代码定义了一个代理陷阱，用于对 <code>target</code> 对象新增属性的值进行验证。此代码只验证新增属性的值，当我们为新增值添加一个非 <code>Number</code> 类型的值时，会抛出错误。</p>
<p>使用 <code>set</code> 代理陷阱允许我们在写入属性值的时候进行拦截，而 <code>get</code> 代理陷阱则允许我们在读取属性值的时候进行拦截。</p>
<h3 id="使用-get-陷阱函数进行对象外形验证"><a href="#使用-get-陷阱函数进行对象外形验证" class="headerlink" title="使用 get 陷阱函数进行对象外形验证"></a>使用 get 陷阱函数进行对象外形验证</h3><p><strong>JS</strong> 语言有趣但有时却令人困惑的特性之一，就是读取对象不存在的属性时并不会抛出错误，而是会把 <code>undefined</code> 当作该属性的值。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>对象外形（<strong>Object Shape</strong>）指的是对象已有的属性与方法的集合。使用 <code>get</code> 陷阱函数，该陷阱函数会在读取属性时被调用，即使该属性在对象中并不存在，它能接受三个参数：</p>
<ol>
<li><code>trapTarget</code>：将接收属性的对象（即代理的目标对象）；</li>
<li><code>key</code>：需要读取的属性的键（字符串类型或符号类型）；</li>
<li><code>receiver</code>：操作发生的对象（通常是代理对象）；</li>
</ol>
<p><code>Reflect.get()</code> 方法同样接收这三个参数，并且默认会返回属性的值。</p>
<p>我们可以通过 <code>get</code> 陷阱函数与 <code>Reflect.get()</code> 方法在目标属性不存在时抛出错误。如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">    name: <span class="string">"target"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="keyword">get</span>(tarpTarget, key, receiver) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(key <span class="keyword">in</span> receiver)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Property "</span> + key + <span class="string">" doesn't exist."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(tarpTarget, key, receiver)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name) <span class="comment">// target</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// nme 属性不存在抛出错误</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.nme)</span><br></pre></td></tr></table></figure>

<p>在此处的例子中我们使用了 <code>in</code> 来判断 <code>receiver</code> 是否存在对应的属性，之所以使用 <code>receiver</code> 并没有使用 <code>tarpTarget</code>，而是用了 <code>in</code> ，这是因为 <code>receiver</code> 本身就是拥有一个 <code>has</code> 陷阱函数的代理对象，在此处使用 <code>trapTarget</code> 会跳过 <code>has</code> 陷阱函数数，并可能给你一个错误的结果。</p>
<h3 id="使用-has-陷阱函数隐藏属性"><a href="#使用-has-陷阱函数隐藏属性" class="headerlink" title="使用 has 陷阱函数隐藏属性"></a>使用 has 陷阱函数隐藏属性</h3><p><code>in</code> 运算符用于判定指定对象中是否存在某个属性，如果对象的属性名与指定的字符串或符号值想匹配，那么 <code>in</code> 运算符应当返回 <code>true</code>，无论该属性是对象自身的属性还是其原型的属性。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    name: <span class="string">"zzzhim"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">Object</span>.create(obj1)</span><br><span class="line"></span><br><span class="line">obj2.sex = <span class="string">"男"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> obj2) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"sex"</span> <span class="keyword">in</span> obj2)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>has</code> 陷阱函数会在使用 <code>in</code> 运算符的情况下被调用，并且会被传入两个参数：</p>
<ol>
<li><code>trapTarget</code>：需要读取属性的对象（即代理的目标对象）；</li>
<li><code>key</code>：需要检查的属性的键（字符串类型或者符号类型）；</li>
</ol>
<p><code>Reflect.has()</code> 方法接受与之相同的参数，并向 <code>in</code> 运算符返回默认的响应结果。使用 <code>has</code> 陷阱函数以及 <code>Reflect.has()</code> 方法，允许你修改部分属性在接受 <code>in</code> 检测时的行为，但保留其他属性的默认行为。</p>
<p>如下，我们想要隐藏某个属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">    name: <span class="string">"target"</span>,</span><br><span class="line">    value: <span class="number">23</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    has(trapTarget, key) &#123;</span><br><span class="line">        <span class="keyword">if</span>(key === <span class="string">"value"</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.has(trapTarget, key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"value"</span> <span class="keyword">in</span> proxy)    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> proxy)     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"toString"</span> <span class="keyword">in</span> proxy) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"valueOf"</span> <span class="keyword">in</span> proxy)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>我们使用 <code>has</code> 陷阱函数检测 <code>key</code> 的值是否为 <code>&quot;value&quot;</code>。如果是，则返回 <code>false</code>，否则返回默认结果。</p>
<h3 id="使用-deleteProperty-陷阱函数避免属性被删除"><a href="#使用-deleteProperty-陷阱函数避免属性被删除" class="headerlink" title="使用 deleteProperty 陷阱函数避免属性被删除"></a>使用 deleteProperty 陷阱函数避免属性被删除</h3><p><code>delete</code> 运算符能够从指定对象上删除一个属性，在删除成功时返回 <code>true</code> ，否则返回 <code>false</code>。如果试图用 <code>delete</code> 运算符去删除一个不可配置的属性，在严格模式下将会抛出错误；非严格模式下只是单纯返回 <code>false</code>。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">    name: <span class="string">"target"</span>,</span><br><span class="line">    value: <span class="number">23</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(target, <span class="string">"name"</span>, &#123;</span><br><span class="line">    configurable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"value"</span> <span class="keyword">in</span> target) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = <span class="keyword">delete</span> target.value;</span><br><span class="line"><span class="built_in">console</span>.log(result1) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"value"</span> <span class="keyword">in</span> target) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 严格模式下抛错</span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="keyword">delete</span> target.name</span><br><span class="line"><span class="built_in">console</span>.log(result2) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> target) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>deleteProperty</code> 陷阱函数会在使用 <code>delete</code> 运算符去删除对象属性时下被调用，并且会被传入两个参数：</p>
<ol>
<li><code>tarpTarget</code>：需要删除属性的对象（即代理的目标对象）；</li>
<li><code>key</code>：需要删除的属性的键（字符串类型或者符号类型）；</li>
</ol>
<p><code>Reflect.deleteProperty()</code> 方法也接受这两个参数，并提供了 <code>deleteProperty</code> 陷阱函数的默认实现。我们可以结合 <code>Reflect.deleteProperty()</code> 方法以及 <code>deleteProperty</code> 陷阱函数，来修改 <code>delete</code> 运算符的行为。</p>
<p>如下，我们使用它们确保 <code>value</code> 属性不能被删除：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">    name: <span class="string">"target"</span>,</span><br><span class="line">    value: <span class="number">23</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    deleteProperty(trapTarget, key) &#123;</span><br><span class="line">        <span class="keyword">if</span>(key === <span class="string">"value"</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.deleteProperty(trapTarget, key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试删除 value 属性</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"value"</span> <span class="keyword">in</span> proxy)   <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> result1 = <span class="keyword">delete</span> proxy.value</span><br><span class="line"><span class="built_in">console</span>.log(result1)            <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"value"</span> <span class="keyword">in</span> proxy)   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试删除 proxy.name</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> proxy)    <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="keyword">delete</span> proxy.name</span><br><span class="line"><span class="built_in">console</span>.log(result2)            <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> proxy)    <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>这段代码允许我们在严格模式下保护属性避免其被删除，并且不会抛出错误。</p>
<h3 id="原型代理的陷阱函数"><a href="#原型代理的陷阱函数" class="headerlink" title="原型代理的陷阱函数"></a>原型代理的陷阱函数</h3><p>代理允许通过 <code>setPrototypeOf</code> 与 <code>getPrototypeOf</code> 陷阱函数来对这两个方法的操作进行拦截。<code>Object</code> 对象上的这两个方法都会调用代理中对应名称的陷阱函数，从而允许你改变这两个方法的行为。</p>
<p>由于存在着两个陷阱函数与原型代理相关联，因此分别有一组方法对应着每个陷阱函数。</p>
<p><code>setPrototypeOf</code> 陷阱函数接受两个参数：</p>
<ol>
<li><code>tarpTarget</code>：需要设置原型的对象（即代理的目标对象）；</li>
<li><code>proto</code>：被用作原型的对象；</li>
</ol>
<p><code>Object.setPrototypeOf()</code> 方法与 <code>Reflect.setPrototypeOf()</code> 方法会被传入相同的参数。另一方面， <code>getPrototypeOf</code> 陷阱函数只接受 <code>trapTarget</code> 参数， <code>Object.getPrototypeOf()</code> 方法与 <code>Reflect.getPrototypeOf()</code> 方法也是如此。</p>
<blockquote>
<p>原文的例子如下：<br>下面这个例子通过返回 <code>null</code> 隐藏了代理对象的原型，并且使得该原型不可被修改：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    getPrototypeOf(trapTarget) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    setPrototypeOf(trapTarget, proto) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> targetProto = <span class="built_in">Object</span>.getPrototypeOf(target);</span><br><span class="line"><span class="keyword">let</span> proxyProto = <span class="built_in">Object</span>.getPrototypeOf(proxy);</span><br><span class="line"><span class="built_in">console</span>.log(targetProto === <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(proxyProto === <span class="built_in">Object</span>.prototype); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(proxyProto); <span class="comment">// null</span></span><br><span class="line"><span class="comment">// 成功</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(target, &#123;&#125;);</span><br><span class="line"><span class="comment">// 抛出错误</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(proxy, &#123;&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当我试图在控制台执行原文的例子时，Chrome浏览器会抛出 <code>&#39;getPrototypeOf&#39; on proxy: trap returned neither object nor null</code> ，原因是因为在 <code>getPrototypeOf</code> 返回了一个 <code>null</code>，具体为什么会抛出错误，我也没有找到原因。因此我在上述例子中稍微做了一些修改：</p>
</blockquote>
<p>下面的例子通过返回原型为 <code>null</code> 的空对象，隐藏了代理对象的原型，并且使得该原型不可被修改：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    getPrototypeOf(trapTarget) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    setPrototypeOf(trapTarget, proto) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxyProto = <span class="built_in">Object</span>.getPrototypeOf(proxy)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxyProto) <span class="comment">// 原型为 `null` 的空对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出错误</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(proxy, &#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>如果我们想在两个陷阱函数中使用默认的行为，那么只需调用 <code>Reflect</code> 对象上的相应方法。如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    getPrototypeOf(trapTarget) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.getPrototypeOf(trapTarget)</span><br><span class="line">    &#125;,</span><br><span class="line">    setPrototypeOf(trapTarget, proto) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.setPrototypeOf(trapTarget, proto)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> targetProto = <span class="built_in">Object</span>.getPrototypeOf(target)</span><br><span class="line"><span class="keyword">let</span> proxyProto =  <span class="built_in">Object</span>.getPrototypeOf(proxy)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(targetProto === <span class="built_in">Object</span>.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(proxyProto === <span class="built_in">Object</span>.prototype)  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(target, &#123;&#125;)</span><br><span class="line"><span class="comment">// 同样成功</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(proxy, &#123;&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="两组方法的不同之处"><a href="#两组方法的不同之处" class="headerlink" title="两组方法的不同之处"></a>两组方法的不同之处</h3><p><code>Reflect.getPrototypeOf()</code> 和 <code>Reflect.setPrototypeOf</code> 虽然看起来与 <code>Object.getPrototypeOf()</code> 和 <code>Object.setPrototypeOf</code> 很相似，但它们两个之间仍然有着显著差异。</p>
<p>首先 <code>Object.getPrototypeOf()</code> 和 <code>Object.setPrototypeOf</code> 属于高级操作，从产生之初便已提供给开发者使用；而 <code>Reflect.getPrototypeOf()</code> 和 <code>Reflect.setPrototypeOf</code> 属于底层操作，允许开发者访问 <code>[[GetPrototypeOf]]</code> 与 <code>[[SetPrototypeOf]]</code> 这两个原先仅供语言内部使用的操作。</p>
<p><code>Reflect.getPrototypeOf()</code> 方法是对内部的 <code>[[GetPrototypeOf]]</code> 操作的封装（并且附加了一些输入验证），而 <code>Reflect.setPrototypeOf()</code> 方法与 <code>[[SetPrototypeOf]]</code> 操作之间也有类似的关系。</p>
<p>虽然 <code>Object</code> 对象上的同名方法也调用了 <code>[[GetPrototypeOf]]</code> 与 <code>[[SetPrototypeOf]]</code> ，但它们在调用这两个操作之前添加了一些步骤、并检查返回值，以决定如何行动。</p>
<p><code>Reflect.getPrototypeOf()</code> 方法在接收到的参数不是一个对象时会抛出错误，而 <code>Object.getPrototypeOf()</code> 则会在操作之前先将参数值转换为一个对象。如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = <span class="built_in">Object</span>.getPrototypeOf(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result === <span class="built_in">Number</span>.prototype) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛错</span></span><br><span class="line"><span class="built_in">Reflect</span>.getPrototypeOf(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><code>Reflect.setPrototypeOf()</code> 方法方法返回一个布尔值用于表示操作是否已成功，成功时返回 <code>true</code> ，失败时返回 <code>false</code>； <code>Object.setPrototypeOf()</code> 方法的操作失败时，它会抛出错误。<code>Object.setPrototypeOf()</code> 方法会将传入的第一个参数作为自身的返回值，因此并不适合用来实现 <code>setPrototypeOf</code> 代理陷阱的默认行为。如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target1 = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> result1 = <span class="built_in">Object</span>.setPrototypeOf(target1, &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result1 === target1) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> target2 = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> result2 = <span class="built_in">Reflect</span>.setPrototypeOf(target2, &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result2 === target2) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(result2) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="对象可扩展性的陷阱函数"><a href="#对象可扩展性的陷阱函数" class="headerlink" title="对象可扩展性的陷阱函数"></a>对象可扩展性的陷阱函数</h3><p>ES5 通过 <code>Object.preventExtensions()</code> 与 <code>Object.isExtensible()</code> 方法给对象增加了可扩展<br>性。</p>
<p>ES6 通过 <code>preventExtensions</code> 与 <code>isExtensible</code> 陷阱函数允许代理拦截对于底层对象的方法调用。这两个陷阱函数都接受名为 <code>trapTarget</code> 的单个参数，此参数代表方法在哪个对象上被调用。同时 <code>Reflect</code> 上面也存在对应的  <code>Reflect.preventExtensions()</code> 与 <code>Reflect.isExtensible()</code> 方法，用于实现默认的行为。这两个方法都返回布尔值，因此它们可以在对应的陷阱函数内直接使用。</p>
<blockquote>
<p><code>Object.isExtensible()</code> 方法判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）。</p>
<p><code>Object.preventExtensions()</code> 方法让一个对象变的不可扩展，也就是永远不能再添加新的属性。</p>
</blockquote>
<h6 id="两个基本范例"><a href="#两个基本范例" class="headerlink" title="两个基本范例"></a>两个基本范例</h6><p>下列代码实现了 <code>isExtensible</code> 与 <code>preventExtensions</code> 陷阱函数的默认行为。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    isExtensible(trapTarget) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.isExtensible(trapTarget)</span><br><span class="line">    &#125;,</span><br><span class="line">    preventExtensions(trapTarget) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.preventExtensions(trapTarget)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(target)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(proxy)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常运行</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(target, <span class="string">"name"</span>, &#123; <span class="attr">value</span>: <span class="string">"zzzhim"</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让对象变得不可扩展</span></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(proxy)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(target)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(proxy)) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出错误：Cannot define property value, object is not extensible</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(target, <span class="string">"value"</span>, &#123; <span class="attr">value</span>: <span class="number">111</span> &#125;)</span><br></pre></td></tr></table></figure>

<p>我们也可以在 <code>preventExtensions</code> 陷阱函数上返回 <code>false</code>，来让代理上的 <code>Object.preventExtensions()</code> 操作失败。如下：</p>
<blockquote>
<p>原文代码如下：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    isExtensible(trapTarget) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.isExtensible(trapTarget)</span><br><span class="line">    &#125;,</span><br><span class="line">    preventExtensions(trapTarget) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(target)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(proxy)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(proxy)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(target)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(proxy)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>此代码在 <code>Chrome</code> 和 <code>FireFox</code> 执行时分别会抛出 <code>&#39;preventExtensions&#39; on proxy: trap returned falsish at Function.preventExtensions</code> 和 <code>proxy preventExtensions handler returned false</code> 错误。</p>
</blockquote>
<p>!&gt; <code>Object.isExtensible()</code> 方法与 <code>Reflect.isExtensible()</code> 方法几乎一样，只在接收到的参数不是一个对象时才有例外。此时 <code>Object.isExtensible()</code> 总是会返回 <code>false</code> ，而 <code>Reflect.isExtensible()</code> 则会抛出一个错误。</p>
<h3 id="属性描述符的陷阱函数"><a href="#属性描述符的陷阱函数" class="headerlink" title="属性描述符的陷阱函数"></a>属性描述符的陷阱函数</h3><p>ES5 的最重要的特征之一就是引入了 <code>Object.defineProperty()</code> 方法用于定义属性的特征，它能让我们直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并且能让属性变成只读或是不可枚举的。我们还可以利用 <code>Object.getOwnPropertyDescriptor()</code> 方法检索这些特性。</p>
<p>代理允许我们使用 <code>defineProperty</code> 与 <code>getOwnPropertyDescriptor</code> 陷阱函数，来分别拦截对于 <code>Object.defineProperty()</code> 与 <code>Object.getOwnPropertyDescriptor()</code>。</p>
<p><code>defineProperty</code> 陷阱函数接受下列三个参数：</p>
<ol>
<li><code>trapTarget</code> ：需要被定义属性的对象（即代理的目标对象）；</li>
<li><code>key</code> ：属性的键（字符串类型或符号类型）；</li>
<li><code>descriptor</code> ：为该属性准备的描述符对象。</li>
</ol>
<p><code>defineProperty</code> 陷阱函数要求你在操作成功时返回 <code>true</code> ，否则返回 <code>false</code> 。 <code>getOwnPropertyDescriptor</code> 陷阱函数则只接受 <code>trapTarget</code> 与 <code>key</code> 这两个参数，并会返回对应的描述符。 <code>Reflect.defineProperty()</code> 与 <code>Reflect.getOwnPropertyDescriptor()</code> 方法作为上述陷阱函数的对应方法，接受与之相同的参数。</p>
<p>此代码实现了每个陷阱函数的默认行为，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    defineProperty(trapTarget, key, descriptor) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.defineProperty(trapTarget, key, descriptor)</span><br><span class="line">    &#125;,</span><br><span class="line">    getOwnPropertyDescriptor(trapTarget, key) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.getOwnPropertyDescriptor(trapTarget, key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(proxy, <span class="string">"name"</span>, &#123;</span><br><span class="line">    value: <span class="string">"zzzhim"</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name) <span class="comment">// "zzzhim"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="string">"name"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(descriptor.value) <span class="comment">// "zzzhim"</span></span><br></pre></td></tr></table></figure>

<h3 id="阻止-Object-defineProperty"><a href="#阻止-Object-defineProperty" class="headerlink" title="阻止 Object.defineProperty()"></a>阻止 Object.defineProperty()</h3><p><code>defineProperty</code> 陷阱函数要求你返回一个布尔值用于表示操作是否已成功。当它返回 <code>true</code> 时， <code>Object.defineProperty()</code> 会正常执行；如果它返回 <code>false</code> ，则会抛出错误。我们可以利用这个特性，来限制可以被 <code>Object.defineProperty()</code> 的属性。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    defineProperty(trapTarget, key, descriptor) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> key === <span class="string">"symbol"</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.defineProperty(trapTarget, key, descriptor)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> symbol = <span class="built_in">Symbol</span>(<span class="string">"name"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出错误</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(proxy, symbol, &#123;</span><br><span class="line">    value: <span class="string">"zzzhim"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当 <code>key</code> 值为 <code>Symbol</code> 类型时，我们在 <code>defineProperty</code> 陷阱函数中返回 <code>false</code>，导致程序抛出错误。</p>
<blockquote>
<p>你可以让陷阱函数返回 <code>true</code> ，同时不去调用 <code>Reflect.defineProperty()</code> 方法，这样 <code>Object.defineProperty()</code> 就会静默失败，如此便可在未实际去定义属性的情况下抑制运行错误。</p>
</blockquote>
<h3 id="描述符对象的限制"><a href="#描述符对象的限制" class="headerlink" title="描述符对象的限制"></a>描述符对象的限制</h3><p>为了确保 <code>Object.defineProperty()</code> 与 <code>Object.getOwnPropertyDescriptor()</code> 方法的行为一致，传递给 <code>defineProperty</code> 陷阱函数的描述符对象必须是正规的。出于同一原因， <code>getOwnPropertyDescriptor</code> 陷阱函数返回的对象也始终需要被验证。</p>
<p>任意对象都能作为 <code>Object,defineProperty()</code> 方法的第三个参数；然而能够传递给 <code>defineProperty</code> 陷阱函数的描述对象参数，则只有 <code>enumerable</code>、 <code>configurable</code> 、 <code>value</code> 、 <code>writable</code> 、 <code>get</code> 与 <code>set</code> 这些属性。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    defineProperty(trapTarget, key, descriptor) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(descriptor) <span class="comment">// 描述对象输出 &#123;&#123; value: value &#125;&#125; 并没有 name 属性</span></span><br><span class="line">        <span class="keyword">return</span>  <span class="built_in">Reflect</span>.defineProperty(trapTarget, key, descriptor)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(proxy, <span class="string">"name"</span>, &#123;</span><br><span class="line">    value: <span class="string">"value"</span>,</span><br><span class="line">    name: <span class="string">"zzzhim"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>getOwnPropertyDescriptor</code> 陷阱函数有一个微小差异，要求返回值必须是 <code>null</code> 、 <code>undefined</code> ，或者是一个对象。当返回值是一个对象时，只允许该对象拥有 <code>enumerable</code>、 <code>configurable</code> 、 <code>value</code> 、 <code>writable</code> 、 <code>get</code> 与 <code>set</code> 这些属性。如果返回的对象包含了不被许可的自有属性，则程序会抛出错误。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    getOwnPropertyDescriptor(trapTarget, key) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            name: <span class="string">"zzzhim"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛错</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="string">"name"</span>)</span><br></pre></td></tr></table></figure>

<p>?&gt; <code>Object.getOwnPropertyDescriptor()</code> 的返回值总是拥有可信任的结构，无论是否使用了代理。</p>
<h3 id="重复的描述符方法"><a href="#重复的描述符方法" class="headerlink" title="重复的描述符方法"></a>重复的描述符方法</h3><h6 id="defineProperty-方法"><a href="#defineProperty-方法" class="headerlink" title="defineProperty() 方法"></a>defineProperty() 方法</h6><p><code>Object.defineProperty()</code> 方法与 <code>Reflect.defineProperty()</code> 方法几乎一模一样，只是返回值有区别。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> result1 = <span class="built_in">Object</span>.defineProperty(target, <span class="string">"name"</span>, &#123; <span class="attr">value</span>: <span class="string">"target"</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(target === result1) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="built_in">Reflect</span>.defineProperty(target, <span class="string">"name"</span>, &#123; <span class="attr">value</span>: <span class="string">"target"</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result2) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>?&gt; 如上，前者返回的是调用它时的第一个参数，而后者在操作成功时返回 <code>true</code> 、失败时返回 <code>false</code>。</p>
<h6 id="getOwnPropertyDescriptor-方法"><a href="#getOwnPropertyDescriptor-方法" class="headerlink" title="getOwnPropertyDescriptor() 方法"></a>getOwnPropertyDescriptor() 方法</h6><p><code>Object.getOwnPropertyDescriptor()</code> 方法会在接收的第一个参数是基本类型值时，将该参数转化为对象。而 <code>Reflect.getOwnPropertyDescriptor()</code> 方法则会在第一个参数是基本类型值的时候抛出错误。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> descriptor1 = <span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="number">2</span>, <span class="string">"name"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(descriptor1) <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 抛出错误</span></span><br><span class="line"><span class="keyword">let</span> descriptor2 = <span class="built_in">Reflect</span>.getOwnPropertyDescriptor(<span class="number">2</span>, <span class="string">"name"</span>)</span><br></pre></td></tr></table></figure>

<h3 id="ownKeys-陷阱函数"><a href="#ownKeys-陷阱函数" class="headerlink" title="ownKeys 陷阱函数"></a>ownKeys 陷阱函数</h3><p><code>ownKeys</code> 代理陷阱拦截了内部方法 <code>[[OwnPropertyKeys]]</code> ，并允许你返回一个数组用于重写该行为。返回的这个数组会被用于四个方法：</p>
<ol>
<li><code>Object.keys()</code> 方法；</li>
<li><code>Object.getOwnPropertyNames()</code> 方法；</li>
<li><code>Object.getOwnPropertySymbols()</code> 方法；</li>
<li><code>Object.assign()</code> 方法；</li>
</ol>
<p>?&gt; 其中 <code>Object.assign()</code> 方法会使用该数组来决定哪些属性会被复制。</p>
<p><code>ownKeys</code> 陷阱函数的默认行为由 <code>Reflect.ownKeys()</code> 方法实现，会返回一个由全部自有属性的键构成的数组，无论键的类型是字符串还是符号。</p>
<p><code>Object.getOwnPropertyNames()</code> 方法与 <code>Object.keys()</code> 方法会将符号值从该数组中过滤出去；</p>
<p><code>Object.getOwnPropertySymbols()</code> 会将字符串值过滤掉；</p>
<p><code>Object.assign()</code> 方法会使用数组中所有的字符串值与符号值；</p>
<p><code>ownKeys</code> 陷阱函数接受单个参数，即目标对象，同时必须返回一个数组或者一个类数组对象，不合要求的返回值会导致错误。我们可以使用 <code>ownKeys</code> 陷阱函数去过滤特定的属性，以避免这些属性被 <code>Object.keys()</code> 方法，<code>Object.getOwnPropertyNames()</code> 、<code>Object.getOwnPropertySymbols()</code> 、<code>Object.assign()</code>方法使用。</p>
<p>如下，我们过滤掉名为 <code>name</code> 的属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    ownKeys(trapTarget) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.ownKeys(trapTarget).filter(<span class="function"><span class="params">key</span> =&gt;</span> key !== <span class="string">"name"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">proxy.name = <span class="string">"zzzhim"</span></span><br><span class="line">proxy.age = <span class="number">23</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(proxy)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(keys) <span class="comment">// [ age ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> names = <span class="built_in">Object</span>.getOwnPropertyNames(proxy)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(names) <span class="comment">// [ age ]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>ownKeys</code> 陷阱函数也能影响 <code>for-in</code> 循环，因为这种循环调用了陷阱函数来决定哪些值能够被用在循环内。</p>
</blockquote>
<h3 id="使用-apply-与-construct-陷阱函数的函数代理"><a href="#使用-apply-与-construct-陷阱函数的函数代理" class="headerlink" title="使用 apply 与 construct 陷阱函数的函数代理"></a>使用 apply 与 construct 陷阱函数的函数代理</h3><p>在所有的代理陷阱中，只有 <code>apply</code> 与 <code>construct</code> 要求代理目标对象必须是一个函数。</p>
<p>之前提到过，函数拥有两个内部方法：<code>[[Call]]</code> 与 <code>[[Construct]]</code> ，前者会在函数被直接调用时执行，而后者会在函数被使用 <code>new</code> 运算符调用时执行。<code>[[Call]]</code> 会在函数被直接调用时执行，而后者会在函数被使用 <code>new</code> 运算符调用时执行。</p>
<p><code>apply</code> 与 <code>construct</code> 陷阱函数对应着这两个内部方法，并允许我们对其进行重写。当不使用 <code>new</code> 去调用一个函数时， <code>apply</code> 陷阱函数会接收到下列三个参数（<code>Reflect.apply()</code> 也会接收这些参数）：</p>
<ol>
<li><code>trapTarget</code>：被执行的函数（即代理的目标对象）；</li>
<li><code>thisArg</code>：调用过程中函数内部的 <code>this</code> 值；</li>
<li><code>argumentsList</code>：被传递给函数的参数数组；</li>
</ol>
<p>当使用 <code>new</code> 去执行函数时，<code>construct</code> 陷阱函数会被调用并接收到下列两个参数：</p>
<ol>
<li><code>trapTarget</code>：被执行的函数（即代理的目标对象）；</li>
<li><code>argumentsList</code>：被传递给函数的参数数组；</li>
</ol>
<p><code>Reflect.construct()</code> 方法同样会接收到这两个参数，还会收到可选的第三个参数 <code>newTarget</code>，如果提供了此参数，则它就指定了函数内部的 <code>new.target</code> 值。</p>
<p><code>apply</code> 与 <code>construct</code>陷阱函数结合起来就能够完全控制任意目标对象函数的行为。</p>
<p>模拟函数的默认行为，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> targetFun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">23</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(targetFun, &#123;</span><br><span class="line">    apply(trapTarget, thisArg, argumentsList) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(trapTarget, thisArg, argumentsList)</span><br><span class="line">    &#125;,</span><br><span class="line">    construct(trapTarget, argumentsList) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.construct(trapTarget, argumentsList)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用了函数的代理，其目标对象会被视为函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> proxy) <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy()) <span class="comment">// 23</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> proxy()</span><br><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> proxy) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> targetFun) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="验证函数的参数"><a href="#验证函数的参数" class="headerlink" title="验证函数的参数"></a>验证函数的参数</h3><p><code>apply</code> 与 <code>construct</code> 陷阱函数在函数的执行方式上开启了很多的可能性。</p>
<p>如下，我们可以通过 <code>apply</code> 陷阱函数保证参数必须是数值类型，并且函数不能使用 <code>new</code> 调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params">...values</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(values)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sumProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(sum, &#123;</span><br><span class="line">    apply(trapTarget, thisArg, argumentsList) &#123;</span><br><span class="line">        argumentsList.forEach(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> value !== <span class="string">"number"</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"All arguments must be numbers."</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(trapTarget, thisArg, argumentsList)</span><br><span class="line">    &#125;,</span><br><span class="line">    construct(trapTarget, argumentsList) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"This function can't be called with new."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sumProxy(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)) <span class="comment">// [ 1, 2, 3, 4 ]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sumProxy(<span class="string">"1"</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">"4"</span>)) <span class="comment">// 抛错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newSum = <span class="keyword">new</span> sumProxy()  <span class="comment">// 抛错</span></span><br></pre></td></tr></table></figure>

<p>相反的，你也可以限制函数必须使用 <code>new</code> 运算符调用，同时确保它的参数都是数值。</p>
<h3 id="调用构造器而无须使用-new"><a href="#调用构造器而无须使用-new" class="headerlink" title="调用构造器而无须使用 new"></a>调用构造器而无须使用 new</h3><p>前面介绍了我们可以通过 <code>new.target</code> 来判断函数是否使用了 <code>new</code>。就像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Numbers</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">new</span>.target === <span class="string">"undefined"</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"This function must be called with new."</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.values = values</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> Numbers(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(instance.values) <span class="comment">// [ 1, 2, 3 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出错误</span></span><br><span class="line">Numbers(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>上面的这个例子，<code>Numbers</code> 函数必须要使用 <code>new</code> 才能够正常执行，在用户不知情的情况下，通常会造成不必要的错误。我们可以使用 <code>apply</code> 陷阱函数来规避必须使用 <code>new</code> 调用这个限制，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Numbers</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">new</span>.target === <span class="string">"undefined"</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"This function must be called with new."</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.values = values</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(Numbers, &#123;</span><br><span class="line">    apply(trapTarget, thisArg, argumentsList) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.construct(trapTarget, argumentsList)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance1 = <span class="keyword">new</span> proxy(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(instance1.values) <span class="comment">// [ 1, 2, 3 ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance2 = proxy(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(instance2.values) <span class="comment">// [ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure>

<p><code>proxy</code> 函数允许我们调用 <code>Numbers</code> 并且无须使用 <code>new</code> ，并且这种调用方式的效果与使用 <code>new</code> 是完全一致的。</p>
<h3 id="可被调用的类构造器"><a href="#可被调用的类构造器" class="headerlink" title="可被调用的类构造器"></a>可被调用的类构造器</h3><p>前面说明了构造器必须始终使用 <code>new</code> 来调用，原因是类构造器的内部方法 <code>[[Call]]</code> 被明确要求抛出错误。然而代理可以拦截对于 <code>[[Call]]</code> 方法的调用，意味着我们可以借助代理创建一个可以被直接调用的类构造器。</p>
<p>如下，我们想让类构造器不使用 <code>new</code> 的情况下也能够正常工作，我们可以使用 <code>apply</code> 陷阱函数来创建一个新的实例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PersonProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(Person, &#123;</span><br><span class="line">    apply(trapTarget, thisArg, argumentsList) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> trapTarget(...argumentsList)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = PersonProxy(<span class="string">"zzzhim"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.name) <span class="comment">// zzzhim</span></span><br><span class="line"><span class="built_in">console</span>.log(obj <span class="keyword">instanceof</span> Person) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="可被撤销的代理"><a href="#可被撤销的代理" class="headerlink" title="可被撤销的代理"></a>可被撤销的代理</h3><p>代理在被创建之后，通常就不能再从目标对象上被解绑了。我之前使用的例子都是使用了不可被撤销的代理。</p>
<p>有些情况下我们可能想要撤销一个代理使它不能够再被使用。我们可以使用 <code>Proxy.revocable()</code> 方法来创建一个可被撤销的代理，该方法接收的参数与 <code>Proxy</code> 构造器相同：</p>
<ol>
<li><code>proxy</code>：可被撤销的代理对象；</li>
<li><code>revoke</code>：用于撤销代理的函数；</li>
</ol>
<p>当 <code>revoke()</code> 函数被调用后，就不能再对该 <code>proxy</code> 对象进行更多操作，任何与该代理对象交互的意图都会触发代理的陷阱函数，从而抛出一个错误。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    name: <span class="string">"zzzhim"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; proxy, revoke &#125; = <span class="built_in">Proxy</span>.revocable(target, &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name) <span class="comment">// zzzhim</span></span><br><span class="line"></span><br><span class="line">revoke()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出错误</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name)</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/16/js/proxy/" data-id="ck4bd0sr2000cmou175gvej74"
        class="article-share-link">分享</a>
      

    </footer>

  </div>

  
  
  <nav class="article-nav">
    
      <a href="/2019/12/16/js/promise/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            Promise与异步编程
          
        </div>
      </a>
    
    
      <a href="/2019/12/16/js/stringAndRegExp/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">字符串与正则表达式</div>
      </a>
    
  </nav>


  

  
  
<!-- valine评论 -->
<div id="vcomments-box">
    <div id="vcomments">
    </div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine@1.3.10/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#vcomments',
        notify: false,
        verify: false,
        app_id: 'pUhbbBIdkBPvVbR0iVMNbxKB-gzGzoHsz',
        app_key: '5hUYxDcuUwUe18KzRrGfF2mn',
        path: window.location.pathname,
        avatar: 'mp',
        placeholder: '给我的文章加点评论吧~',
        recordIP: true
    });
    const infoEle = document.querySelector('#vcomments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
        infoEle.childNodes.forEach(function (item) {
            item.parentNode.removeChild(item);
        });
    }
</script>
<style>
    #vcomments-box {
        padding: 5px 30px;
    }

    @media screen and (max-width: 800px) {
        #vcomments-box {
            padding: 5px 0px;
        }
    }

    #vcomments-box #vcomments {
        background-color: #fff;
    }

    .v .vlist .vcard .vh {
        padding-right: 20px;
    }

    .v .vlist .vcard {
        padding-left: 10px;
    }
</style>

  

  
  
  

</article>
</section>
      <footer>
  
</footer>


<!-- <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2019
        
      </li>
      <li>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <ul class="list-inline">
  <li>PV:<span id="busuanzi_value_page_pv"></span></li>
  <li>UV:<span id="busuanzi_value_site_uv"></span></li>
</ul>
        
      </li>
      <li> -->
        <!-- cnzz统计 -->
        <!-- 
      </li>
    </ul>
  </div>
</footer> -->
    <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
    
    <aside class="sidebar">
      
        <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <!-- <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt=""></a>
  </div> -->
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">目录</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
      </aside>
      
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>


  
<script src="/fancybox/jquery.fancybox.min.js"></script>




  
<script src="/js/tocbot.min.js"></script>

  <script>
    // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
    tocbot.init({
      tocSelector: '.tocbot',
      contentSelector: '.article-entry',
      headingSelector: 'h1, h2, h3, h4, h5, h6',
      hasInnerContainers: true,
      scrollSmooth: true,
      positionFixedSelector: '.tocbot',
      positionFixedClass: 'is-position-fixed',
      fixedSidebarOffset: 'auto',
    });
  </script>


<script>
  var ayerConfig = {
    mathjax: true
  }
</script>


<script src="/js/ayer.js"></script>



  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.bootcss.com/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  </div>
</body>

</html>