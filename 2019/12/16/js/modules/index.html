<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    用模块封装代码 |  
  </title>
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/css/style.css">
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
<script src="/js/pace.min.js"></script>


  

  

<meta name="generator" content="Hexo 4.1.1"><link rel="alternate" href="/atom.xml" title="" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    <main class="content">
      <section class="outer">
  <article id="es6-js/modules" class="article article-type-es6" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  用模块封装代码
</h1>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2019/12/16/js/modules/" class="article-date">
  <time datetime="2019-12-16T12:48:06.000Z" itemprop="datePublished">2019-12-16</time>
</a>
      
    </div>
    

    
    
    <div class="tocbot"></div>





    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="用模块封装代码"><a href="#用模块封装代码" class="headerlink" title="用模块封装代码"></a>用模块封装代码</h1><p>在 <strong>ES6</strong> 之前，一个应用的每个 <strong>JS</strong> 文件所定义的所有内容都由全局作用域共享。当应用变得非常复杂时，这会造成许多问题，例如命名冲突、安全问题等。<strong>ES6</strong> 的设计目标之一就是要解决作用域问题，让 <strong>JS</strong> 应用更加有条理，更容易维护。</p>
<h3 id="何为模块？"><a href="#何为模块？" class="headerlink" title="何为模块？"></a>何为模块？</h3><p>模块（<strong>Modules</strong>）是使用不同方法加载的 <strong>JS</strong> 文件（与 <strong>JS</strong> 原先的脚本加载方式相对）。这种不同模式很有必要，因为它与脚本（<strong>script</strong>） 有大大不同的语义：</p>
<ol>
<li>模块代码自动运行在严格模式下，并且没有任何办法跳出严格模式；</li>
<li>在模块的顶级作用域创建的变量，不会被自动添加到共享的全局作用域，它们只会在模块顶级作用域的内部存在；</li>
<li>模块顶级作用域的 <code>this</code> 值为 <code>undefined</code> ；</li>
<li>模块不允许在代码中使用 <strong>HTML</strong> 风格的注释（这是 <strong>JS</strong> 来自于早期浏览器的历史遗留特性）；</li>
<li>对于需要让模块外部代码访问的内容，模块必须导出它们；</li>
<li>允许模块从其他模块导入绑定。</li>
</ol>
<p>?&gt; 模块最重要的功能是可以按需导出与导入代码的能力，而不用将所有内容放在同一个文件内。</p>
<h3 id="基本的导出"><a href="#基本的导出" class="headerlink" title="基本的导出"></a>基本的导出</h3><p>想要把代码公开给其他模块，我们可以使用 <code>export</code> 关键字将代码导出给其他模块使用。最简单的方法就是把 <code>export</code> 放在函数、变量、类声明之前。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出变量</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> age = <span class="number">23</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> color = <span class="string">"red"</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">"zzzhim"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出类</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">React</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length</span><br><span class="line">        <span class="keyword">this</span>.width = width</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个私有函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面被导出的函数或者类都有自己的名称，这是因为导出的函数声明与类声明必须要有名称。想要导出一个匿名函数或匿名类，需要使用 <code>default</code> 关键字（后面会提到）。</p>
<p>!&gt; 在模块中未被导出的 变量、函数、类，在模块外部都不可被访问，这是因为它们在模块内是私有的。</p>
<h3 id="基本的导入"><a href="#基本的导入" class="headerlink" title="基本的导入"></a>基本的导入</h3><p>我们可以在模块内使用 <code>import</code> 关键字来访问其他模块导出的功能。</p>
<p><code>import</code> 语句有两个部分，一是需要导入的标识符，二是需要导入的标识符的来源模块。如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span></span><br></pre></td></tr></table></figure>

<p><code>import</code> 的花括号指明了从给定模块导入对应的绑定， <code>from</code> 关键字则指明了需要导入的模块。</p>
<p>?&gt; 当从模块导入了一个绑定时，该绑定表现的就像使用了 <code>const</code> 的定义。这意味着你不能再定义另一个同名变量（包括导入另一个同名绑定），也不能在对应的 <code>import</code> 语句之前使用此标识符（也就是要受到暂时性死区限制），更不能修改它的值。</p>
<h6 id="导入单个绑定"><a href="#导入单个绑定" class="headerlink" title="导入单个绑定"></a>导入单个绑定</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单个导入</span></span><br><span class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span></span><br></pre></td></tr></table></figure>

<h6 id="导入多个绑定"><a href="#导入多个绑定" class="headerlink" title="导入多个绑定"></a>导入多个绑定</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多个导入</span></span><br><span class="line"><span class="keyword">import</span> &#123; sum, React, age &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span></span><br></pre></td></tr></table></figure>

<h6 id="完全导入一个模块"><a href="#完全导入一个模块" class="headerlink" title="完全导入一个模块"></a>完全导入一个模块</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完全导入</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> example <span class="keyword">from</span> <span class="string">"./example.js"</span></span><br></pre></td></tr></table></figure>

<p>在此例中，<code>example.js</code> 中所有导出的绑定都会被加载到一个名为 <code>example</code> 的对象中。这种导入格式被称为命名空间导入（<strong>namespace import</strong>），这是因为该 <code>example</code> 对象并不存在于 <code>example.js</code> 文件中，而是作为一个命名空间对象被创建使用。</p>
<p>?&gt; 无论你对同一个模块使用了多少次 <code>import</code> 语句，该模块都只会被执行一次。在导出模块的代码执行之后，已被实例化的模块就被保留在内存中，并随时都能被其他 <code>import</code> 所引用。</p>
<blockquote>
<p>你只能在模块的顶级作用域使用 <code>export</code> 。类似的，你不能在一个语句内部使用 <code>import</code> ，也只能将其用在顶级作用域。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sum) &#123;</span><br><span class="line">    <span class="keyword">export</span> sum <span class="comment">// 语法错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tryImport</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span> <span class="comment">// 语法错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="重命名导出与导入"><a href="#重命名导出与导入" class="headerlink" title="重命名导出与导入"></a>重命名导出与导入</h6><p>假如我们想用不同的名称导出一个函数，我们可以使用 <code>as</code> 关键字来指定新的名称。如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出函数</span></span><br><span class="line"><span class="keyword">export</span> &#123; sum <span class="keyword">as</span> add &#125;</span><br></pre></td></tr></table></figure>

<p>在此处 <code>sum</code> 是本地名称（<strong>local name</strong>），后者则是导出名称（<strong>exported name</strong>）。这意味着当另一个模块想要导入此函数时，需要使用 <code>add</code> 这个名称。如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span></span><br></pre></td></tr></table></figure>

<p>如果模块导入函数时想使用另一个名称，同样也可以用 <code>as</code> 关键字：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; add <span class="keyword">as</span> sum &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> add) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h3 id="模块的默认值"><a href="#模块的默认值" class="headerlink" title="模块的默认值"></a>模块的默认值</h3><p>模块的默认值（<strong>default value</strong>）是使用 <code>default</code> 关键字所指定的单个变量、函数或类，在每个模块中只能设置一个默认导出，将 <code>default</code> 关键字用于多个导出会是语法错误。</p>
<h6 id="导出默认值"><a href="#导出默认值" class="headerlink" title="导出默认值"></a>导出默认值</h6><p>以下是使用 <code>default</code> 关键字的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出默认值</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此模块中我们将一个函数作为默认值导出， <code>default</code> 关键字标明了这是一个默认导出。此函数不需要名称，因为它就代表了这个模块自身。</p>
<p>我们也可以这样指定一个默认的导出，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出默认值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> sum</span><br></pre></td></tr></table></figure>

<h6 id="导入默认值"><a href="#导入默认值" class="headerlink" title="导入默认值"></a>导入默认值</h6><p>我们可以使用下列语法导入一个模块的默认值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入默认值</span></span><br><span class="line"><span class="keyword">import</span> sum <span class="keyword">from</span> <span class="string">"./example.js"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>对于即导出了默认值，又导出了非默认绑定的模块，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> color = <span class="string">"red"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出默认值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> sum</span><br></pre></td></tr></table></figure>

<p>我们可以使用这种方式导入非默认和默认值，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sum, &#123; color &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span></span><br></pre></td></tr></table></figure>

<h6 id="绑定的再导出"><a href="#绑定的再导出" class="headerlink" title="绑定的再导出"></a>绑定的再导出</h6><p>如果我们想把当前导入的模块再重新导出，只需这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sum, &#123; color &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; color &#125;</span><br></pre></td></tr></table></figure>

<p>当然我们也可以选择将一个值用不同名称导出：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; color <span class="keyword">as</span> red &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span></span><br></pre></td></tr></table></figure>

<p>如果我们想将来自另一个模块的所有值完全导出，可以使用星号（ * ）模式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">"./example.js"</span></span><br></pre></td></tr></table></figure>

<h3 id="无绑定的导入"><a href="#无绑定的导入" class="headerlink" title="无绑定的导入"></a>无绑定的导入</h3><p>有些模块也许没有进行任何导出，可能我们只需要它做一些适配处理。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">doc, win</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> docEl = doc.documentElement,</span><br><span class="line">        resizeEvt = <span class="string">'orientationchange'</span> <span class="keyword">in</span> <span class="built_in">window</span> ? <span class="string">'orientationchange'</span> : <span class="string">'resize'</span>,</span><br><span class="line">        recalc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> clientWidth = docEl.clientWidth;</span><br><span class="line">            <span class="keyword">if</span> (!clientWidth) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span>(clientWidth&gt;= <span class="number">750</span>)&#123;</span><br><span class="line">                docEl.style.fontSize = <span class="string">'100px'</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                docEl.style.fontSize = <span class="number">100</span> * (clientWidth / <span class="number">750</span>) + <span class="string">'px'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!doc.addEventListener) <span class="keyword">return</span>;</span><br><span class="line">    win.addEventListener(resizeEvt, recalc, <span class="literal">false</span>);</span><br><span class="line">    doc.addEventListener(<span class="string">'DOMContentLoaded'</span>, recalc, <span class="literal">false</span>);</span><br><span class="line">    recalc();</span><br><span class="line">&#125;)(<span class="built_in">document</span>, <span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>

<p>我们只需要此代码在屏幕宽度变化时，做不同的适配。尽管我们并没有在该模块中做任何导出与导入，但它仍然是一个有效的模块。我们可以把它当做一个模块或者脚本使用。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"./example.js"</span></span><br></pre></td></tr></table></figure>

<p>由于它没有导出任何东西，我们可以使用此简化的导入语法来执行此模块的代码。</p>
<p>?&gt; 无绑定的导入经常被用于创建 <strong>polyfill</strong> 与 <strong>shim</strong> (也就是为新语法在旧环境中运行提供向下兼容的两种方式)。</p>
<h3 id="加载模块"><a href="#加载模块" class="headerlink" title="加载模块"></a>加载模块</h3><p>ES6 虽然定义了模块的语法，但是并未定义如何加载它们。。这是规范复杂性的一部分，这种复杂性对于实现环境来说是无法预知的。 ES6 未选择给所有 JS 环境努力创建一个有效的单一规范，而只对一个未定义的内部操作 <code>HostResolveImportedModule</code> 指定了语法以及抽象的加载机制。</p>
<h3 id="在-Web-浏览器中使用模块"><a href="#在-Web-浏览器中使用模块" class="headerlink" title="在 Web 浏览器中使用模块"></a>在 Web 浏览器中使用模块</h3><p>即使在 ES6 之前， web 浏览器都有多种方式在 web 应用中加载 JS 。这些可能的脚本加载选择是：</p>
<ol>
<li>使用 <code>&lt;script&gt;</code> 元素以及 <code>src</code> 属性来指定代码加载的位置，以便加载 JS 代码文件。</li>
<li>使用 <code>&lt;script&gt;</code> 元素但不使用 <code>src</code> 属性，来嵌入内联的 JS 代码。</li>
<li>加载 JS 代码文件并作为 <strong>Worker</strong> （例如 <strong>Web Worker</strong> 或 <strong>Service Worker</strong>）来执行。</li>
</ol>
<h6 id="在-script-标签中使用模块"><a href="#在-script-标签中使用模块" class="headerlink" title="在 script 标签中使用模块"></a>在 script 标签中使用模块</h6><p><code>&lt;script&gt;</code> 元素默认以脚本方式（而非模块）来加载 <strong>JS</strong> 文件，只要 <code>type</code> 属性缺失，或者 <code>type</code> 属性含有与 <strong>JS</strong> 对应的内容类型（如：<code>&quot;text/javascript&quot;</code>）。<code>&lt;script&gt;</code> 元素能够执行内联脚本，也能加载在 <code>src</code> 中指定的文件。为了支持模块，添加了 <code>&quot;module&quot;</code> 值作为 <code>type</code> 的选项。将 <code>type</code> 设置为 <code>&quot;module&quot;</code> ，就告诉了浏览器要将内联代码或是指定文件中的代码当做模块，而不是当作脚本。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载 js模块文件</span></span><br><span class="line">&lt;script type=<span class="string">"module"</span> src=<span class="string">"module.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">srcipt</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 包括内联模块</span></span><br><span class="line">&lt;script type=<span class="string">"module"</span>&gt;</span><br><span class="line">    <span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span></span><br><span class="line">    <span class="keyword">let</span> result = sum(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="Web-浏览器中的模块加载次序"><a href="#Web-浏览器中的模块加载次序" class="headerlink" title="Web 浏览器中的模块加载次序"></a>Web 浏览器中的模块加载次序</h6><p>模块相对脚本的独特之处在于：它们能使用 <code>import</code> 来指定必须要加载的其他文件，以保证正确执行。为了支持此功能， <code>&lt;script type=&quot;module&quot;&gt;</code> 总是表现得像是已经应用了 <code>defer</code> 属性。</p>
<p><code>defer</code> 属性是加载脚本文件时的可选项，但在加载模块文件时总是自动应用的。当 <strong>HTML</strong> 解析到拥有 <code>src</code> 属性的 <code>&lt;script type=&quot;module&quot;&gt;</code> 标签时，就会立即开始下载模块文件，但并不会执行它，直到整个网页文档全部解析完为止。这也就意味着模块会按照它们在 <strong>HTML</strong> 文件中出现的顺序依次执行。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个执行</span></span><br><span class="line">&lt;script type=<span class="string">"module"</span> src=<span class="string">"module1.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个执行</span></span><br><span class="line">&lt;script type=<span class="string">"module"</span>&gt;</span><br><span class="line">    <span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span></span><br><span class="line">    <span class="keyword">let</span> result = sum(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 第三个执行</span></span><br><span class="line"><span class="regexp">&lt;script type="module" src="module2.js"&gt;&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<p>所有模块无论是用 <code>&lt;script type=&quot;module&quot;&gt;</code> 显式包含的，还是用 <code>import</code> 隐式包含的，都会按照次序加载与执行。</p>
<p>前面的范例，完整的加载次序是：</p>
<ol>
<li>下载并解析 <code>module1.js</code>；</li>
<li>递归下载并解析在 <code>module1.js</code> 中使用 <code>import</code> 导入的资源；</li>
<li>解析内联模块；</li>
<li>递归下载并解析在内联模块中使用 <code>import</code> 导入的资源；</li>
<li>下载并解析 <code>module2.js</code>；</li>
<li>递归下载并解析在 <code>module2.js</code> 中使用 <code>import</code> 导入的资源；</li>
</ol>
<p>一旦加载完毕，直到页面文档被完整解析之前，都不会有任何代码被执行。在文档解析完毕后，会发生下列行为：</p>
<ol>
<li>递归执行 <code>module1.js</code> 导入的资源；</li>
<li>执行 <code>module1.js</code>；</li>
<li>递归执行内联模块导入的资源；</li>
<li>执行内联模块；</li>
<li>递归执行 <code>module2.js</code> 导入的资源；</li>
<li>执行 <code>module2.js</code>；</li>
</ol>
<blockquote>
<p><code>&lt;script type=&quot;module&quot;&gt;</code> 上的 <code>defer</code> 属性总是会被忽略，因为它已经应用了该属性。</p>
</blockquote>
<h6 id="Web-浏览器中的异步模块加载"><a href="#Web-浏览器中的异步模块加载" class="headerlink" title="Web 浏览器中的异步模块加载"></a>Web 浏览器中的异步模块加载</h6><p>当配合脚本使用时， <code>async</code> 会导致脚本文件在下载并解析完毕后就立即执行。但带有 <code>async</code> 的脚本在文档中的顺序却并不会影响脚本执行的次序，脚本总是会在下载完成后就立即执行，而无须等待包含它的文档解析完毕。</p>
<p><code>async</code> 属性也能同样被应用到模块上。在 <code>&lt;script type=&quot;module&quot;&gt;</code> 上使用 <code>async</code> 会导致模块的执行行为与脚本相似。唯一区别是模块中所有 <code>import</code> 导入的资源会在模块自身被执行前先下载。这保证了模块中所有需要的资源会在模块执行前被下载，你只是不能保证模块何时会执行。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不能保证哪个会先执行</span></span><br><span class="line">&lt;script type=<span class="string">"module"</span> <span class="keyword">async</span> src=<span class="string">"module1.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script type=<span class="string">"module"</span> <span class="keyword">async</span> src=<span class="string">"module2.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h6 id="将模块作为-Worker-加载"><a href="#将模块作为-Worker-加载" class="headerlink" title="将模块作为 Worker 加载"></a>将模块作为 Worker 加载</h6><p>为了支持模块加载， <strong>HTML</strong> 标准的开发者为 <strong>worker</strong> 构造器添加了第二个参数。此参数是一个有 <code>type</code> 属性的对象，该属性的默认值是 <code>&quot;script&quot;</code> 。你也可以将 <code>type</code> 设置为<code>&quot;module&quot;</code> 以便加载模块文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用模块方式加载 module.js</span></span><br><span class="line"><span class="keyword">let</span> worker = <span class="keyword">new</span> Worker(<span class="string">"module.js"</span>, &#123; <span class="attr">type</span>: <span class="string">"module"</span> &#125;)</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/16/js/modules/" data-id="ck4bd0sqv000amou10m7574jo"
        class="article-share-link">分享</a>
      

    </footer>

  </div>

  
  
  <nav class="article-nav">
    
      <a href="/2019/12/16/js/fun/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            函数
          
        </div>
      </a>
    
    
      <a href="/2019/12/16/js/promise/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Promise与异步编程</div>
      </a>
    
  </nav>


  

  
  
<!-- valine评论 -->
<div id="vcomments-box">
    <div id="vcomments">
    </div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine@1.3.10/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#vcomments',
        notify: false,
        verify: false,
        app_id: 'pUhbbBIdkBPvVbR0iVMNbxKB-gzGzoHsz',
        app_key: '5hUYxDcuUwUe18KzRrGfF2mn',
        path: window.location.pathname,
        avatar: 'mp',
        placeholder: '给我的文章加点评论吧~',
        recordIP: true
    });
    const infoEle = document.querySelector('#vcomments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
        infoEle.childNodes.forEach(function (item) {
            item.parentNode.removeChild(item);
        });
    }
</script>
<style>
    #vcomments-box {
        padding: 5px 30px;
    }

    @media screen and (max-width: 800px) {
        #vcomments-box {
            padding: 5px 0px;
        }
    }

    #vcomments-box #vcomments {
        background-color: #fff;
    }

    .v .vlist .vcard .vh {
        padding-right: 20px;
    }

    .v .vlist .vcard {
        padding-left: 10px;
    }
</style>

  

  
  
  

</article>
</section>
      <footer>
  
</footer>


<!-- <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2019
        
      </li>
      <li>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <ul class="list-inline">
  <li>PV:<span id="busuanzi_value_page_pv"></span></li>
  <li>UV:<span id="busuanzi_value_site_uv"></span></li>
</ul>
        
      </li>
      <li> -->
        <!-- cnzz统计 -->
        <!-- 
      </li>
    </ul>
  </div>
</footer> -->
    <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
    
    <aside class="sidebar">
      
        <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <!-- <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt=""></a>
  </div> -->
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">目录</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
      </aside>
      
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>


  
<script src="/fancybox/jquery.fancybox.min.js"></script>




  
<script src="/js/tocbot.min.js"></script>

  <script>
    // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
    tocbot.init({
      tocSelector: '.tocbot',
      contentSelector: '.article-entry',
      headingSelector: 'h1, h2, h3, h4, h5, h6',
      hasInnerContainers: true,
      scrollSmooth: true,
      positionFixedSelector: '.tocbot',
      positionFixedClass: 'is-position-fixed',
      fixedSidebarOffset: 'auto',
    });
  </script>


<script>
  var ayerConfig = {
    mathjax: true
  }
</script>


<script src="/js/ayer.js"></script>



  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.bootcss.com/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  </div>
</body>

</html>