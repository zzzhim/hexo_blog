<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>增强的数组功能</title>
    <url>/2019/12/16/js/arrayMethod/</url>
    <content><![CDATA[<h1 id="增强的数组功能"><a href="#增强的数组功能" class="headerlink" title="增强的数组功能"></a>增强的数组功能</h1><p>数组是 JS 中的一种基本对象。ES6 中添加了许多方法来增强数组，并且还增加了创建类型话数组（<strong>typed array</strong>）的能力。</p>
<h3 id="Array-of-方法"><a href="#Array-of-方法" class="headerlink" title="Array.of() 方法"></a>Array.of() 方法</h3><p>在 ES6 之前，调用 <code>new Array()</code> 构造器时，存在一个怪异点，根据传入参数的类型与数量的不同，实际上会导致一些不同的结果。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.length) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>])     <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">1</span>])     <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"2"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr.length) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>])     <span class="comment">// "2"</span></span><br><span class="line"></span><br><span class="line">arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>, <span class="string">"3"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr.length) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>])     <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">1</span>])     <span class="comment">// "3"</span></span><br><span class="line"></span><br><span class="line">arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr.length) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>])     <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">1</span>])     <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>当我们对 <code>Array</code> 构造器传入单个的数值类型时，数组的长度会被设置为该参数；但是当我们使用单个的非数值类型来调用时，该参数就会成为目标数组的唯一项；如果使用多个参数来调用，也会作为目标数组的项。这种行为其实是很奇怪的，也是非常具有风险的，因为可能有些时候我们并不能确定参数的类型。</p>
<p>ES6 引入了 <code>Array.of()</code> 来解决这个问题。 <code>Array.of()</code> 方法总会创建一个包含所有参数的数组。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.of(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr.length) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>])     <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">arr = <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr.length) <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>])     <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">1</span>])     <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">2</span>])     <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">arr = <span class="built_in">Array</span>.of(<span class="string">"3"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr.length) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>])     <span class="comment">// "3"</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Array.of()</code> 方法并没有使用 <code>Symbol.species</code> 属性来决定返回值的类型，而是使用了当前的构造器来做决定。</p>
</blockquote>
<h3 id="Array-from-方法"><a href="#Array-from-方法" class="headerlink" title="Array.from() 方法"></a>Array.from() 方法</h3><p>在 ES5 中我们将非数组对象转换成真正的数组，可能经常使用这种方法。如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">makeArray</span><span class="params">(arr)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(arr)</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> arr = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"div"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(arr)) <span class="comment">// [object HTMLCollection]</span></span></span><br><span class="line">    arr = makeArray(arr)</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(arr)) <span class="comment">// [object Array]</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的方法通过改变 <code>slice()</code> 方法的 <code>this</code> ，来将 <strong>HTML集合</strong> 转换为了数组。但是调用 <code>Array.prototype.slice.call(arr)</code> 并没有明确体现出我们这段代码的目的。ES6 新增了 <code>Array.from()</code> 方法来提供一种明确清晰的方式以解决这方面的需求。</p>
<p>如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">makeArray</span><span class="params">(arr)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">Array</span>.from(arr)</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> arr = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"div"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(arr)) <span class="comment">// [object HTMLCollection]</span></span></span><br><span class="line">    arr = makeArray(arr)</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(arr)) <span class="comment">// [object Array]</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此处调用了 <code>Array.from()</code> 方法，将一个 <strong>HTML集合</strong> 转换为了数组。</p>
<blockquote>
<p><code>Array.from()</code> 方法同样使用 <code>this</code> 来决定要返回什么类型的数组。</p>
<p>注意： <code>Array.from()</code> 方法创建的是一个新的， <strong>浅拷贝</strong> 的数组实例。</p>
</blockquote>
<h6 id="映射转换"><a href="#映射转换" class="headerlink" title="映射转换"></a>映射转换</h6><p>如果想在数组转换时进行进一步的处理，我们可以向 <code>Array.from()</code> 方法传递一个映射用的函数作为第二个参数。此函数会将类数组对象的每一个值转换为目标形式，并将其存储在目标数组的对应位置上。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">translate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>, value =&gt; value + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = translate(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(numbers) <span class="comment">// 2, 3, 4</span></span><br></pre></td></tr></table></figure>

<p>如果映射函数需要在对象上工作，你可以手动传递第三个参数给 <code>Array.from()</code> 方法，从而指定映射函数内部的 <code>this</code> 值。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> helper = &#123;</span><br><span class="line">    diff: <span class="number">1</span>,</span><br><span class="line">    add(value) &#123;</span><br><span class="line">        <span class="keyword">return</span> value + <span class="keyword">this</span>.diff</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">translate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>, helper.add, helper)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = translate(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(numbers) <span class="comment">// 2, 3, 4</span></span><br></pre></td></tr></table></figure>

<p>上面的例子中，由于 <code>helper</code> 对象使用了 <code>this</code>，我们必须在向 <code>Array.from()</code> 方法传递第三个参数用于指定映射函数的 <code>this</code> 值。</p>
<h6 id="在可迭代对象上使用"><a href="#在可迭代对象上使用" class="headerlink" title="在可迭代对象上使用"></a>在可迭代对象上使用</h6><p><code>Array.from()</code> 方法不仅可用于类数组对象，也可用于可迭代对象，这意味着该方法可以将任<br>意包含 <code>Symbol.iterator</code> 属性的对象转换为数组。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = &#123;</span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers2 = <span class="built_in">Array</span>.from(numbers, value =&gt; value + <span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(numbers2) <span class="comment">// 2, 3, 4</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果一个对象既是类数组对象，又是可迭代对象，那么迭代器就会使用 <code>Array.from()</code> 方法来决定需要转换的值。</p>
</blockquote>
<h3 id="find-与-findIndex-方法"><a href="#find-与-findIndex-方法" class="headerlink" title="find() 与 findIndex() 方法"></a>find() 与 findIndex() 方法</h3><p><code>find()</code> 与 <code>findIndex()</code> 方法均接受两个参数：一个回调函数、一个可选值用于指定回调函数内部的 <code>this</code> 。该会回调函数可接受三个参数：数组的某个元素、该元素对应的索引位置、以及该数组自身，这与 <code>map()</code> 和 <code>forEach()</code> 方法的回调函数所用的参数一致。该回调函数应当在给定的元素满足你定义的条件时返回 <code>true</code> ，而 <code>find()</code> 与 <code>findIndex()</code> 方法均会在回调函数第一次返回 <code>true</code> 时停止查找。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [ <span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span> ]</span><br><span class="line"><span class="built_in">console</span>.log(numbers.find(<span class="function"><span class="params">n</span> =&gt;</span> n &gt; <span class="number">33</span>))       <span class="comment">// 35</span></span><br><span class="line"><span class="built_in">console</span>.log(numbers.findIndex(<span class="function"><span class="params">n</span> =&gt;</span> n &gt; <span class="number">33</span>))  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>find()</code> 方法会返回匹配的值，而 <code>findIndex()</code> 方法则会返回匹配位置的索引。</p>
</blockquote>
<h3 id="fill-方法"><a href="#fill-方法" class="headerlink" title="fill() 方法"></a>fill() 方法</h3><p><code>fill()</code> 方法能使用特定值填充数组中的一个或多个元素。当只使用一个参数的时候，该方法会用该参数的值填充整个数组。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> ]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.fill(<span class="number">1</span>)) <span class="comment">// [ 1, 1, 1, 1 ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr2 = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> ]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr2.fill(<span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>)) <span class="comment">// [ 1, 10, 3, 4 ]</span></span><br></pre></td></tr></table></figure>

<p><code>fill</code> 的第二个参数和第三个参数，分别是填充的起始索引和终止索引（填充不包括终止索引）。</p>
<blockquote>
<p>如果提供的起始位置或结束位置为负数，则它们会被加上数组的长度来算出最终的位置。</p>
</blockquote>
<h3 id="copyWithin-方法"><a href="#copyWithin-方法" class="headerlink" title="copyWithin() 方法"></a>copyWithin() 方法</h3><p><code>copyWithin()</code> 方法与 <code>fill</code> 类似, 可以一次性修改数组的多个元素。不过，与 <code>fill()</code> 使用单个值来填充数组不同， <code>copyWithin()</code> 方法允许你在数组内部复制自身元素。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从索引 2 的位置开始粘贴</span></span><br><span class="line"><span class="comment">// 从数组索引 0 的位置开始复制数据</span></span><br><span class="line">numbers.copyWithin(<span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(numbers.toString()) <span class="comment">// 1, 2, 1, 2, 3, 4</span></span><br></pre></td></tr></table></figure>

<p>调用 <code>copyWithin()</code> 方法时将第二个参数指定为 <code>0</code> ，表示被复制的数据从索引值为 <code>0</code> 的元素开始，一直到没有元素可供复制为止。</p>
<p><code>copyWithin()</code> 方法总是会一直复制到数组末尾，不过你还可以提供一个可选参数来限制到底有多少元素会被覆盖。这第三个参数指定了复制停止的位置（不包含该位置自身）。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从索引 2 的位置开始粘贴</span></span><br><span class="line"><span class="comment">// 从数组索引 0 的位置开始复制数据</span></span><br><span class="line"><span class="comment">// 在遇到索引 1 时停止复制</span></span><br><span class="line">numbers.copyWithin(<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(numbers.toString()) <span class="comment">// 1, 2, 1, 4, 5, 6</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>类似于 <code>fill()</code> 方法，如果你向 <code>copyWithin()</code> 方法传递负数参数，数组的长度会自动被加到该参数的值上，以便算出正确的索引位置。</p>
</blockquote>
<h3 id="类型化数组"><a href="#类型化数组" class="headerlink" title="类型化数组"></a>类型化数组</h3><p>/<em>暂时不大理解，等详细理解了，再做笔记。</em>/</p>
]]></content>
  </entry>
  <entry>
    <title>Set与Map</title>
    <url>/2019/12/16/js/SetAndMap/</url>
    <content><![CDATA[<h1 id="Set与Map"><a href="#Set与Map" class="headerlink" title="Set与Map"></a>Set与Map</h1><p><code>Set</code> 是不包含重复值的列表。<code>Set</code>对象允许我们存储任何类型的唯一值，无论是原始值或者是对象引用。<br><code>Map</code> 则是键与相对应的值的集合。任何值(对象或者原始值) 都可以作为一个键或一个值。</p>
<h3 id="ES5-中的-Set-与-Map"><a href="#ES5-中的-Set-与-Map" class="headerlink" title="ES5 中的 Set 与 Map"></a>ES5 中的 Set 与 Map</h3><p>在ES5中，开发者使用对象属性来模拟 <code>Set</code> 与 <code>Map</code>。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = Object.create(null)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.foo = true</span><br><span class="line"></span><br><span class="line">// 检查属性的存在性</span><br><span class="line">if(<span class="keyword">set</span>.foo) &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在本例中的 <code>set</code> 变量是一个原型为 <code>null</code> 的对象，确保在此对象上没有继承属性。使用对象的属性作为需要检查的唯一值在ES5中是很常用的方法。当一个属性被添加到 <code>set</code> 对象时，它的值也被设为 <code>true</code>，因此条件判断语句就可以简单判断出该值是否存在。</p>
<p>使用对象模拟 <code>Set</code> 与模拟 <code>Map</code> 之间唯一真正的区别是所存储的值。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">map.foo = <span class="string">'bar'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取一个值</span></span><br><span class="line"><span class="keyword">let</span> value = map.foo</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(value) <span class="comment">// bar</span></span><br></pre></td></tr></table></figure>

<p>与 <code>Set</code> 不同， <code>Map</code> 多数被用来提取数据，而不是仅检测键的存在性。</p>
<h3 id="变通方法的问题"><a href="#变通方法的问题" class="headerlink" title="变通方法的问题"></a>变通方法的问题</h3><p>尽管在简单情况下将对象作为 <code>Set</code> 与 <code>Map</code> 来使用都是可行的，但一旦接触到对象属性的局限性，此方式就会遇到更多麻烦。例如，由于对象属性的类型必须为字符串，你就必须保证任意两个键不能被转换为相同的字符串。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">map[<span class="number">5</span>] = <span class="string">'foo'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map[<span class="string">'5'</span>]) <span class="comment">// foo</span></span><br></pre></td></tr></table></figure>

<p>在将字符串 <code>&#39;foo&#39;</code> 赋值到数值类型的键 <code>5</code> 上，因为对象属性的类型必须是字符串，所以数值类型会被隐式转换为字符串类型，因此使用 <code>5</code> 和 <code>&#39;5&#39;</code> 都可以访问到同一个属性。当你想将数值类型与字符串类型都同时作为键时，可能会引发一些问题。</p>
<p>而且如果我们使用对象作为键时，还会出现另有一个问题。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"><span class="keyword">let</span> key1 = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> key2 = &#123;&#125;</span><br><span class="line"></span><br><span class="line">map[key1] = <span class="string">'foo'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map[key2]) <span class="comment">// foo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 放开这个注释，你会发现也会打印出 foo</span></span><br><span class="line"><span class="comment">// console.log(map['[object Object]']) // foo</span></span><br></pre></td></tr></table></figure>

<p>会发生上面的问题的原因，也是因为 <code>map[key1]</code> 和 <code>map[key2]</code> 引用的是同一个值。由于对象的属性只能是字符串， <code>key1</code> 与 <code>key2</code> 对象就被转换为字符串了。因为对象的默认的字符串类型表达式为 <code>&#39;[object Object]&#39;</code>, 所以它们被转换为了同一个字符串了。</p>
<blockquote>
<p>这种行为导致的错误可能不太显眼，因为貌似合乎逻辑的假设是：键如果使用了不同对象，它们就应当是不同的键。</p>
</blockquote>
<h3 id="ES6-的-Set"><a href="#ES6-的-Set" class="headerlink" title="ES6 的 Set"></a>ES6 的 Set</h3><p>ES6 新增了 <code>Set</code> 类型，这是一种无重复值的有序列表。 <code>Set</code> 允许对它包含的数据进行快速访问，从而增加了一个追踪离散值的更有效方式。</p>
<h6 id="创建-Set-并添加项目"><a href="#创建-Set-并添加项目" class="headerlink" title="创建 Set 并添加项目"></a>创建 <code>Set</code> 并添加项目</h6><p><code>Set</code> 使用 <code>new Set()</code> 来创建，而调用 <code>add()</code> 方法就能向 <code>Set</code> 中添加项目，检查 <code>size</code> 属性还能查看其中包含有多少项。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set()</span><br><span class="line"><span class="keyword">set</span>.add(5)</span><br><span class="line"><span class="keyword">set</span>.add('5')</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>.size) // 2</span><br></pre></td></tr></table></figure>

<p><code>Set</code> 是不会使用强制类型转换来判断值是否重复。这意味着 <code>Set</code> 可以同时包含数值 <code>5</code> 与字符串 <code>&#39;5&#39;</code>，并将它们都作为相对独立的项（<code>Set</code> 内部使用的比较是使用的 <code>Object.is()</code> 方法，来判断两个值是否相等，区别是在判断 <code>+0</code> 与 <code>-0</code> 时，在 <code>Set</code> 中会被判断为相等的）。</p>
<p>同时我们还可以向 <code>Set</code> 添加多个对象，它们并不会被合并为同一项：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set()</span><br><span class="line">let key1 = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> key2 = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add(key1)</span><br><span class="line"><span class="keyword">set</span>.add(key2)</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>.size) // 2</span><br></pre></td></tr></table></figure>

<p>因为 <code>key1</code> 和 <code>key2</code> 不会被转换为字符串，所以它们在这个 <code>Set</code> 内部被认为是两个不同的项。</p>
<p>如果对 <code>add()</code> 方法用相同值进行了多次调用，那么除了第一次以外的调用都会被忽略。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set()</span><br><span class="line"><span class="keyword">set</span>.add(5)</span><br><span class="line"><span class="keyword">set</span>.add("5")</span><br><span class="line"><span class="keyword">set</span>.add(5) // 被忽略</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>.size) // 2</span><br></pre></td></tr></table></figure>

<p>可以使用数组来初始化一个 <code>Set</code> ，并且 <code>Set</code> 构造器会确保不重复地使用这些值。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 2, 3, 4, 4, 3, 5, 5, 2])</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>) // Set(5) &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">set</span>.size) // 5</span><br></pre></td></tr></table></figure>

<h6 id="has-方法"><a href="#has-方法" class="headerlink" title="has() 方法"></a><code>has()</code> 方法</h6><p>想要检测某个值是否存在与 <code>Set</code> 中，可以使用 <code>has()</code> 方法，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set()</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add(5)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add('5')</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>.has(5)) // true</span><br><span class="line">console.log(<span class="keyword">set</span>.has(10)) // false</span><br></pre></td></tr></table></figure>

<h6 id="delete-与-clear-方法"><a href="#delete-与-clear-方法" class="headerlink" title="delete() 与 clear() 方法"></a><code>delete()</code> 与 <code>clear()</code> 方法</h6><p>想要将值从 <code>Set</code> 中移除，可以使用 <code>delete()</code> 与 <code>clear()</code> 方法。</p>
<blockquote>
<p>delete() 方法来移除单个值。</p>
<p>clear() 方法来将所有值从 Set 中移除。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set()</span><br><span class="line"><span class="keyword">set</span>.add(5)</span><br><span class="line"><span class="keyword">set</span>.add('5')</span><br><span class="line"><span class="keyword">set</span>.add(6)</span><br><span class="line"><span class="keyword">set</span>.add('6')</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>.has(5)) // true</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.delete(5)</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>.has(5)) // false</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.clear()</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>.has('5')) // false</span><br><span class="line">console.log(<span class="keyword">set</span>.has(6)) // false</span><br><span class="line">console.log(<span class="keyword">set</span>.has('6')) // false</span><br></pre></td></tr></table></figure>

<h6 id="Set-上的-forEach-方法"><a href="#Set-上的-forEach-方法" class="headerlink" title="Set 上的 forEach() 方法"></a><code>Set</code> 上的 <code>forEach()</code> 方法</h6><p><code>Set</code> 上的 <code>forEach()</code> 方法会被传递一个回调函数，该回调接受三个参数：</p>
<ol>
<li>Set 中下个位置的值；</li>
<li>与第一个参数相同的值；</li>
<li>目标 Set 自身。</li>
</ol>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 2]);</span><br><span class="line">    <span class="keyword">set</span>.forEach(function(value, key, ownerSet) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key === value)</span><br><span class="line">    <span class="built_in">console</span>.log(key + <span class="string">" "</span> + value)</span><br><span class="line">    <span class="built_in">console</span>.log(ownerSet === <span class="keyword">set</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>与传统的 <code>forEach()</code> 不同的是，<code>Set</code> 是没有键的，为了与数组以及 <code>Map</code> 版本保持一致，就把 <code>Set</code> 的每一项同时认定为键与值，因此该回调函数的前两个参数始终相等。</p>
<h6 id="将-Set-转换为数组"><a href="#将-Set-转换为数组" class="headerlink" title="将 Set 转换为数组"></a>将 <code>Set</code> 转换为数组</h6><p>想要将数组转换为 <code>Set</code> 很容易，同时想把 <code>Set</code> 转换为数组也很容易，只需利用 <code>扩展运算符</code> 即可实现。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([ 1, 2, 2, 3, 3, 4, 5 ])</span><br><span class="line">let arr = [ ...<span class="keyword">set</span> ]</span><br><span class="line"></span><br><span class="line">console.log(arr) // [ 1, 2, 3, 4, 5 ]</span><br></pre></td></tr></table></figure>

<p>不过需要注意的是把数组转化为 <code>Set</code> 的同时会进行去重。当然也可以利用这个特性去创建一个无重复的新数组。</p>
<h3 id="Weak-Set"><a href="#Weak-Set" class="headerlink" title="Weak Set"></a>Weak Set</h3><p>由于 <code>Set</code> 类型存储对象引用的方式， 它也可以被称为 <code>Strong Set</code>。对象存储在 <code>Set</code> 的一个实例中时，实际上相当于把对象存储在变量中。只要对于 <code>Set</code> 实例的引用仍然存在，所存储的对象就无法被垃圾回收机制回收，从而无法释放内存。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set()</span><br><span class="line">let key = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add(key)</span><br><span class="line">console.log(<span class="keyword">set</span>.size) // 1</span><br><span class="line"></span><br><span class="line">// 取消原始引用</span><br><span class="line">key = null</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>.size) // 1</span><br><span class="line"></span><br><span class="line">// 重新获取原始引用</span><br><span class="line">key = [...<span class="keyword">set</span>][0]</span><br></pre></td></tr></table></figure>

<p>在本例中，将 key 设置为 <code>null</code> 清除了对 <code>key</code> 对象的一个引用，但是另一个引用还存于 <code>set</code> 内部。你仍然可以使用扩展运算符将 <code>Set</code> 转换为数组，然后访问数组的第一项， <code>key</code> 变量就取回了原先的对象。这种结果在大部分程序中是没问题的，但有时，当其他引用消失之后若 <code>Set</code> 内部的引用也能消失，那就更好。</p>
<p>而使用 <code>Weak Set</code> 就可以达到这个目的。，该类型只允许存储对象弱引用，而不能存储基本类型的值。对象的弱引用在它自己成为该对象的唯一引用时，不会阻止垃圾回收。</p>
<h6 id="创建-Weak-Set"><a href="#创建-Weak-Set" class="headerlink" title="创建 Weak Set"></a>创建 <code>Weak Set</code></h6><p><code>Weak Set</code> 使用 <code>WeakSet</code> 构造器来创建，并包含 <code>add()</code> 方法、 <code>has()</code> 方法以及 <code>delete()</code> 方法。以下例子使用了这三个方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new WeakSet()</span><br><span class="line">let key = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add(key)</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>.has(key)) // true</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.delete(key)</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>.has(key)) // false</span><br></pre></td></tr></table></figure>

<p><code>Weak Set</code> 和 <code>Set</code> 的使用方法很相似，我们可以在 <code>Weak Set</code> 上添加、删除、或者检查引用，同样也可以给构造器传入一个可迭代对象来初始化 <code>Weak Set</code> 的值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> key1 = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> key2 = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new WeakSet([ key1, key2 ])</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>.has(key1)) // true</span><br><span class="line">console.log(<span class="keyword">set</span>.has(key2)) // true</span><br></pre></td></tr></table></figure>

<p>?&gt;  <code>WeakSet</code> 构造器不接受基本类型的值。</p>
<h6 id="Set-类型之间的关键差异"><a href="#Set-类型之间的关键差异" class="headerlink" title="Set 类型之间的关键差异"></a><code>Set</code> 类型之间的关键差异</h6><p><code>Weak Set</code> 与 <code>Set</code> 之间最大的区别是对象的弱引用。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new WeakSet()</span><br><span class="line">let key = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add(key)</span><br><span class="line">console.log(<span class="keyword">set</span>.has(key)) // true</span><br><span class="line"></span><br><span class="line">// 取消原始引用</span><br><span class="line">key = null</span><br><span class="line"></span><br><span class="line">// 无法核实，不过 JS 引擎已经正确的将引用移除了</span><br></pre></td></tr></table></figure>

<p>当此代码被执行后，<code>Weak Set</code> 中的 <code>key</code> 引用就不能再访问了。核实这一点是不可能的，因为需要把对于该对象的一个引用传递给 <code>has()</code> 方法（而只要存在其他引用， <code>Weak Set</code> 内部的弱引用就不会消失）。</p>
<blockquote>
<p><strong>Weak Set 与 Set 的差异</strong></p>
<ol>
<li><p>对于 <code>WeakSet</code> 的实例，若调用 <code>add()</code> 方法时传入了非对象的参数，就会抛出错误（ <code>has()</code> 或 <code>delete()</code> 则会在传入了非对象的参数时返回 <code>false</code> ）；</p>
</li>
<li><p><code>Weak Set</code> 不可迭代，因此不能被用在 <code>for-of</code> 循环中；</p>
</li>
<li><p><code>Weak Set</code> 无法暴露出任何迭代器（例如 <code>keys()</code> 与 <code>values()</code> 方法），因此没有任何编程手段可用于判断 <code>Weak Set</code> 的内容；</p>
</li>
<li><p><code>Weak Set</code> 没有 <code>forEach()</code> 方法；</p>
</li>
<li><p><code>Weak Set</code> 没有 <code>size</code> 属性。</p>
</li>
</ol>
</blockquote>
<h3 id="ES6-的-Map"><a href="#ES6-的-Map" class="headerlink" title="ES6 的 Map"></a>ES6 的 Map</h3><p><code>Map</code> 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。</p>
<h6 id="set与get方法"><a href="#set与get方法" class="headerlink" title="set与get方法"></a>set与get方法</h6><p>想要给 <code>Map</code> 添加键值可以调用 <code>set()</code> 方法；然后可以使用键名来调用 <code>get()</code> 方法便能够取得对应的值了。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"></span><br><span class="line">map.set(<span class="string">"title"</span>, <span class="string">"ES6"</span>)</span><br><span class="line">map.set(<span class="string">"type"</span>, <span class="string">"JS"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">"title"</span>)) <span class="comment">// ES6</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">"type"</span>))  <span class="comment">// JS</span></span><br></pre></td></tr></table></figure>

<p>我们也可以将对象作为键，这也是以前使用对象属性来创建 <code>Map</code> 的变通方法所无法做到的。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="keyword">const</span> key1 = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> key2 = &#123;&#125;</span><br><span class="line"></span><br><span class="line">map.set(key1, <span class="number">1</span>)</span><br><span class="line">map.set(key2, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map.get(key1)) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(key2)) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>在这里我们使用了对象作为 <strong>Map</strong> 的键，并且存储了两个不同的值。由于 <strong>Map</strong> 的键不会被强制转换成其他形式，所以每个对象就都被认为是唯一的。这允许我们给对象关联额外数据，而不用修改对象自身。</p>
<h3 id="Map-的方法"><a href="#Map-的方法" class="headerlink" title="Map 的方法"></a>Map 的方法</h3><p>与 <code>Set</code> 相同，以下三个方法 <code>Map</code> 上也存在。</p>
<ul>
<li><code>has(key)</code> ：判断指定的键是否存在于 <code>Map</code> 中；</li>
<li><code>delete(key)</code> ：移除 <code>Map</code> 中的键以及对应的值；</li>
<li><code>clear()</code> ：移除 <code>Map</code> 中所有的键与值。</li>
</ul>
<p><strong>Map</strong> 同样拥有 <code>size</code> 属性，用于指明包含了多少键值对。</p>
<p>此示例包含三种方法以及 <code>size</code> 属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">map.set(<span class="string">'a'</span>, <span class="number">1</span>)</span><br><span class="line">map.set(<span class="string">'b'</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map.size) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">'a'</span>)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">map.delete(<span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 a 键被使用 delete 方法移除后， has() 方法再接受 a 的时候就会返回 false 了</span></span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">'a'</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(map.size) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">'b'</span>)) <span class="comment">// true</span></span><br><span class="line">map.clear()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map.size) <span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 使用 clear 方法则清空了所有的键，所以 has() 方法再接受 b 的时候就会返回 false 了</span></span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">'b'</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="Map-的初始化"><a href="#Map-的初始化" class="headerlink" title="Map 的初始化"></a>Map 的初始化</h3><p>我们也可以将数组传递给 <code>Map</code> 构造器，以便使用数据来初始化一个 <strong>Map</strong>。 该数组中的每一项也必须是数组，内部数组的首个项会作为键，第二项则会为对应值。因此整个 <strong>Map</strong> 就被这些双项数组所填充。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[ <span class="string">'a'</span>, <span class="number">1</span> ], [ <span class="string">'b'</span>, <span class="number">2</span> ]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map.size) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">'a'</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">'b'</span>)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">'a'</span>)) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">'b'</span>)) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h3 id="Map-上的-forEach-方法"><a href="#Map-上的-forEach-方法" class="headerlink" title="Map 上的 forEach 方法"></a>Map 上的 forEach 方法</h3><p><strong>Map</strong> 上也有  <code>forEach()</code> 方法类似于 <code>Set</code> 与数组的同名方法，它接受一个能接受三个参数的回调函数：</p>
<ol>
<li><strong>Map</strong> 中下个位置的值</li>
<li>该值对应的键</li>
<li>目标 <strong>Map</strong> 自身</li>
</ol>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[ <span class="string">'a'</span>, <span class="number">1</span> ], [ <span class="string">'b'</span>, <span class="number">2</span> ]])</span><br><span class="line"></span><br><span class="line">map.forEach(<span class="function">(<span class="params">value, key, own</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 第一次循环打印 1 ；第二次循环打印 2 ；</span></span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">    <span class="comment">// 第一次循环打印 a ；第二次循环打印 b ；</span></span><br><span class="line">    <span class="built_in">console</span>.log(key)</span><br><span class="line">    <span class="comment">// 第一次循环打印 true ；第二次循环打印 true ；</span></span><br><span class="line">    <span class="built_in">console</span>.log(map === own)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>你也可以给 forEach() 提供第二个参数来指定回调函数中的 this 值，其行为与 Set 版本的 forEach() 一致。</p>
</blockquote>
<h3 id="Weak-Map"><a href="#Weak-Map" class="headerlink" title="Weak Map"></a>Weak Map</h3><p>Weak Map 对 Map 而言，就像 Weak Set 对 Set 一样：Weak 版本都是存储对象弱引用的方式。在 <strong>Weak Map</strong> 中，所有的键对必须是对象（如果使用非对象则会抛出错误），而且这些对象都是弱引用，不会干扰垃圾回收。当 <strong>Weak Map</strong> 中的键在 <strong>Weak Map</strong> 之外不存在引用时，该键值对会被移除。</p>
<p><strong>Weak Map</strong> 的最佳用武之地，就是在浏览器中创建一个关联到特定 <strong>DOM</strong> 元素的对象。例如，某些用在网页上的 <strong>JS</strong> 库会维护一个自定义对象，用于引用该库所使用的每一个 <strong>DOM</strong> 元素，并且其映射关系会存储在内部的对象缓存中。</p>
<p>该方法的困难之处在于：如何判断一个 <strong>DOM</strong> 元素已不复存在于网页中，以便该库能移除此元素的关联对象。若做不到，该库就会继续保持对 <strong>DOM</strong> 元素的一个无效引用，并造成内存泄漏。使用 <strong>Weak Map</strong> 来追踪 <strong>DOM</strong> 元素，依然允许将自定义对象关联到每个 <strong>DOM</strong> 元素，而在此对象所关联的 <strong>DOM</strong> 元素不复存在时，它就会在 <strong>Weak Map</strong> 中被自动销毁。</p>
<blockquote>
<p>必须注意的是， <strong>Weak Map</strong> 的键才是弱引用，而值不是。在 <strong>Weak Map</strong> 的值中存储对象会阻止垃圾回收，即使该对象的其他引用已全都被移除。</p>
</blockquote>
<h3 id="使用-Weak-Map"><a href="#使用-Weak-Map" class="headerlink" title="使用 Weak Map"></a>使用 Weak Map</h3><p>ES6 的 <code>Weak Map</code> 类型是键值对的无序列表，其中键必须是非空的对象，值则允许是任意类型。 <code>Weak Map</code> 的接口与 <code>Map</code> 的非常相似，都使用 <code>set()</code> 与 <code>get()</code> 方法来分别添加与提取数据。如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"ele"</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> ele = <span class="built_in">document</span>.querySelector(<span class="string">"#ele"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    map.set(ele, <span class="string">'dom'</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="keyword">const</span> value = map.get(ele)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(value) <span class="comment">// dom</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 删除元素</span></span></span><br><span class="line">    ele.parentNode.removeChild(ele)</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    ele = <span class="literal">null</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 该 Weak Map 在此处为空</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>类似于 Weak Set ，没有任何办法可以确认 Weak Map 是否为空，因为它没有 <code>size</code> 属性。在其他引用被移除后，由于对键的引用不再有残留，也就无法调用 <code>get()</code> 方法来提取对应的值。Weak Map  已经切断了对于该值的访问，其所占的内存在垃圾回收器运行时便会被释放。</p>
<h3 id="Weak-Map-的初始化"><a href="#Weak-Map-的初始化" class="headerlink" title="Weak Map 的初始化"></a>Weak Map 的初始化</h3><p>和正规的 <code>Map</code> 构造器一样，初始化 <strong>Weak Map</strong>，也需要把一个由数组构成的数组传递给 <code>Weak Map</code> 构造器。每个内部数组都要有两个值，第一项是作为键的非空对象，第二项则是对应的值（任意类型<code>any</code>）。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> key1 = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> key2 = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>([[ key1, <span class="number">1</span> ], [ key2, <span class="number">2</span> ]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map.get(key1)) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(key2)) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>!&gt; 在传递给 <strong>WeakMap</strong> 构造器的参数中，若任意键值对使用了非对象的键，构造器就会抛出错误。</p>
<h3 id="Weak-Map-的方法"><a href="#Weak-Map-的方法" class="headerlink" title="Weak Map 的方法"></a>Weak Map 的方法</h3><p>Weak Map 只有两个附加方法能用来与键值对交互。</p>
<ol>
<li><code>has()</code> 方法用于判断指定的键是否存在于 Map 中。</li>
<li><code>delete()</code> 方法则用于移除一个特定的键值对。</li>
</ol>
<p>需要注意的是 <strong>Weak Map</strong> 上是没有 <code>clear()</code> 方法的，这是因为没必要对键进行枚举，而且也不可能对 Weak Map 进行枚举。</p>
<p>此示例使用了两种方法，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> key1 = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> key2 = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>([[ key1, <span class="number">1</span> ], [ key2, <span class="number">2</span> ]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map.has(key1)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(map.has(key2)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">map.delete(key1)</span><br><span class="line">map.delete(key2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map.has(key1)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(map.has(key2)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-Weak-Map-来创建对象的私有数据"><a href="#使用-Weak-Map-来创建对象的私有数据" class="headerlink" title="使用 Weak Map 来创建对象的私有数据"></a>使用 Weak Map 来创建对象的私有数据</h3><p>Weak Map 的另一个实际应用就是在对象实例中存储私有数据。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Person = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> privateData = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        privateData.set(<span class="keyword">this</span>, &#123; <span class="attr">name</span>: name &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> privateData.get(<span class="keyword">this</span>).name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Person</span><br><span class="line">&#125;())</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="string">'反芹菜联盟盟主'</span>)</span><br><span class="line"></span><br><span class="line">person.getName() <span class="comment">// 反芹菜联盟盟主</span></span><br></pre></td></tr></table></figure>

<p>由于 <code>Person</code> 对象的实例本身能被作为键来使用，于是也就无须再记录单独的 <code>ID</code> 。当 <code>Person</code> 构造器被调用时，将 <code>this</code> 作为键在 <code>Weak Map</code> 上建立了一个入口，而包含私有信息的对象成为了对应的值，其中只存放了 <code>name</code> 属性。通过将 <code>this</code> 传递给 <code>privateData.get()</code> 方法，以获取值对象并访问其 <code>name</code> 属性， <code>getName()</code> 函数便能提取私有信息。这种技术让私有信息能够保持私有状态，并且当与之关联的对象实例被销毁时，私有信息也会被同时销毁。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>Set</strong> 是无重复值的有序列表。根据 <code>Object.is()</code> 方法来判断其中的值不相等，以保证无重复。<strong>Set</strong> 会自动移除重复的值，因此我们也可以使用它来过滤数组的重复值。我们可以使用 <code>has()</code> 方法来判断某一个值是否存在于 <strong>Set</strong> 中，也可以通过 <code>size</code> 属性查看其中有多少值。也可以使用 <code>forEach()</code> 方法，来处理每个值。</p>
<p>Weak Set 是只能包含对象的特殊 Set 。其中的对象使用弱引用来存储，意味着当 Weak Set中的项是某个对象的仅存引用时，它不会屏蔽垃圾回收。由于内存管理的复杂性， Weak Set的内容不能被检查，因此最好将 Weak Set 仅用于追踪需要被归组在一起的对象。</p>
<p>Map 是有序的键值对，其中的键允许是任何类型。与 Set 相似，通过调用 <code>Object.is()</code> 方法来判断重复的键，这意味着能将数值 5 与字符串 “5” 作为两个相对独立的键。使用 <code>set()</code> 方法能将任何类型的值关联到某个键上，并且该值此后能用 <code>get()</code> 方法提取出来。Map 也拥有一个 size 属性与一个 <code>forEach()</code> 方法，让项目访问更容易。</p>
<p>Weak Map 是只能包含对象类型的键的特殊 Map 。与 Weak Set 相似，键的对象引用是弱引用，因此当它是某个对象的仅存引用时，也不会屏蔽垃圾回收。当键被回收之后，所关联的值也同时从 Weak Map 中被移除。</p>
]]></content>
  </entry>
  <entry>
    <title>块级绑定</title>
    <url>/2019/12/16/js/block/</url>
    <content><![CDATA[<h1 id="块级绑定"><a href="#块级绑定" class="headerlink" title="块级绑定"></a>块级绑定</h1><h3 id="var-声明与变量提升"><a href="#var-声明与变量提升" class="headerlink" title="var 声明与变量提升"></a>var 声明与变量提升</h3><p>使用 <code>var</code> 关键字声明的变量，无论其实际声明位置在何处，都会被视为声明于所在函数的顶部（如果声明不在任意函数内，则视为在全局作用域的顶部）。这就是所谓的变量提升。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">condition</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(condition) &#123;</span><br><span class="line">        <span class="keyword">var</span> value = <span class="string">"blue"</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value) <span class="comment">// 在此处可以访问，值为undefined</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(value) <span class="comment">// 在此处可以访问，值为undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于刚接触 <code>JS</code> 的人，或许会认为仅当 <code>condition</code> 的值为 <strong>true</strong> 时，变量 <code>value</code> 才会被创建。但实际上 <code>value</code> 无论何时都会被创建。 <code>JS</code> 引擎在后台对 <code>getValue</code> 函数进行了调整，就像下面这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">condition</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value <span class="comment">// 未初始化的变量，默认值为undefined</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(condition) &#123;</span><br><span class="line">        value = <span class="string">"blue"</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value) <span class="comment">// 在此处可以访问，值为undefined</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(value) <span class="comment">// 在此处可以访问，值为undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>value</code> 变量的声明被提升到了顶部，而初始化工作则保留在原处。这也代表我们可以在 <code>else</code> 分支内 <code>value</code> 变量也可以被我们访问到，此处它的值会是 <code>undefined</code> ，因为它并没有被初始化。</p>
<p>?&gt; <strong>块级声明：</strong> 块级声明也就是让所声明的变量在指定块的作用域外无法被访问。块级作用域（又被称为词法作用域）在以下情况被创建：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 在一个函数内部</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// no thing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 在一个代码块（由一对花括号包裹）内部</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// no thing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="let-声明"><a href="#let-声明" class="headerlink" title="let 声明"></a>let 声明</h3><p><code>let</code> 声明的语法与 <code>var</code> 的语法一致。我们完全可以用 <code>let</code> 来代替 <code>var</code> 进行变量声明，但会将变量的作用域限制在当前的块级作用域中。由于 <code>let</code> 声明不存在变量提升，因此我们需要手动将 <code>let</code> 声明放置到顶部，以便让变量在整个代码块都可以被访问到。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">condition</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(condition) &#123;</span><br><span class="line">        <span class="keyword">let</span> value = <span class="string">"blue"</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// value 在此处不可被访问</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// value 在此处不可被访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>?&gt; 这种写法的 <code>getValue</code> 函数的行为更接近其他类<strong>C</strong>语言。由于变量 <code>value</code> 声明使用的是 <code>let</code> 而非 <code>var</code>,该声明就没有被提升到函数定义的顶部，因此变量 <code>value</code> 在 <code>if</code> 代码块外部是无法访问的；并且在 <code>condition</code> 的值为 <strong>false</strong> 时，该变量是永远不会被声明并初始化的。</p>
<h3 id="禁止重复声明"><a href="#禁止重复声明" class="headerlink" title="禁止重复声明"></a>禁止重复声明</h3><p>如果一个标识符已经在代码块内部被定义，那么在此代码块内使用同一个标识符进行 <code>let</code> 声明就会导致<strong>抛出错误</strong>。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法错误 Identifier 'count' has already been declared</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">40</span></span><br></pre></td></tr></table></figure>
<p>在本例中，<code>count</code> 变量被声明了两次：一次使用 <code>var</code> ，另一次使用 <code>let</code>。 因为 <code>let</code> 不能在同一作用域内重复声明一个已有标识符，此处的 <code>let</code> 声明就会抛出错误。另一方面，在嵌套的作用域内使用 <code>let</code> 声明一个同名的新变量，则不会抛出错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不会抛出错误</span></span><br><span class="line"><span class="keyword">if</span>(condition) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">40</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此处 <code>let</code> 声明并没有抛出错误，这是因为我们并不是在同一 <strong>块级作用域</strong> 再次创建此变量，而是在 <code>if</code> 代码块内部创建的，这个新变量会屏蔽全局的 <code>count</code> 变量，从而在局部阻止对于后者的访问。</p>
<h3 id="常量声明"><a href="#常量声明" class="headerlink" title="常量声明"></a>常量声明</h3><p>在 <strong>ES6</strong> 中里也可以使用 <code>const</code> 语法进行声明。使用 <code>const</code> 声明的变量会被认为是 <strong>常量（constant）</strong> ，意味着它们的值在被设置完成后就不能再被改变。正因为如此，所有的 <code>const</code> 变量都需要在声明时进行初始化。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有效的常量</span></span><br><span class="line"><span class="keyword">const</span> maxItems = <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法错误：未进行初始化</span></span><br><span class="line"><span class="keyword">const</span> name</span><br></pre></td></tr></table></figure>

<p><code>maxItems</code> 变量被初始化了，因此它的 <code>const</code> 声明能正常奇效。而 <code>name</code> 变量没有被初始化，导致在试图运行这段代码时抛出了错误。</p>
<p>对比 <code>const</code> 声明与 <code>let</code> 声明</p>
<p>常量声明与 <code>let</code> 声明一样，都是块级声明。这意味着常量在声明它们的语句块外部也是无法访问的，并且声明同样不会被提升。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="keyword">const</span> maxItems = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// maxItems 在此处无法被访问</span></span><br></pre></td></tr></table></figure>

<p>与 <code>let</code> 的另一个相似之处，是 <code>const</code> 声明在同一个作用域内定义一个已经声明的变量时同样会抛出错误。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">"Hello!"</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">25</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二者都会抛出错误</span></span><br><span class="line"><span class="keyword">const</span> message = <span class="string">"Good!"</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span></span><br></pre></td></tr></table></figure>

<p>两个 <code>const</code> 声明都可以单独使用，但是在前面使用 <code>var</code> 与 <code>let</code> 声明过后的情况下，二者都会抛出错误。</p>
<p>!&gt; <code>let</code> 与 <code>const</code> 之间有个必须牢记的重大区别：试图对之前用 <code>const</code> 声明的常量进行赋值会抛出错误，无论是在严格模式还是非严格模式下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> maxItems = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出错误</span></span><br><span class="line">maxItems = <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>?&gt; 这里需要注意的是 <code>maxItems</code> 变量不能被再次赋值。然而与其他语言不同， <strong>JS</strong> 的常量如果是一个对象，它所包含的值是可以被修改的。这是因为 <code>const</code> 声明创建一个值的只读引用。但这并不意味着它所持有的值是不可变的，只是变量标识符不能重新分配。例如，在引用内容是对象的情况下，这意味着可以改变对象的内容（例如，其参数）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">'大白兔奶糖'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常</span></span><br><span class="line">person.name = <span class="string">'奶糖'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出错误</span></span><br><span class="line">person = &#123;</span><br><span class="line">    name: <span class="string">'软糖'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是因为 <code>person</code> 在初始化时被绑定了带有一个属性的对象。修改 <code>person.name</code> 是可以的，因为该操作只是修改了 <code>person</code> 对象的成员，并没有修改 <code>person</code> 的绑定值。但是当我们尝试为 <code>person</code> 对象重新赋值时（改变变量绑定），就会导致抛出错误。</p>
<p>!&gt; <code>const</code> 阻止的是对于变量绑定的修改，而不阻止我们对成员值的修改。</p>
<h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p>使用 <code>let</code> 或 <code>const</code> 声明的变量，在达到声明处之前都是无法访问的，试图访问会导致一个引用错误，即使在我们进行安全的操作时（例如使用 <code>typeof</code> 运算符），也是如此。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition) &#123;</span><br><span class="line">    <span class="comment">//  Cannot access 'value' before initialization</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> value)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虽然这里是使用的 let 声明的但是 const 也会出现相同的情况</span></span><br><span class="line">    <span class="keyword">let</span> value = <span class="string">"blue"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们使用 <code>let</code> 或 <code>const</code> 声明的变量，若试图在定义位置之前使用它，无论如何都不能避免暂时性死区。</p>
<h3 id="循环中的块级绑定"><a href="#循环中的块级绑定" class="headerlink" title="循环中的块级绑定"></a>循环中的块级绑定</h3><p>我们最需要使用变量的块级作用域的场景，或许就是在 <code>for</code> 循环内，也就是想让一次性的循环计数器仅仅能在循环内部使用。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    process(arr[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// i 在此处也是可以被访问到的</span></span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>如果我们把上面的示例换成 <code>let</code>，则会这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    process(arr[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// i 在此处不可访问，抛出错误</span></span><br><span class="line"><span class="built_in">console</span>.log(i)</span><br></pre></td></tr></table></figure>

<h3 id="循环内的函数"><a href="#循环内的函数" class="headerlink" title="循环内的函数"></a>循环内的函数</h3><p>长期以来， <code>var</code> 的特点使得循环变量在循环作用域之外仍然可被访问，于是在循环内创建函数就变得很有问题。如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">fun</span>) </span>&#123;</span><br><span class="line">    fun() <span class="comment">// 输出数值 10 十次</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>?&gt; 可能我们本来预期这段代码会输出 0 到 9 的数值，但它却在同一行讲数值 10 输出了十次。这是因为变量 <code>i</code> 在循环的每次迭代中都被共享了，意味着循环内创建的那些函数都拥有对于同一变量的引用。在循环结束后，变量 <code>i</code> 的值会是 <code>10</code> ，因此当 <code>console.log(i)</code> 被调用时，每次都打印出 <code>10</code>。</p>
<p>想要解决上面的问题，我们可以在循环内使用立即调用函数表达式（IIFE），以便在每次迭代中强制创建变量的一个新副本。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    funcs.push((<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(i)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">fun</span>) </span>&#123;</span><br><span class="line">    fun() <span class="comment">// 0 到 9 依次输出</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>虽然使用这种方法可以达到我们预期的效果，但是却增加了我们的代码量，幸运的是，使用 <code>let</code> 和 <code>const</code> 的块级绑定可以在 <strong>ES6</strong> 中简化这个循环。</p>
<h3 id="循环内的-let-声明"><a href="#循环内的-let-声明" class="headerlink" title="循环内的 let 声明"></a>循环内的 let 声明</h3><p><code>let</code> 声明通过有效模仿上例中 <strong>IIFE</strong> 的作用而简化了循环。在每次迭代中，都会创建一个新的同名变量并对其进行初始化。这意味着我们完全可以省略 <strong>IIFE</strong> 而获得预期的结果。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">fun</span>) </span>&#123;</span><br><span class="line">    fun() <span class="comment">// 0 到 9 依次输出</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>?&gt; 与使用 <code>var</code> 声明以及 <code>IIFE</code> 相比，这样能达到相同的效果，而且更加简洁。在循环中 <code>let</code> 声明每次都创建了一个新的 <code>i</code> 变量，因此在循环内部创建的函数获得了各自的 <code>i</code> 副本，而每个 <code>i</code> 副本的值都在每次循环迭代声明变量的时候被确定了。这种方式同样可以应用在 <code>for-in</code> 和 <code>for-of</code> 循环中。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = []</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    a: <span class="literal">true</span>,</span><br><span class="line">    b: <span class="literal">true</span>,</span><br><span class="line">    c: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(key)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    func() <span class="comment">// 依次输出 "a"、 "b"、 "c"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="循环内的常量声明"><a href="#循环内的常量声明" class="headerlink" title="循环内的常量声明"></a>循环内的常量声明</h3><p>ES6 规范没有明确禁止在循环中使用 <code>const</code> 声明，然而它会根据循环方式的不同而有不同行为。在常规的 <code>for</code> 循环中，我们可以在初始化时使用 <code>const</code> ，但循环会在你试图改变该变量的值时抛出错误。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"><span class="comment">// 在一次迭代后抛出错误</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i) <span class="comment">// 会在打印 0 之后抛出错误。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>?&gt; 因为第一次迭代成功执行后，此时 <code>i</code> 的值为 0 。在 <code>i++</code> 执行时，一个错误抛出，这是因为该语句试图修改常量的值。</p>
<p>但是当 <code>const</code> 变量在 <code>for-in</code> 或者 <code>for-of</code> 循环中使用时，与 <code>let</code> 变量效果相同。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = []</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    a: <span class="literal">true</span>,</span><br><span class="line">    b: <span class="literal">true</span>,</span><br><span class="line">    c: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(key)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    func() <span class="comment">// 依次输出 "a"、 "b"、 "c"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>?&gt; <code>const</code> 能够在 <code>for-in</code> 或者 <code>for-of</code> 内工作，是因为循环为每次迭代创建了一个新的变量绑定，而不是去修改已绑定的变量的值。</p>
<h3 id="全局块级绑定"><a href="#全局块级绑定" class="headerlink" title="全局块级绑定"></a>全局块级绑定</h3><p><code>let</code> 与 <code>const</code> 不同于 <code>var</code> 的另一个方面是在全局作用域上的表现。当在全局作用域上使用 <code>var</code> 时，它会创建一个新的全局变量，并且成为全局对象（浏览器上是 <code>window</code>）的一个属性。这意味着我们使用 <code>var</code> 可能会无意间覆盖某个已有的全局属性。但是当我们在全局作用域上使用 <code>let</code> 或 <code>const</code>时，虽然也会在全局作用域上创建新的绑定，但是并不会有任何属性添加到全局对象（<code>window</code>）上。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">RegExp</span> = <span class="string">"hello!"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.RegExp) <span class="comment">// "hello!"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> good = <span class="string">"Good!"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.good) <span class="comment">// "Good!"</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">RegExp</span> = <span class="string">"hello!"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>) <span class="comment">// "hello!"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.RegExp === <span class="built_in">RegExp</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> good = <span class="string">"Good!"</span></span><br><span class="line"><span class="built_in">console</span>.log(good) <span class="comment">// "Good!"</span></span><br><span class="line"><span class="built_in">console</span>.log(good <span class="keyword">in</span> <span class="built_in">window</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>let</code> 与 <code>const</code> 的块级绑定将<strong>块级作用域</strong>引入了<strong>JS</strong>。这两种方式都不会进行变量提升，并且只能在声明它们的<strong>块级作用域</strong>内部存在，并且在声明变量之前的位置访问时，会导致<strong>暂时性死区</strong>的错误。</p>
<p><code>let</code> 与 <code>const</code> 的表现在很多情况下都类似与 <code>var</code>，然而在循环中有明显的区别。在 <code>for-in</code> 和 <code>for-of</code> 循环中，<code>let</code> 与 <code>const</code> 都能在迭代的时候创建一个新的绑定，这意味这在循环体内创建的函数可以使用当前迭代所绑定的循环变量值（而不是像使用 <code>var</code> 那样，统一使用循环结束时的变量值）。这一点在 <code>for</code> 循环中使用 <code>let</code> 声明时也成立，不过在 <code>for</code> 循环中使用 <code>const</code> 声明会导致错误。</p>
<p>在使用<strong>块级绑定</strong>的时候默认情况下应该使用 <code>const</code> ，只有在明确知道变量值需要更改的情况下才使用 <code>let</code> 。这样有助于防止某些类型的错误。</p>
]]></content>
  </entry>
  <entry>
    <title>JS的类</title>
    <url>/2019/12/16/js/class/</url>
    <content><![CDATA[<h1 id="JS的类"><a href="#JS的类" class="headerlink" title="JS的类"></a>JS的类</h1><h3 id="ES5-中的仿类结构"><a href="#ES5-中的仿类结构" class="headerlink" title="ES5 中的仿类结构"></a>ES5 中的仿类结构</h3><p>在ES5以及更早版本之前，JS是不存在类的。与类最接近的是：创建一个构造器，然后将方法指派到该构造器的原型上。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PersonType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PersonType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> PersonType(<span class="string">"zzzhim"</span>)</span><br><span class="line">person.sayName() <span class="comment">// zzzhim</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> PersonType) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>)     <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>PersonType</code> 是一个构造器函数，创建了 <code>name</code> 属性。 <code>sayName()</code> 方法被我们挂载在原型上，<code>PersonType</code> 对象的所有实例都会共享此方法。当我们使用 <code>new</code> 运算符创建了 <code>PersonType</code> 的新实例 <code>person</code> ，此对象会被认为是一个通过原型继承了 <code>PersonType</code> 与 <code>Object</code> 的实例。</p>
<h3 id="基本的类声明"><a href="#基本的类声明" class="headerlink" title="基本的类声明"></a>基本的类声明</h3><p>在 <strong>ES6</strong> 中我们可以通过 <code>class</code> 声明创建一个基于原型继承的具有指定名称的新类。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 等价于 PersonType 构造器</span></span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等价于 PersonType.prototype.sayName</span></span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> PersonClass(<span class="string">"zzzhim"</span>)</span><br><span class="line"></span><br><span class="line">person.sayName() <span class="comment">// zzzhim</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> PersonClass) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>)     <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass) <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass.prototype.sayName) <span class="comment">// function</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>自有属性（ <strong>Own properties</strong> ）：该属性出现在实例上而不是原型上，只能在类的构造器或方法内部进行创建。在本例中， <code>name</code> 就是一个自有属性。我建议应在构造器函数内创建所有可能出现的自有属性，这样在类中声明变量就会被限制在单一位置（有助于代码检查）。</p>
</blockquote>
<p>?&gt; 相对于已有的自定义类型声明方式来说，类声明仅仅是以它为基础的一个语法糖。 <code>PersonClass</code> 声明实际上创建了一个拥有 <code>constructor</code> 方法及其行为的函数，这也是 <code>typeof PersonClass</code> 会得到 <code>function</code> 结果的原因。 <code>sayName()</code> 方法最终也成为 <code>PersonClass.prototype</code> 上的一个方法。</p>
<h3 id="为什么要使用类的语法"><a href="#为什么要使用类的语法" class="headerlink" title="为什么要使用类的语法"></a>为什么要使用类的语法</h3><p>尽管类与自定义类型之间有相似性，但仍然有一些重要的区别：</p>
<ol>
<li>类生命不会被提升，而函数定义则相反。类声明的行为与 <code>let</code> 相似，因此在程序的执行到达声明处之前，类会存在<strong>暂时性死区</strong>内。</li>
<li>类声明中的所有代码会自动运行在严格模式下，并且也无法退出严格模式。</li>
<li>类的所有方法都是不可枚举的，这是和自定义类型的显著变化，后者必须使用 <code>Object.defineProperty()</code> 才能将方法改变为不可枚举。</li>
<li>类的所有方法内部都没有 <code>[[Construct]]</code> ，因此使用 <code>new</code> 来调用它们会抛出错误。</li>
<li>调用类构造器时不使用 <code>new</code> ，会抛出错误。</li>
<li>试图在类的方法内部重写类名，会抛出错误。</li>
</ol>
<p>上例中的 <code>PersonClass</code> 声明实际上就直接等价于以下未使用类语法的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> PersonClass = <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="meta">    "use strict"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> PersonClass = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 查看函数是否使用了 new</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">new</span>.target === <span class="string">"undefined"</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Constructor must be called with new."</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(PersonClass.prototype, <span class="string">"sayName"</span>, &#123;</span><br><span class="line">        value() &#123;</span><br><span class="line">            <span class="comment">// 确保函数调用时 没有使用 new</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">new</span>.target !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Method cannot be called with new."</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 设置为不可枚举</span></span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> PersonClass</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> PersonClass(<span class="string">"zzzhim"</span>)</span><br><span class="line"></span><br><span class="line">person.sayName() <span class="comment">// zzzhim</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> PersonClass) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>)     <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass) <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass.prototype.sayName) <span class="comment">// function</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>只有在类的内部，类名才被视为是使用 <code>const</code> 声明。这意味着我们可以在外部重写类名，但是不能在类的方法内部这么做。例如：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        Person = <span class="string">"cat"</span> <span class="comment">// 执行时抛错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正常运行</span></span><br><span class="line">Person = <span class="string">"cat"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在此代码中，类构造器内部的 <code>Person</code> 与 类外部的 <code>Person</code> 是不同的绑定。内部的就像是 <code>const</code> 声明定义的，而外部的就像是 <code>let</code> 声明定义的。</p>
</blockquote>
<h3 id="类表达式"><a href="#类表达式" class="headerlink" title="类表达式"></a>类表达式</h3><p>类与函数相似之处，它们都有两种形式：声明与表达式。函数声明与类声明都以适当的关键字为起始（分别是 <code>function</code> 与 <code>class</code>），随后是标识符（即函数名或类名）。函数具有一种表达式形式，无须在 <code>function</code> 后面使用标识符；类似的，类也有不需要标识符的表达式形式。</p>
<h3 id="基本的类表达式"><a href="#基本的类表达式" class="headerlink" title="基本的类表达式"></a>基本的类表达式</h3><p>我们可以用类表达式的方式，声明一个 <code>PersonClass</code> 。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> PersonClass = <span class="class"><span class="keyword">class</span>  </span>&#123;</span><br><span class="line">    <span class="comment">// 等价于 PersonType 构造器</span></span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等价于 PersonType.prototype.sayName</span></span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> PersonClass(<span class="string">"zzzhim"</span>)</span><br><span class="line"></span><br><span class="line">person.sayName() <span class="comment">// zzzhim</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> PersonClass) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>)     <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass) <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass.prototype.sayName) <span class="comment">// function</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>相对于函数声明与函数表达式之间的区别，类声明与类表达式都不会被提升。</p>
</blockquote>
<h3 id="具名类表达式"><a href="#具名类表达式" class="headerlink" title="具名类表达式"></a>具名类表达式</h3><p>我们可以像函数表达式那样，也可以为类表达式命名。为此需要在 <code>class</code> 关键字后添加标识符，就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> PersonClass1 = <span class="class"><span class="keyword">class</span> <span class="title">PersonClass2</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 等价于 PersonType 构造器</span></span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等价于 PersonType.prototype.sayName</span></span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"------"</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass2) <span class="comment">// function</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"------"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> PersonClass1(<span class="string">"zzzhim"</span>)</span><br><span class="line"></span><br><span class="line">person.sayName() <span class="comment">// zzzhim</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass1) <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass2) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>此例中 <code>PersonClass2</code> 标识符只在类定义内部存在，因此只能在类方法内部访问到。在类的外部，<code>typeof PersonClass2</code> 的结果为 <code>undefined</code> 。参考下面代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> PersonClass1 = <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="meta">    "use strict"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> PersonClass2 = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">new</span>.target === <span class="string">"undefined"</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Constructor must be called with new."</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(PersonClass2.prototype, <span class="string">"sayName"</span>, &#123;</span><br><span class="line">        value() &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">new</span>.target !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Method cannot be called with new."</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"------"</span>)</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass2) <span class="comment">// function</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"------"</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> PersonClass2</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> PersonClass1(<span class="string">"zzzhim"</span>)</span><br><span class="line"></span><br><span class="line">person.sayName() <span class="comment">// zzzhim</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass1) <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass2) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="JS-中的一级公民"><a href="#JS-中的一级公民" class="headerlink" title="JS 中的一级公民"></a>JS 中的一级公民</h3><p>在编程中，能被当作值来使用的就称为一级公民（<strong>first-class citizen</strong>），意味着它能作为参数传给函数、能作为函数返回值、能用来给变量赋值。JS中的函数就是一级公民（它们有时又被称为一级函数）。在 ES6 中，类（<strong>class</strong>）同样是一级公民。</p>
<h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><p>自有属性需要在类构造器中创建，类还允许我们在原型上定义访问器属性。创建 <strong>getter</strong> 和 <strong>setter</strong> ， 只需使用 <code>get</code> 和 <code>set</code> 关键字。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">"person"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> sayName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> sayName(value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> PersonClass()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.sayName) <span class="comment">// person</span></span><br><span class="line"></span><br><span class="line">person.sayName = <span class="string">"zzzhim"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.sayName) <span class="comment">// zzzhim</span></span><br></pre></td></tr></table></figure>

<p>非类的等价表示，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> PersonClass = <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="meta">    "use strict"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> PersonClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">new</span>.target === <span class="string">"undefined"</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Method cannot be called with new."</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">"person"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(PersonClass.prototype, <span class="string">"sayName"</span>, &#123;</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.name = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> PersonClass</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> PersonClass()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.sayName) <span class="comment">// person</span></span><br><span class="line"></span><br><span class="line">person.sayName = <span class="string">"zzzhim"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.sayName) <span class="comment">// zzzhim</span></span><br></pre></td></tr></table></figure>

<h3 id="需计算的成员名"><a href="#需计算的成员名" class="headerlink" title="需计算的成员名"></a>需计算的成员名</h3><p>类方法与类访问器属性也都能使用需计算的名称。语法相同与对象字面量中的需计算名称：无须使用标识符，而是用中括号来包裹一个表达式。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sayName = <span class="string">"sayName"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [sayName]() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> PersonClass(<span class="string">"zzzhim"</span>)</span><br><span class="line"></span><br><span class="line">person[sayName]() <span class="comment">// zzzhim</span></span><br></pre></td></tr></table></figure>

<h3 id="生成器方法"><a href="#生成器方法" class="headerlink" title="生成器方法"></a>生成器方法</h3><p>想要在类上面定义一个生成器，只需要在方法名称前附加一个星号（<code>*</code>）。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.num = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *sayNum() &#123;</span><br><span class="line">        <span class="keyword">yield</span> ++<span class="keyword">this</span>.num</span><br><span class="line">        <span class="keyword">yield</span> ++<span class="keyword">this</span>.num</span><br><span class="line">        <span class="keyword">yield</span> ++<span class="keyword">this</span>.num</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> PersonClass(<span class="string">"zzzhim"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iterator = person.sayNum()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>直接在构造器上添加额外的方法来模拟静态成员，这在ES5以及更早版本是另一个通用的模式。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PersonType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态方法</span></span><br><span class="line">PersonType.create = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PersonType(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例方法</span></span><br><span class="line">PersonType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = PersonType.create(<span class="string">"zzzhim"</span>)</span><br><span class="line"></span><br><span class="line">person.sayName() <span class="comment">// zzzhim</span></span><br></pre></td></tr></table></figure>

<p>工厂方法 <code>PersonType.create()</code> 会被认定为一个静态方法，它的数据不依赖 <code>PersonType</code> 的任何实例。 ES6 的类简化了静态成员的创建，只要在方法与访问器属性的名称前添加正式的 <code>static</code> 标注。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 等价于 PersonType 构造器</span></span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等价于 PersonType.prototype.sayName</span></span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等价于 PersonType.create</span></span><br><span class="line">    <span class="keyword">static</span> create(name) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PersonClass(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = PersonClass.create(<span class="string">"zzzhim"</span>)</span><br><span class="line"></span><br><span class="line">person.sayName() <span class="comment">// zzzhim</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>静态成员不能用实例来访问，你始终需要直接用类自身来访问它们。</p>
</blockquote>
<h3 id="使用派生类进行继承"><a href="#使用派生类进行继承" class="headerlink" title="使用派生类进行继承"></a>使用派生类进行继承</h3><p>ES6 之前，实现一个自定义类型的继承是一个很繁琐的过程。而 ES6 为我们提供了 <code>extends</code> 关键字，大大的简化了这个过程。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child(<span class="string">"zzzhim"</span>)</span><br><span class="line"></span><br><span class="line">child.sayName() <span class="comment">// zzzhim</span></span><br></pre></td></tr></table></figure>

<p>继承了其他类的类被称为派生类（ <strong>derived classes</strong> ）。如果派生类指定了构造器，就需要<br>使用 <code>super()</code> ，否则会造成错误。若你选择不使用构造器， <code>super()</code> 方法会被自动调用，<br>并会使用创建新实例时提供的所有参数。</p>
<blockquote>
<p>使用 <code>super()</code> 时需要牢记以下几点：</p>
<ol>
<li>你只能在派生类中使用 <code>super()</code> 。若尝试在非派生类（即：没有使用 <code>extends</code> 关键字的类）或函数中使用它，就会抛出错误。</li>
<li>在构造器中，你必须在访问 <code>this</code> 之前调用 <code>super()</code> 。 由于 <code>super()</code> 负责初始化 <code>this</code> ， 因此试图先访问 <code>this</code> 自然就会造成错误。</li>
<li>唯一能避免调用 <code>super()</code> 的办法，是从类构造器中返回一个对象。</li>
</ol>
</blockquote>
<h3 id="屏蔽类方法"><a href="#屏蔽类方法" class="headerlink" title="屏蔽类方法"></a>屏蔽类方法</h3><p>派生类中的方法总是会屏蔽基类的同名方法。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"ES6"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child(<span class="string">"zzzhim"</span>)</span><br><span class="line"></span><br><span class="line">child.sayName() <span class="comment">// ES6</span></span><br></pre></td></tr></table></figure>

<h3 id="继承静态成员"><a href="#继承静态成员" class="headerlink" title="继承静态成员"></a>继承静态成员</h3><p>如果基类包含静态成员，那么这些静态成员在派生类中也是可用的。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"zzzhim"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.sayName() <span class="comment">// zzzhim</span></span><br></pre></td></tr></table></figure>

<h3 id="从表达式中派生类"><a href="#从表达式中派生类" class="headerlink" title="从表达式中派生类"></a>从表达式中派生类</h3><p>在 ES6 中派生类的最强大能力，或许就是能够从表达式中派生类。只要一个表达式能够返回一个具有 <code>[[Construct]]</code> 属性以及原型的函数，你就可以对其使用 <code>extends</code>。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Father.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child(<span class="string">"zzzhim"</span>)</span><br><span class="line"></span><br><span class="line">child.sayName() <span class="comment">// zzzhim</span></span><br></pre></td></tr></table></figure>

<p>在上例中 <code>Father</code> 是一个 ES5 风格的构造器，而 <code>Child</code> 是一个类。但是因为 <code>Father</code> 具有 <code>[[Construct]]</code> 以及原型，所以 <code>Child</code> 可以直接继承它。</p>
<p><code>extends</code> 后面能够接受任意类型的表达式。例如动态地决定所要继承的类。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Father.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Father</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">getClass</span>() </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child(<span class="string">"zzzhim"</span>)</span><br><span class="line"></span><br><span class="line">child.sayName() <span class="comment">// zzzhim</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>任意表达式都能在 <code>extends</code> 关键字后使用，但并非所有表达式的结果都是一个有效的类。特别的，下列表达式类型会导致错误：</p>
<ul>
<li>null</li>
<li>生成器函数<br>试图使用结果为上述值的表达式来创建一个新的类实例，都会抛出错误，因为不存在 <code>[[Construct]]</code> 可供调用。</li>
</ul>
</blockquote>
<h3 id="继承内置对象"><a href="#继承内置对象" class="headerlink" title="继承内置对象"></a>继承内置对象</h3><p>在 <strong>ES6</strong> 基于类的继承中， <code>this</code> 的值先被基类创建，随后才被派生类的构造器所修改。结果是 <code>this</code> 初始就拥有作为基类的内置对象的所有功能，并能正确接收与之关联的所有功能。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="comment">// no thing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> colors = <span class="keyword">new</span> MyArray()</span><br><span class="line"></span><br><span class="line">colors[<span class="number">0</span>] = <span class="string">"red"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors.length) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">colors.push(<span class="string">"green"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors.length) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">colors.length = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">0</span>]) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">1</span>]) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>从上面代码可以看出，<code>MyArray</code> 直接继承了 <code>Array</code> ，因此工作方式与正规数组相同。</p>
<h3 id="Symbol-species-属性"><a href="#Symbol-species-属性" class="headerlink" title="Symbol.species 属性"></a>Symbol.species 属性</h3><p>继承内置对象一个有趣的方面是：任意能返回内置对象实例的方法，在派生类上却会自动返回派生类的实例。因此，若你拥有一个继承了 <code>Array</code> 的派生类 <code>MyArray</code> ，诸如 <code>slice()</code> 之类的方法都会返回 <code>MyArray</code> 的实例。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空代码块</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> items = <span class="keyword">new</span> MyArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> subitems = items.slice(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(items <span class="keyword">instanceof</span> MyArray)    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(subitems <span class="keyword">instanceof</span> MyArray) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>在此代码中， <code>slice()</code> 方法返回了 <code>MyArray</code> 的一个实例。 <code>slice()</code> 方法是从 <code>Array</code> 上继承的，原本应当返回 <code>Array</code> 的一个实例。</p>
<p>造成这种变化的原因是因为 <code>Array</code> 类型拥有默认的 <code>Symbol.species</code> 属性，它们的返回值为 <code>this</code>，意味着该属性总是会返回自身的构造器函数。</p>
<blockquote>
<p>下列内置类型都定义了 Symbol.species ：</p>
<ul>
<li><code>Array</code></li>
<li><code>ArrayBuffer</code></li>
<li><code>Map</code></li>
<li><code>Promise</code></li>
<li><code>Array</code></li>
<li><code>Set</code></li>
<li><code>类型化数组</code></li>
</ul>
</blockquote>
<p>当然了，假如我们想要在 <code>MyArray</code> 上返回 <code>Array</code> 对象。我们可以这样做：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">get</span> [Symbol.species]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> items = <span class="keyword">new</span> MyArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> subitems = items.slice(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(items <span class="keyword">instanceof</span> MyArray)    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(subitems <span class="keyword">instanceof</span> MyArray) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Symbol.species</code> 知名符号被用于定义 <code>MyArray</code> 的一个静态访问器属性。注意此处只有 <code>getter</code> 而没有 <code>setter</code> ，这是因为修改类的 <code>species</code> 是不允许的。</p>
</blockquote>
<h3 id="在类构造器中使用-new-target"><a href="#在类构造器中使用-new-target" class="headerlink" title="在类构造器中使用 new.target"></a>在类构造器中使用 new.target</h3><p>我们可以在类构造器中使用 <code>new.target</code> ，来判断类是被如何调用的。</p>
<p>在一般情况下， <code>new.target</code> 就等于本类的构造器函数。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(color) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === Cat)</span><br><span class="line">        <span class="built_in">console</span>.log(color + <span class="string">" cat"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> Cat(<span class="string">"white"</span>)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// white cat</span></span><br></pre></td></tr></table></figure>

<p>上面代码说明当 <code>new Cat(&quot;white&quot;)</code> 被调用时， <code>new.target</code> 等于 <code>Cat</code>。因为类构造器被调用时不能缺少 <code>new</code> ， 所以 <code>new.target</code> 属性就始终会在类构造器内被定义。不过在有些情况下，这个值并不总是相同的。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(color) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === Cat)</span><br><span class="line">        <span class="built_in">console</span>.log(color + <span class="string">" cat"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WhiteCat</span> <span class="keyword">extends</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(color) &#123;</span><br><span class="line">        <span class="keyword">super</span>(color)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> whiteCat = <span class="keyword">new</span> WhiteCat(<span class="string">"white"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// white cat</span></span><br></pre></td></tr></table></figure>

<p><code>WhiteCat</code> 调用了 <code>Cat</code> 的构造器，因此 <code>Cat</code> 构造器被调用时， <code>new.target</code> 实际上是等于 <code>WhiteCat</code> 的。这是很重要的，因为构造器会根据是否被调用而有不同的行为，可能会因此造成一些不必要的问题。当然我们也可以创建一种只能被继承无法被实例化的抽象基类。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无法被实例化的抽象基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(color) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span>.target === Cat) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"This class cannot be instantiated directly"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(color + <span class="string">" cat"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WhiteCat</span> <span class="keyword">extends</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(color) &#123;</span><br><span class="line">        <span class="keyword">super</span>(color)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> Cat(<span class="string">"white"</span>) <span class="comment">// 抛出错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> whiteCat = <span class="keyword">new</span> WhiteCat(<span class="string">"white"</span>) <span class="comment">// 没有错误，输出 white cat</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(whiteCat <span class="keyword">instanceof</span> WhiteCat); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于调用类时不能缺少 <code>new</code> ，于是 <code>new.target</code> 属性在类构造器内部就绝不会是 <code>undefined</code> 。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>解构赋值</title>
    <url>/2019/12/16/js/deconstruction/</url>
    <content><![CDATA[<h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><p><strong>解构赋值</strong> 语法是一种<strong>Javascript</strong>表达式。通过<strong>解构赋值</strong>，可以将属性/值从对象/数组中取出，赋值给其他变量。</p>
<h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><p>在<strong>ES5</strong>中，从对象或数组中获取特定的数据存入本地变量，我们可能要编写许多重复的代码。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">"zzzhim"</span>,</span><br><span class="line">    age: <span class="number">23</span>,</span><br><span class="line">    sex: <span class="string">"男"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取对象中的指定数据</span></span><br><span class="line"><span class="keyword">const</span> name = person.name</span><br><span class="line"><span class="keyword">const</span> age = person.age</span><br><span class="line"><span class="keyword">const</span> sex = person.sex</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>从上面的代码中看到我们想要获取到对象中的指定数据，就必须要逐个赋值，虽然看起来挺简单，但是如果需要提取的数据很多的话，就会变得很麻烦。这就是为什么<strong>ES6</strong>中为何要给对象和数组添加解构赋值的原因。</p>
<p>对象解构语法在赋值语句的左侧使用了对象字面量。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">"zzzhim"</span>,</span><br><span class="line">    age: <span class="number">23</span>,</span><br><span class="line">    sex: <span class="string">"男"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; name, age, sex &#125; = person</span><br><span class="line"><span class="built_in">console</span>.log(name, age, sex) <span class="comment">// zzzhim 23 男</span></span><br></pre></td></tr></table></figure>

<p>在上面的代码中 <code>person.name</code>、<code>person.age</code>、<code>person.sex</code>的值，分别被储存在了<code>name</code>、<code>age</code>、<code>sex</code>的本地变量中。</p>
<p>?&gt; 进行解构赋值时，会把对象上同名的属性的值赋值给对应的变量，来完成解构赋值。</p>
<p>可以看到我们使用<strong>ES6</strong>中的对象解构赋值也可以达到同样的效果，同时代码也更加精简，即使是在处理大量数据的时候，也不会进行重复的操作。</p>
<p>!&gt; 需要注意的是当我们使用解构来配合 <code>var</code>、<code>let</code> 与 <code>const</code>来声明变量的时候，我们必须提供初始化器（也就是等号右边的值）。</p>
<h6 id="无声明赋值"><a href="#无声明赋值" class="headerlink" title="无声明赋值"></a>无声明赋值</h6><p>我们在进行变量声明解构赋值的同时，也可以进行<strong>无声明赋值</strong>。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name, age, sex</span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">"zzzhim"</span>,</span><br><span class="line">    age: <span class="number">23</span>,</span><br><span class="line">    sex: <span class="string">"男"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用解构赋值来分配对应的值</span></span><br><span class="line">;(&#123; name, age, sex &#125; = person)</span><br><span class="line"><span class="built_in">console</span>.log(name, age, sex) <span class="comment">// zzzhim 23 男</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中 <code>name</code>、<code>age</code>、<code>sex</code>变量都已经被声明，然后我们通过解构来获取到了 <code>person</code> 上对应的同名属性，来进行赋值。</p>
<p>!&gt; 这里进行解构赋值时，必须使用圆括号包裹解构赋值语句，这是因为 左侧的 <code>{ name, age, sex }</code> 会被认为一个块而不是对象字面量，使用圆括号包裹代码块，标识了里面的并不是块语句，而应该被解释为表达式。<code>(...)</code>表达式之前有些时候可能需要一个分号，否则可能会被当成上一行的函数执行。</p>
<h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>变量可以先赋予默认值，当我们要提取的对象没有对应的属性或者值为 <code>undefined</code> 时，变量将会被赋予默认值。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">"zzzhim"</span>,</span><br><span class="line">    age: <span class="number">23</span>,</span><br><span class="line">    sex: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; name, age, sex = <span class="string">"男"</span>, height = <span class="string">"1.85"</span> &#125; = person</span><br><span class="line"><span class="built_in">console</span>.log(name, age, sex, height) <span class="comment">// zzzhim 23 男 1.85</span></span><br></pre></td></tr></table></figure>

<p>上面的例子我们可以看到，我们给 <code>sex</code> 与 <code>height</code> 声明了一个默认值，当 <code>person</code> 对象上面并没有该属性，或者该属性的值为 <code>undefined</code> 时默认值将会被应用。</p>
<h3 id="别名：将对象的属性值赋值给不同的变量名"><a href="#别名：将对象的属性值赋值给不同的变量名" class="headerlink" title="别名：将对象的属性值赋值给不同的变量名"></a>别名：将对象的属性值赋值给不同的变量名</h3><p>上面的例子中我们都是把对象的属性值赋值给了相同的变量名，ES6中的解构赋值也支持给与对象属性名不同的变量名赋值。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">"zzzhim"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">name</span>: englishName &#125; = person</span><br><span class="line"><span class="built_in">console</span>.log(englishName) <span class="comment">// zzzhim</span></span><br></pre></td></tr></table></figure>

<p><code>{ name: englishName } = person</code> 表示要读取 <code>person</code> 对象上的 <code>name</code> 属性，并把它的值赋值在变量 <code>englishName</code> 上面。可以看到这种语法正好与我们使用的传统字面量语法相反，传统语法将名称放在冒号左边、值放在右边。而本例中正好相反，名称在右，值则在左。</p>
<h3 id="给别名添加默认值"><a href="#给别名添加默认值" class="headerlink" title="给别名添加默认值"></a>给别名添加默认值</h3><p>我们可以给变量别名添加默认值，依然是在本地变量名称后添加等号与默认值。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">"zzzhim"</span>,</span><br><span class="line">    age: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">age</span>: localAge = <span class="number">23</span> &#125; = person</span><br><span class="line"><span class="built_in">console</span>.log(localAge) <span class="comment">// 23</span></span><br></pre></td></tr></table></figure>

<h3 id="嵌套的对象解构"><a href="#嵌套的对象解构" class="headerlink" title="嵌套的对象解构"></a>嵌套的对象解构</h3><p>使用类似于对象字面量的语法，可以深入到嵌套的对象结构中去提取我们想要的数据。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        englishName: <span class="string">'zzzhim'</span>,</span><br><span class="line">        chineseName: <span class="string">'反芹菜联盟盟主'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">name</span>: &#123; englishName, chineseName &#125; &#125; = person</span><br><span class="line"><span class="built_in">console</span>.log(englishName, chineseName) <span class="comment">// zzzhim, 反芹菜联盟盟主</span></span><br></pre></td></tr></table></figure>

<p>从上面的例子中我们看到，解构赋值上使用了花括号，表示应当到 <code>person</code> 对象下的 <code>name</code> 属性寻找 <code>englishName</code> 与 <code>chineseName</code> 属性。</p>
<p>当然了<strong>嵌套的对象解构</strong>也同样支持参数默认值与别名。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        chineseName: <span class="string">'反芹菜联盟盟主'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">name</span>: &#123; englishName = <span class="string">"zzzhim"</span>, <span class="attr">chineseName</span>: localName &#125; &#125; = person</span><br><span class="line"><span class="built_in">console</span>.log(englishName, localName) <span class="comment">// zzzhim, 反芹菜联盟盟主</span></span><br></pre></td></tr></table></figure>

<h3 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h3><p>数组解构的语法和对象解构差不多，只是对象字面量（<code>{}</code>）替换成了数组字面量（<code>[]</code>）。数组结构时，解构是根据数组内部的位置，而不是像对象一样根据对象上的具名属性进行结构。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [ one, two, three ] = nums</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(one)    <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(two)    <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(three)  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>上面的数组解构从 <code>nums</code> 数组中取出了 <code>1</code>, <code>2</code>, <code>3</code>，并将它们赋值给 <code>one</code>、<code>two</code>、<code>three</code>变量。这些值被赋值，是根据它们在数组中的位置进行的，而不是根据变量名称。</p>
<p>当我们只想要取出 <code>nums</code> 中第三个值时，我们也可以在数组解构中忽略某一些值。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [ , , three ] = nums</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(three)  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>!&gt; 与对象解构一样，我们在使用 <code>var</code>、<code>let</code>、<code>const</code> 进行数组解构的时候，也需要提供初始化器。</p>
<p>同样我们也可以在赋值表达式中使用数组解构。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> one, two, three</span><br><span class="line"><span class="keyword">const</span> nums = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ]</span><br><span class="line"></span><br><span class="line">;[ one, two, three ] = nums</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(one)    <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(two)    <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(three)  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>?&gt; 赋值表达式中数组解构与对象结构的区别是，在数组表达式中不必将表达式包含在圆括号（<code>()</code>）中。</p>
<p>数组解构中，有一个很实用的例子，可以轻易地互换两个变量的值。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>,</span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">;[ a, b ] = [ b, a ]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">// 2, 1</span></span><br></pre></td></tr></table></figure>

<h3 id="默认值-1"><a href="#默认值-1" class="headerlink" title="默认值"></a>默认值</h3><p>数组解构赋值也支持默认值，当数组指定位置项不存在，或者值为 <code>undefined</code>时，那么就会应用默认值。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = [ <span class="number">1</span>, <span class="literal">undefined</span> ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [ one, two = <span class="number">2</span>, three = <span class="number">3</span> ] = nums</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(one)    <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(two)    <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(three)  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h3 id="嵌套的解构"><a href="#嵌套的解构" class="headerlink" title="嵌套的解构"></a>嵌套的解构</h3><p>同样的数组也支持嵌套的解构，在整个解构模式中插入另一个数组模式，解构操作就会下行到嵌套的数组中。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = [ <span class="number">1</span>, [ <span class="number">2</span>, <span class="number">3</span> ], <span class="number">4</span> ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [ one, [ two, three ], four ] = nums</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(one)    <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(two)    <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(three)  <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(four)   <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<h3 id="解构一个函数返回的数组"><a href="#解构一个函数返回的数组" class="headerlink" title="解构一个函数返回的数组"></a>解构一个函数返回的数组</h3><p>从一个函数中返回一个数组是十分常见的情况。数组解构，同样也支持解构一个函数返回的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [ <span class="number">1</span>, <span class="number">2</span> ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [ one, two ] = fun()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(one)    <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(two)    <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h3 id="剩余项"><a href="#剩余项" class="headerlink" title="剩余项"></a>剩余项</h3><p>与函数的剩余参数相同，数组解构也有个类似的、名为剩余项（rest items）的概念，它使用 <code>...</code> 语法来将剩余的项目赋值给一个指定的变量。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [ one, ...restNums ] = nums</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(one)         <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(restNums)    <span class="comment">// [ 2, 3 ]</span></span><br></pre></td></tr></table></figure>

<p><code>nums</code> 的第一项赋值给了变量 <code>one</code>, 而它的剩余参数，则以数组的形式以此添加到了 <code>restNums</code> 中。</p>
<p>在 <code>ES5</code>中我们想要克隆一个数组，可能会用到 <code>concat()</code> 方法来克隆数组，而在 <code>ES6</code> 中，我们可以使用<strong>剩余参数</strong>的形式，更加方便的达到同样的目的。</p>
<p>ES5中克隆数组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> copyNums = nums.concat()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(copyNums) <span class="comment">// [ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure>

<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/concat" target="_blank" rel="noopener">concat</a>方法：用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。</p>
<p>ES6中使用<strong>剩余参数</strong>克隆数组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> copyNums = [ ...nums ]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(copyNums) <span class="comment">// [ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure>

<p>!&gt; 数组剩余参数，也必须是数组解构模式中的最后部分，之后不能有逗号，否则就是语法错误。</p>
<h3 id="解构嵌套对象和数组"><a href="#解构嵌套对象和数组" class="headerlink" title="解构嵌套对象和数组"></a>解构嵌套对象和数组</h3><p>对象与数组解构能被用在一起，以创建更复杂的解构表达式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> createElement = [</span><br><span class="line">    <span class="string">'div'</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        className: <span class="string">'foo'</span>,</span><br><span class="line">        style: &#123;</span><br><span class="line">            color: <span class="string">'red'</span>,</span><br><span class="line">            fontSize: <span class="string">'14px'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    [</span><br><span class="line">        <span class="string">'这是一段内容!'</span>,</span><br><span class="line">        [</span><br><span class="line">            <span class="string">'h1'</span>,</span><br><span class="line">            &#123;&#125;,</span><br><span class="line">            <span class="string">'这是一段文本！'</span></span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [</span><br><span class="line">    ,</span><br><span class="line">    &#123;</span><br><span class="line">        className,</span><br><span class="line">        style: &#123; color, fontSize &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    content</span><br><span class="line">] = createElement</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(className) <span class="comment">// foo</span></span><br><span class="line"><span class="built_in">console</span>.log(color)     <span class="comment">// red</span></span><br><span class="line"><span class="built_in">console</span>.log(fontSize)  <span class="comment">// 14px</span></span><br><span class="line"><span class="built_in">console</span>.log(content)   <span class="comment">// [ '这是一段内容!', [ 'h1', &#123;&#125;, '这是一段文本！' ] ]</span></span><br></pre></td></tr></table></figure>

<p>此代码将 <code>createElement</code> 数组中的，<code>createElement[1]</code> 对象中的 <code>className</code> 与 <code>style</code> 下的 <code>color</code>、 <code>fontSize</code> 和 <code>createElement[2]</code> 的值提取了出来。混合使用对象与数组解构，可以把 <code>createElement</code> 中的任何部分提取出来。</p>
<h3 id="函数参数解构"><a href="#函数参数解构" class="headerlink" title="函数参数解构"></a>函数参数解构</h3><p>解构还有一个特别有用的场景，即在传递函数参数时。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    name,</span></span></span><br><span class="line"><span class="function"><span class="params">    value,</span></span></span><br><span class="line"><span class="function"><span class="params">    &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        secure,</span></span></span><br><span class="line"><span class="function"><span class="params">        path,</span></span></span><br><span class="line"><span class="function"><span class="params">        domain,</span></span></span><br><span class="line"><span class="function"><span class="params">        expires</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(secure)  <span class="comment">// true</span></span><br><span class="line">    <span class="built_in">console</span>.log(path)    <span class="comment">// undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(domain)  <span class="comment">// undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(expires) <span class="comment">// 60000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 cookie 的代码</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三个参数映射到 setCookie 的第三个参数上</span></span><br><span class="line">setCookie(</span><br><span class="line">    <span class="string">"type"</span>,</span><br><span class="line">    <span class="string">"js"</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        secure: <span class="literal">true</span>,</span><br><span class="line">        expires: <span class="number">60000</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上面的代码我们可以看成这样来理解。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; secure, path, domain, expires &#125; = options</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(secure)  <span class="comment">// true</span></span><br><span class="line">    <span class="built_in">console</span>.log(path)    <span class="comment">// undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(domain)  <span class="comment">// undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(expires) <span class="comment">// 60000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 cookie 的代码</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三个参数映射到 setCookie 的第三个参数上</span></span><br><span class="line">setCookie(</span><br><span class="line">    <span class="string">"type"</span>,</span><br><span class="line">    <span class="string">"js"</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        secure: <span class="literal">true</span>,</span><br><span class="line">        expires: <span class="number">60000</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>不过上面的代码还有一点小问题，当我们在默认情况下调用函数时，不传递第三个参数的时候，解构赋值会抛出错误。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    name,</span></span></span><br><span class="line"><span class="function"><span class="params">    value,</span></span></span><br><span class="line"><span class="function"><span class="params">    &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        secure,</span></span></span><br><span class="line"><span class="function"><span class="params">        path,</span></span></span><br><span class="line"><span class="function"><span class="params">        domain,</span></span></span><br><span class="line"><span class="function"><span class="params">        expires</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(secure)  <span class="comment">// true</span></span><br><span class="line">    <span class="built_in">console</span>.log(path)    <span class="comment">// undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(domain)  <span class="comment">// undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(expires) <span class="comment">// 60000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 cookie 的代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出错误 Cannot destructure property `secure` of 'undefined' or 'null'.</span></span><br><span class="line">setCookie(<span class="string">"type"</span>, <span class="string">"js"</span>)</span><br></pre></td></tr></table></figure>

<p>这是因为函数调用时，当我们不传递第三个参数时，实际上它会默认等于 <code>undefined</code>，这就导致了参数在进行解构时会抛出错误。</p>
<p>想要解决上面的错误，我们可以给函数参数设置一个默认值，当用户不传递或者传递 <code>undefined</code> 时，就会应用我们的默认值。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    name,</span></span></span><br><span class="line"><span class="function"><span class="params">    value,</span></span></span><br><span class="line"><span class="function"><span class="params">    &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        secure = true, <span class="regexp">//</span> 函数参数解构的默认值</span></span></span><br><span class="line"><span class="function"><span class="params">        path = <span class="string">""</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        domain,</span></span></span><br><span class="line"><span class="function"><span class="params">        expires = <span class="number">60000</span></span></span></span><br><span class="line"><span class="function"><span class="params">    &#125; = &#123;&#125;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(secure)  <span class="comment">// true</span></span><br><span class="line">    <span class="built_in">console</span>.log(path)    <span class="comment">// ""</span></span><br><span class="line">    <span class="built_in">console</span>.log(domain)  <span class="comment">// undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(expires) <span class="comment">// 60000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 cookie 的代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setCookie(<span class="string">"type"</span>, <span class="string">"js"</span>)</span><br></pre></td></tr></table></figure>

<p>这样的话就不会有错误抛出了。</p>
<p>?&gt; 函数参数解构的默认值，只需向上面的例子中，每个参数后面添加等号指定默认值就可以了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>解构使得在 <code>JS</code> 中操作对象与数组变得更容易。使用熟悉的对象字面量与数组字面量语法，可以将数据结构分离并只获取你感兴趣的信息。<code>对象解构模式</code>允许你从对象中进行提取，而<code>数组模式</code>则能用于数组。</p>
<p><code>对象</code>与<code>数组解构</code>都能在属性或项未定义时为其提供默认值；在赋值表达式右侧的值为 <code>null</code> 或 <code>undefined</code> 时，两种模式都会抛出错误。你也可以在深层嵌套的数据结构中使用对象与数组解构，下行到该结构的任意深度。</p>
<p>使用 <code>var</code> 、 <code>let</code> 或 <code>const</code> 的解构声明来创建变量，就必须提供初始化器。解构赋值能替代其他赋值，并且允许你把值解构到对象属性或已存在的变量上。</p>
<p><code>参数解构</code>使用解构语法作为函数的参数，让“选项”（ <code>options</code> ）对象更加透明。你实际感兴趣<br>的数据可以与具名参数一并列出。解构的参数可以是<code>对象模式</code>、<code>数组模式</code>或<code>混合模式</code>，并且你能使用它们的所有特性。</p>
]]></content>
  </entry>
  <entry>
    <title>扩展的对象功能</title>
    <url>/2019/12/16/js/expansionObject/</url>
    <content><![CDATA[<h1 id="扩展的对象功能"><a href="#扩展的对象功能" class="headerlink" title="扩展的对象功能"></a>扩展的对象功能</h1><p>ES6注重于提高对象的效用，这是因为在JS中几乎所有的值都是某种类型的对象。</p>
<h3 id="对象类别"><a href="#对象类别" class="headerlink" title="对象类别"></a>对象类别</h3><p>JS使用混合术语来描述能在标准中找到的对象，而不是那些有运行环境（例如浏览器或Node.js）所添加的，并且ES6规范还明确定义了对象的每种类别。</p>
<p>对象类别包括：</p>
<ul>
<li>普通对象：拥有<strong>JS</strong>对象所有默认的内部行为。</li>
<li>奇异对象：其内部行为在某些方面有别于默认行为。</li>
<li>标准对象：在<strong>ES6</strong>中被定义的对象，例如 <code>Array</code>、<code>Date</code>等等。标准对象可以是普通的，也可以是奇异的。</li>
<li>内置对象：在脚本开始运行时由<strong>JS</strong>运行环境提供的对象。所有的标准对象都是内置对象。</li>
</ul>
<h3 id="对象字面量语法的扩展"><a href="#对象字面量语法的扩展" class="headerlink" title="对象字面量语法的扩展"></a>对象字面量语法的扩展</h3><p>对象字面量（object literal）。对象字面量是由一对花括号，并且包含“键/值对”的简单集合。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">'zzzhim'</span>,</span><br><span class="line">    age: <span class="number">22</span>,</span><br><span class="line">    sex: <span class="string">'男'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>?&gt; 对象字面量是<strong>JS</strong>中最流行的模式之一（<strong>JSON</strong>就是基于这种语法），而它还存在与互联网上的几乎所以<strong>JS</strong>文件中。</p>
<h3 id="属性初始化器的速记法"><a href="#属性初始化器的速记法" class="headerlink" title="属性初始化器的速记法"></a>属性初始化器的速记法</h3><p>对象字面量是“键/值对”的简单集合。这意味着在属性值被初始化时可能会有些重复。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObject</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        age: age,</span><br><span class="line">        sex: sex</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>createObject()</code> 函数创建了一个对象，它的属性名和参数名相同。这个结果实际上有些重复，尽管一边是<code>键</code>，一边是<code>值</code>。</p>
<p>在<strong>ES6</strong>中，给我们提供了一种跟便捷的方式来书写。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObject</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name,</span><br><span class="line">        age,</span><br><span class="line">        sex</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中我们可以使用属性初始化器的速记法来消除对象名称与本地变量重复的情况，当对象的中的属性和名称重复的时候，我们可以省略掉值和冒号。</p>
<p>?&gt; 这是因为当对象的字面量只有名称的时候，<strong>JS</strong>引擎会在当前作用域和它的周边作用域查找同名变量，如果找到同名变量，就会把它的值赋值给该对象的同名属性。</p>
<h3 id="方法简写"><a href="#方法简写" class="headerlink" title="方法简写"></a>方法简写</h3><p><strong>ES6</strong>同样改进了为对象字面量方法赋值的语法。在<strong>ES5</strong>以及更早版本中，你必须指定一个名称并用完整的函数定义来为对象添加方法。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">'zzzhim'</span>,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<strong>ES6</strong>中我们可以通过省略 /<em>冒号和 function</em>/ 关键字来使这个语法变得更加简洁。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">'zzzhim'</span>,</span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种速记语法也被称为方法简写语法（<strong>concise method syntax</strong>）。</p>
<p>?&gt; 这种方法与上面的唯一区别是：方法简写能够使用 <code>super</code>,而非简写方法则不能。（<code>super</code>会在后面介绍使用）。</p>
<h3 id="需计算属性名"><a href="#需计算属性名" class="headerlink" title="需计算属性名"></a>需计算属性名</h3><p>在<strong>ES6</strong>中，需计算属性名是对象字面量语法的一部分，它用的是方括号表示法。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> lastName = <span class="string">"last name"</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    <span class="string">"first name"</span>: <span class="string">"zzz"</span>,</span><br><span class="line">    [lastName]: <span class="string">"him"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">"first name"</span>]) <span class="comment">// zzz</span></span><br><span class="line"><span class="built_in">console</span>.log(person[lastName])     <span class="comment">// him</span></span><br></pre></td></tr></table></figure>

<p>我们也可以在方括号中使用表达式。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> lastName = <span class="string">"last"</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    <span class="string">"first name"</span>: <span class="string">"zzz"</span>,</span><br><span class="line">    [lastName + <span class="string">" name"</span>]: <span class="string">"him"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">"first name"</span>]) <span class="comment">// zzz</span></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">"last name"</span>])     <span class="comment">// him</span></span><br></pre></td></tr></table></figure>

<p>?&gt; 使用方括号表达法，任何能放在对象实例方括号内的东西，都可以作为需计算属性名用在对象字面量中。</p>
<h3 id="新的方法"><a href="#新的方法" class="headerlink" title="新的方法"></a>新的方法</h3><p>ES6 在 <code>Object</code> 对象上引入了两个新方法，<code>Object.is()</code> 和 <code>Object.assign()</code> 方法。</p>
<h6 id="Object-is-方法"><a href="#Object-is-方法" class="headerlink" title="Object.is() 方法"></a><strong>Object.is()</strong> 方法</h6><p>当在<strong>JS</strong>中比较两个值时，我们经常会使用相等运算符（<code>==</code>）或严格相等运算符（<code>===</code>）。</p>
<p>当我们使用<strong>相等运算符</strong>的时候，<strong>相等运算符</strong>会比较两个值是否相等，在比较前会将被比较的值进行隐式转换，转换为相同的类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">"0"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num == num) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(num == str) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(str == str) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(num == <span class="literal">false</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(num == <span class="literal">null</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(str == <span class="literal">null</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(num == <span class="literal">undefined</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(str == <span class="literal">undefined</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> == <span class="literal">undefined</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>当我们使用<strong>严格相等运算符</strong>的时候。<strong>严格相等运算符</strong>比较两个值是否相等，类型是否相等。当值和类型都相等的时候结果为 <code>true</code>。在两个被比较的值在比较前是不会进行隐式转换的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"0"</span>);</span><br><span class="line"><span class="keyword">const</span> str = <span class="string">"0"</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num === num); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(obj === obj); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(str === str); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num === obj); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(num === str); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(obj === str); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> === <span class="literal">undefined</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(obj === <span class="literal">null</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(obj === <span class="literal">undefined</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>但严格相等运算符也并不完全准确，例如，它会认为 <code>+0</code> 和 <code>-0</code> 相等，即使这两者在 JS 引擎中有不同的表示；另外 <code>NaN</code> === <code>NaN</code> 会返回 <code>false</code> ，因此有必要使用 <code>isNaN()</code> 函数来正确检测 <code>NaN</code> 。</p>
<p><strong>ES6</strong> 引入了 <code>Object.is()</code> 方法来弥补<strong>严格相等运算符</strong>残留的怪异点。此方法接受两个参数，并且会在二者的值相等时返回 <code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> == <span class="number">-0</span>)            <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> === <span class="number">-0</span>)           <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>))   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> == <span class="literal">NaN</span>)          <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>)         <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>?&gt; 在许多情况下 <code>Object.is()</code> 的结果与<strong>严格相等运算符</strong>是相同的，仅有的例外是： 它会认为  <code>+0</code> 和 <code>-0</code> 不相等，而且 <code>NaN</code> 等于 <code>NaN</code>。</p>
<h6 id="Object-assign-方法"><a href="#Object-assign-方法" class="headerlink" title="Object.assign() 方法"></a>Object.assign() 方法</h6><p>Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p>
<p><strong>Object.assign()</strong> 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后面的源对象的属性将类似地覆盖前面的源对象的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source = &#123;</span><br><span class="line">    b: <span class="number">3</span>,</span><br><span class="line">    c: <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> copy = <span class="built_in">Object</span>.assign(target, source)</span><br><span class="line"><span class="built_in">console</span>.log(copy)</span><br></pre></td></tr></table></figure>

<p>需要注意的是 <code>Object.assign()</code> 进行的是浅拷贝，拷贝的是属性值。假如源对象的值是一个对象的引用，那么它也只指向那个引用。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source = &#123;</span><br><span class="line">    b: <span class="number">3</span>,</span><br><span class="line">    c: &#123;</span><br><span class="line">        a: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> copy = <span class="built_in">Object</span>.assign(target, source)</span><br><span class="line"><span class="built_in">console</span>.log(copy)   <span class="comment">// &#123; a: 1, b: 3, c: &#123; a: 1 &#125; &#125;</span></span><br><span class="line"></span><br><span class="line">source.c.a = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(source) <span class="comment">// &#123; a: 1, b: 3, c: &#123; a: 2 &#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(copy)   <span class="comment">// &#123; a: 1, b: 3, c: &#123; a: 2 &#125; &#125;</span></span><br></pre></td></tr></table></figure>

<p>?&gt; 如果我们需要进行深拷贝可以使用 <code>JSON</code> 进行深拷贝，这也是目前很常见的一种深拷贝方式。</p>
<h3 id="修改对象的原型"><a href="#修改对象的原型" class="headerlink" title="修改对象的原型"></a>修改对象的原型</h3><p>一般来说，对象的原型会在通过构造器或者 <code>Object.create()</code> 方法创建该对象时被指定。<strong>ES6</strong> 通过添加了 <code>Object.setPrototypeOf()</code> 方法，允许我们修改任意对象的原型。</p>
<p><code>Object.setPrototypeOf()</code> 接受两个参数：第一个参数是要设置原型的对象，第二个参数是该对象的新原型（<code>Object</code> 或者 <code>null</code>）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Woof"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> friend = <span class="built_in">Object</span>.create(person)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting()) <span class="comment">// Hello</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === person) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, dog)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting()) <span class="comment">// Woof</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === person) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === dog) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>通过上面的例子我们可以看到，通过 <code>Object.getPrototypeOf()</code> 我们可以把一个对象的原型指向另外一个对象。</p>
<p>?&gt; 对象原型的实际值被存储在一个内部属性 <code>[[Prototype]]</code> 上， <code>Object.getPrototypeOf()</code> 方法会返回此属性存储的值，而 <code>Object.setPrototypeOf()</code> 方法则能够修改该值。不过，使用<code>[[Prototype]]</code> 属性的方式还不止这些。</p>
<h3 id="使用-super-引用的简单原型访问"><a href="#使用-super-引用的简单原型访问" class="headerlink" title="使用 super 引用的简单原型访问"></a>使用 super 引用的简单原型访问</h3><p><strong>super</strong> 关键字用于访问和调用一个对象的父对象上的函数。<strong>super</strong>是指向当前对象的原型的一个指针，实际上就是 <code>Object.getPrototypeOf()</code> 的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    method() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"obj1"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">    method() &#123;</span><br><span class="line">        <span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">this</span>).method()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj2, obj1)</span><br><span class="line">obj2.method() <span class="comment">// obj1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj3 = &#123;</span><br><span class="line">    method() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"obj3"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj2, obj3)</span><br><span class="line">obj2.method() <span class="comment">// obj3</span></span><br></pre></td></tr></table></figure>

<h3 id="正式的方法定义"><a href="#正式的方法定义" class="headerlink" title="正式的方法定义"></a>正式的方法定义</h3><p>在<strong>ES6</strong>之前，“方法”的概念从未被正式定义，它此前仅指对象的函数属性（而非数据属性）。ES6则正式做出了定义：方法是一个拥有<code>[[HomeObject]]</code>内部属性的函数，此内部属性指向该方法所属的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并非方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shareGreeting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hi!"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此例定义了拥有单个 <code>getGreeting()</code> 方法的 <code>person</code> 对象。由于 <code>getGreeting()</code> 被直接赋给了一个对象，它的 <code>[[HomeObject]]</code> 属性值就是 <code>person</code> 。 而另一方面， <code>shareGreeting()</code>函数没有被指定 <code>[[HomeObject]]</code> 属性，因为它在被创建时并没有赋给一个对象。大多数情况下，这种差异并不重要，然而使用 <code>super</code> 引用时就完全不同了。</p>
<p>任何对 <code>super</code> 的引用都会使用 <code>[[HomeObject]]</code> 属性来判断要做什么。第一步是在<code>[[HomeObject]]</code> 上调用 <code>Object.getPrototypeOf()</code> 来获取对原型的引用；接下来，在该原型上查找同名函数；最后，创建 <code>this</code> 绑定并调用该方法。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对象是 <code>JS</code> 编程的中心， <code>ES6</code> 对它进行了一些有益改进，让它更易用并且更加强大。</p>
<p><code>ES6</code> 为对象字面量做了几个改进。速记法属性定义能够更轻易地将作用域内的变量赋值给对象的同名属性；<strong>需计算属性名</strong>允许你将非字面量的值指定为属性的名称，就像此前在其他场合的用法那样；方法简写让你在对象字面量中定义方法时能省略冒号和 <code>function</code> 关键字，从而减少输入的字符数； <code>ES6</code> 还舍弃了对象字面量中重复属性名的检查，意味着你可以在一个对象字面量中书写两个同名属性，而不会抛出错误。</p>
<p><code>Object.assign()</code> 方法使得一次性更改单个对象的多个属性变得更加容易，这在你使用混入模<br>式时非常有用。 <code>Object.is()</code> 方法对任何值都会执行严格相等比较，当在处理特殊的 <code>JS</code> 值<br>时，它有效成为了 <code>===</code> 的一个更安全的替代品。</p>
<p>对象自有属性的枚举顺序在 <code>ES6</code> 中被明确定义了。在枚举属性时，数字类型的键总是会首先出现，并按升序排列，此后是字符串类型的键，最后是符号类型的键，后两者都分别按添加顺序排列。</p>
<p>感谢 <code>ES6</code> 的 <code>Object.setPrototypeOf()</code> 方法，现在能够在对象已被创建之后更改它的原型了。</p>
<p>最后，你能用 <code>super</code> 关键字来调用对象原型上的方法，所调用的方法会被设置好其内部的<code>this</code> 绑定，以自动使用该 <code>this</code> 值来进行工作。</p>
]]></content>
  </entry>
  <entry>
    <title>迭代器与生成器</title>
    <url>/2019/12/16/js/generator/</url>
    <content><![CDATA[<h1 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h1><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器是被设计专用与迭代的对象，带有特定接口。所有的迭代器对象都拥有 <code>next()</code> 方法，会返回一个结果对象。该结果对象有两个属性：对应下一个值的 <code>value</code>，以及一个布尔类型的 <code>done</code>，其值为 <code>true</code> 时表示没有更多值可供使用。迭代器持有一个指向集合位置的内部指针，每当调用了 <code>next()</code> 方法，迭代器就会返回相应的下一个值。</p>
<p>如果在最后一个值返回后再调用 <code>next()</code> ，所返回的 <code>done</code> 属性值会是 <code>true</code> ，并且 <code>value</code> 属性值会是迭代器自身的返回值（<strong>return value</strong> ， 即使用 return 语句明确返回的值）。</p>
<p>在<strong>ES5</strong>中创建一个迭代器。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createIterator</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> done = (i &gt;= items.length)</span><br><span class="line">            <span class="keyword">var</span> value = !done ? items[i++] : <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                done: done,</span><br><span class="line">                value: value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = createIterator([ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ])</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: 1, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: 2, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: 3, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></span><br></pre></td></tr></table></figure>

<p><code>createIterator()</code> 函数返回一个带有 <code>next()</code> 方法的对象。每当调用此方法时， <code>items</code> 数组的下一个值就会成为所返回的 <code>value</code> 属性的值。当 <code>i</code> 的值为 3 时， <code>done</code> 属性变成 <code>true</code> ，并且利用三元运算符讲 <code>value</code> 设置为 <code>undefined</code>。</p>
<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>生成器（<strong>generator</strong>）是能返回一个迭代器的函数。生成器函数由放在 <code>function</code> 关键字之后的一个星号（<code>*</code>）来表示，并能使用新的 <code>yield</code> 关键字。将星号紧跟在 <code>function</code> 关键字后，或是在中间留空格都可以。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成器调用会返回一个迭代器</span></span><br><span class="line"><span class="keyword">const</span> iterator = createIterator()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: 1, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: 2, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: 3, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></span><br></pre></td></tr></table></figure>

<p><code>createIterator()</code> 前面的星号让此函数变成一个生成器。 <code>yield</code> 关键字也是 ES6 新增的，指定了迭代器在被 <code>next()</code> 方法调用时应当按顺序返回的值。</p>
<p>?&gt; 生成器函数最有意思的方面是它们会在每次 <code>yield</code> 语句后停止执行，直到迭代器的 <code>next()</code> 方法再次被调用，才继续执行后面的 <code>yield</code> 语句。</p>
<blockquote>
<p><code>yield</code> 关键字只能用在生成器内部，用于其他任意位置都是语法错误，即使在生成器内部的函数中也不行，正如此例：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">createIterator</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">    items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 语法错误</span></span><br><span class="line">        <span class="keyword">yield</span> item + <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="生成器函数表达式"><a href="#生成器函数表达式" class="headerlink" title="生成器函数表达式"></a>生成器函数表达式</h3><p>我们不但可以使用函数声明的方式创建一个生成器，也可以使用函数表达式来创建，只要在 <code>function</code> 关键字与圆括号之间使用一个星号（<code>*</code>）即可。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> createIterator = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iterator = createIterator()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: 1, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: 2, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: 3, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></span><br></pre></td></tr></table></figure>

<p>!&gt; 注意：不能将箭头函数创建为生成器。</p>
<h3 id="生成器对象方法"><a href="#生成器对象方法" class="headerlink" title="生成器对象方法"></a>生成器对象方法</h3><p>由于生成器就是函数，因此也可以被添加到对象中。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    *createIterator(items) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">            <span class="keyword">yield</span> items[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = obj.createIterator([ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ])</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: 1, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: 2, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: 3, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></span><br></pre></td></tr></table></figure>

<p>在使用ES6速记法中，由于 <code>createIterator()</code> 方法没有使用 <code>function</code> 关键字来定义，星号就紧贴在方法名之前，不过可以在星号和方法名之间留下空格。</p>
<h3 id="可迭代对象与-for-of-循环"><a href="#可迭代对象与-for-of-循环" class="headerlink" title="可迭代对象与 for-of 循环"></a>可迭代对象与 for-of 循环</h3><p>与迭代器紧密相关的是，可迭代对象（<strong>iterable</strong>）是包含 <code>Symbol.iterator</code> 属性的对象。这个 <code>Symbol.iterator</code> 知名符号定义了为指定对象返回迭代器的函数。在ES6中，所有的集合对象（数组、 Set 和 Map ）以及字符串都是可迭代对象，因此它们都被指定了默认的迭代器。</p>
<blockquote>
<p>生成器创建的所有迭代器都是可迭代对象，因为生成器默认就会为 <code>Symbol.iterator</code> 属性赋值。</p>
</blockquote>
<h3 id="访问默认迭代器"><a href="#访问默认迭代器" class="headerlink" title="访问默认迭代器"></a>访问默认迭代器</h3><p>想要访问对象上的默认迭代器，可以使用 <code>Symbol.iterator</code> 。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ]</span><br><span class="line"><span class="keyword">const</span> iterator = arr[<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: 1, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: 2, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: 3, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></span><br></pre></td></tr></table></figure>

<h3 id="检测一个对象是否能进行迭代"><a href="#检测一个对象是否能进行迭代" class="headerlink" title="检测一个对象是否能进行迭代"></a>检测一个对象是否能进行迭代</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isIterator</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> obj[<span class="built_in">Symbol</span>.iterator] === <span class="string">"function"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isIterator([ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ])) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterator(<span class="string">'123456'</span>))    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterator(<span class="keyword">new</span> <span class="built_in">Map</span>()))   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>?&gt; 这个 <code>isIterable()</code> 函数仅仅查看对象是否存在一个类型为函数的默认迭代器。 <code>for-of</code> 循环在执行之前会做类似的检查。</p>
<h3 id="创建可迭代对象"><a href="#创建可迭代对象" class="headerlink" title="创建可迭代对象"></a>创建可迭代对象</h3><p>我们在自定义对象时，默认情况下不是可迭代对象，但是我们可以创建一个包含生成器的 <code>Symbol.iterator</code> 属性，让它们成为可迭代对象。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> collection = &#123;</span><br><span class="line">    items: [],</span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> <span class="keyword">this</span>.items) &#123;</span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">collection.items.push(<span class="number">1</span>)</span><br><span class="line">collection.items.push(<span class="number">2</span>)</span><br><span class="line">collection.items.push(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> collection) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item) <span class="comment">// 1 , 2 , 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个默认迭代器是用 <code>Symbol.iterator</code> 方法创建的，此方法是一个生成器（名称之前依然有星号）。接下来该生成器使用了一个 <code>for-of</code> 循环来对 <code>this.items</code> 中的值进行迭代，并使用了 <code>yield</code> 来返回每个值。 <code>collection</code> 对象依靠 <code>this.items</code> 的默认迭代器来工作，而非在定义的值上手动进行迭代。</p>
<h3 id="集合的迭代器"><a href="#集合的迭代器" class="headerlink" title="集合的迭代器"></a>集合的迭代器</h3><p>ES6 具有三种集合对象类型：数组、Map 和 Set。这三种类型都拥有如下的迭代器：</p>
<ul>
<li><code>entries()</code>：返回一个包含键值对的迭代器。</li>
<li><code>values()</code>：返回一个包含集合中的值的迭代器。</li>
<li><code>keys</code>：返回一个包含集合中的键的迭代器。</li>
</ul>
<p><strong>entries()</strong> 迭代器</p>
<p><code>entries()</code> 迭代器会在每次 <code>next()</code> 被调用时返回一个双项数组，此数组代表了集合中每个元素的键与值：对于数组来说，第一项是数值索引；对于Set，第一项也是值（因为它的值也会被视为键）；对于Map，第一项就是键。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ]</span><br><span class="line"><span class="keyword">const</span> nums = <span class="keyword">new</span> <span class="built_in">Set</span>([ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> ])</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([ [ <span class="string">"title"</span>, <span class="string">"ES6"</span> ], [ <span class="string">"content"</span>, <span class="string">"entries"</span> ] ])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> entry <span class="keyword">of</span> colors.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(entry)</span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="comment">// [ 0, "red" ]</span></span><br><span class="line">    <span class="comment">// [ 1, "green" ]</span></span><br><span class="line">    <span class="comment">// [ 2, "blue" ]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> entry <span class="keyword">of</span> nums.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(entry)</span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="comment">// [ 1, "1" ]</span></span><br><span class="line">    <span class="comment">// [ 2, "2" ]</span></span><br><span class="line">    <span class="comment">// [ 3, "3" ]</span></span><br><span class="line">    <span class="comment">// [ 4, "4" ]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> entry <span class="keyword">of</span> map.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(entry)</span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="comment">// [ "title", "ES6" ]</span></span><br><span class="line">    <span class="comment">// [ "content", "entries" ]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>values()</strong> 迭代器</p>
<p><code>values()</code> 迭代器仅仅能返回储存在集合内的值。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ]</span><br><span class="line"><span class="keyword">const</span> nums = <span class="keyword">new</span> <span class="built_in">Set</span>([ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> ])</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([ [ <span class="string">"title"</span>, <span class="string">"ES6"</span> ], [ <span class="string">"content"</span>, <span class="string">"entries"</span> ] ])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> entry <span class="keyword">of</span> colors.values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(entry)</span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="comment">// "red"</span></span><br><span class="line">    <span class="comment">// "green"</span></span><br><span class="line">    <span class="comment">// "blue"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> entry <span class="keyword">of</span> nums.values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(entry)</span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> entry <span class="keyword">of</span> map.values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(entry)</span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="comment">// "ES6"</span></span><br><span class="line">    <span class="comment">// "entries"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>keys()</strong> 迭代器</p>
<p><code>keys()</code> 迭代器能返回集合中的每一个键。对于数组来说，它只返回数值类型的键，永不返回数组的其他自有属性；Set 的键与值是相同的，因此它的 <code>keys()</code> 与 <code>values()</code> 返回了相同的迭代器；对于 Map ， <code>keys()</code> 迭代器返回了每个不重复的键。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ]</span><br><span class="line"><span class="keyword">const</span> nums = <span class="keyword">new</span> <span class="built_in">Set</span>([ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> ])</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([ [ <span class="string">"title"</span>, <span class="string">"ES6"</span> ], [ <span class="string">"content"</span>, <span class="string">"entries"</span> ] ])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> entry <span class="keyword">of</span> colors.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(entry)</span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="comment">// 0</span></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> entry <span class="keyword">of</span> nums.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(entry)</span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> entry <span class="keyword">of</span> map.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(entry)</span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="comment">// "title"</span></span><br><span class="line">    <span class="comment">// "content"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>集合类型的默认迭代器</strong></p>
<p>当 <code>for-of</code> 循环没有显示指定迭代器时，每种集合类型都有一个默认的迭代器供循环使用。 <code>values()</code> 方法是数组与 Set 的默认迭代器， 而 <code>entries()</code> 方法则是 Map 的默认迭代器。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ]</span><br><span class="line"><span class="keyword">const</span> nums = <span class="keyword">new</span> <span class="built_in">Set</span>([ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> ])</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([ [ <span class="string">"title"</span>, <span class="string">"ES6"</span> ], [ <span class="string">"content"</span>, <span class="string">"entries"</span> ] ])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与使用 colors.values() 相同</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> entry <span class="keyword">of</span> colors) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(entry)</span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="comment">// red</span></span><br><span class="line">    <span class="comment">// green</span></span><br><span class="line">    <span class="comment">// blue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与使用 nums.values() 相同</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> entry <span class="keyword">of</span> nums) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(entry)</span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与使用 map.entries() 相同</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> entry <span class="keyword">of</span> map) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(entry)</span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="comment">// [ "title", "ES6" ]</span></span><br><span class="line">    <span class="comment">// [ "content", "entries" ]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>字符串也可以使用迭代器配合 <code>for-of</code> 循环，因为我在实际应用中很少用到，对这方面了解的也不多，想要了解的话可以看一下 Understanding ECMAScript 6 ，里面有详细的介绍。</p>
</blockquote>
<h3 id="NodeList-的迭代器"><a href="#NodeList-的迭代器" class="headerlink" title="NodeList 的迭代器"></a>NodeList 的迭代器</h3><p>文档对象模型（DOM）具有一种 <code>NodeList</code> 类型，用于表示页面文档中元素的集合。需要注意的是 <code>NodeList</code> 不是一个数组，是一个类似数组的对象。不过虽然 <code>NodeList</code> 不是一个数组，但是可以使用 <code>forEach()</code> 对其进行迭代，也可以使用 <code>Array.from()</code> 将其转换为实际数组。</p>
<p>DOM关于 <code>NodeList</code> 的规定也包含了一个默认迭代器（此规定在 HTML 规范而非 ES6规范中），其表现方式与数组的默认迭代器一致。这意味着我们可以将 <code>NodeList</code> 用于 <code>for-of</code> 循环，或用于其他使用对象默认迭代器的场合。如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> divs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"div"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span>(<span class="keyword">let</span> div <span class="keyword">of</span> divs) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(div) <span class="comment">// 循环打印 div 元素</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="传递参数给迭代器"><a href="#传递参数给迭代器" class="headerlink" title="传递参数给迭代器"></a>传递参数给迭代器</h3><p>我们可以通过 <code>next()</code> 方法向迭代器传递参数。当一个参数被传递给 <code>next()</code> 方法时，该参数就会成为生成器内部 <code>yield</code> 语句的值。这种能力对于更多高级功能（例如异步编程）来说是非常重要的。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> first = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> second = <span class="keyword">yield</span> first + <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> second + <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = createIterator()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())  <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next(<span class="number">4</span>)) <span class="comment">// &#123; value: 6, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next(<span class="number">5</span>)) <span class="comment">// &#123; value: 8, done: false &#125;</span></span><br></pre></td></tr></table></figure>

<p>对于 <code>next()</code> 的首次调用是一个特殊情况，传给它的任意参数都会被忽略。由于传递给 <code>next()</code> 的参数会成为 <code>yield</code> 语句的值，该 <code>yield</code> 语句指的是上次生成器中断执行处的语句；然而 <code>next()</code> 方法第一次被调用时，生成器函数才刚刚开始执行，没有“上一次中断处的 <code>yield</code> 语句”可以赋值。所以第一次调用 <code>next()</code> 时，不能向其传递参数。</p>
<h3 id="在迭代器中抛出错误"><a href="#在迭代器中抛出错误" class="headerlink" title="在迭代器中抛出错误"></a>在迭代器中抛出错误</h3><p>能传递给迭代器的不仅是数据，还可以是错误条件。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> first = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> second</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        second = <span class="keyword">yield</span> first + <span class="number">2</span> <span class="comment">// yield 4 + 2 ，然后抛出错误</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">        second = <span class="number">6</span>; <span class="comment">// 当出错时，给变量另外赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">yield</span> second + <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iterator = createIterator()</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: 1, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next(<span class="number">4</span>)) <span class="comment">// "&#123; value: 6, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Boom"</span>))) <span class="comment">// "&#123; value: 9, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></span><br></pre></td></tr></table></figure>

<p>我们使用 <code>try-catch</code> 在代码中进行错误捕捉，当错误被抛出时， <code>catch</code> 部分捕捉到错误，并且将 <code>second</code> 重新赋值为 <code>6</code> ，然后再继续执行到下一个 <code>yield</code> 处并返回了 9 。</p>
<p>?&gt; <code>next()</code> 方法指示迭代器继续执行（可能会带着给定的值），而 <code>throw()</code> 方法则指示迭代器通过抛出一个错误继续执行。在调用点之后会发生什么，根据生成器内部的代码来决定。</p>
<h3 id="生成器的-return-语句"><a href="#生成器的-return-语句" class="headerlink" title="生成器的 return 语句"></a>生成器的 return 语句</h3><p>由于生成器是函数，我们也可以在内部使用 <code>return</code> 语句，既可以让生成器早一点退出执行，也可以指定在 <code>next()</code> 方法最后一次调用时的返回值。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iterator = createIterator()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: 2, done: true &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，当我们第二次调用 <code>next()</code> 方法时，值 <code>2</code> 会被返回在 <code>value</code> 字段中，此时的 <code>done</code> 字段的值第一次变成了 <code>true</code>。此后我们再调用 <code>next()</code> ，<code>value</code> 属性都会重新变回 <code>undefined</code>。</p>
<blockquote>
<p>扩展运算符与 <code>for-of</code> 循环会忽略 <code>return</code> 语句所指定的任意值。一旦它们看到 <code>done</code> 的值为 <code>true</code> ，它们就会停止操作而不会读取对应的 <code>value</code> 值。</p>
<blockquote>
<p>如下：</p>
</blockquote>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">createIterator1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">createIterator2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> iterator1 = createIterator1()</span><br><span class="line"><span class="keyword">const</span> iterator2 = createIterator2()</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> iterator1) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> iterator2) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="生成器委托"><a href="#生成器委托" class="headerlink" title="生成器委托"></a>生成器委托</h3><p>在某些情况下，将两个迭代器的值合并在一起会更有用。生成器可以用星号（<code>*</code>）配合 <code>yield</code> 这一特殊形式来委托其他的迭代器。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">numIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">colorIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"red"</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">"green"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">createCombinedIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> *numIterator()</span><br><span class="line">    <span class="keyword">yield</span> *colorIterator()</span><br><span class="line">    <span class="keyword">yield</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iterator = createCombinedIterator()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: "red", done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: "greed", done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: true, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>从上面的例子可以看出，<code>createCombinedIterator()</code> 依次委托了 <code>numIterator()</code> 与 <code>colorIterator()</code>，从外部看就像一个单一的迭代器，用于产生值。当我们每次调用 <code>next()</code> 就会委托给合适的生成器，直到创建的迭代器全部清空为止。</p>
<h3 id="异步任务运行"><a href="#异步任务运行" class="headerlink" title="异步任务运行"></a>异步任务运行</h3><h6 id="一个简单的任务运行器"><a href="#一个简单的任务运行器" class="headerlink" title="一个简单的任务运行器"></a>一个简单的任务运行器</h6><p>由于 <code>yield</code> 能停止运行，并在重新开始运行前等待 <code>next()</code> 方法被调用，我们就可以在没有回调函数的情况下实现异步调用。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">taskDef</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建迭代器</span></span><br><span class="line">    <span class="keyword">const</span> task = taskDef()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动任务</span></span><br><span class="line">    <span class="keyword">let</span> result = task.next()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归使用函数来保持对 `next()` 的调用</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!result.done) &#123;</span><br><span class="line">            result = task.next()</span><br><span class="line">            step()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始执行</span></span><br><span class="line">    step()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h6 id="带数据的任务运行"><a href="#带数据的任务运行" class="headerlink" title="带数据的任务运行"></a>带数据的任务运行</h6><p>我们也可以给上面的例子传递数据，只需要稍微改造一下。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">taskDef</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建迭代器</span></span><br><span class="line">    <span class="keyword">const</span> task = taskDef()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动任务</span></span><br><span class="line">    <span class="keyword">let</span> result = task.next()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归使用函数来保持对 `next()` 的调用</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!result.done) &#123;</span><br><span class="line">            result = task.next(result.value)</span><br><span class="line">            step()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始执行</span></span><br><span class="line">    step()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="built_in">console</span>.log(value) <span class="comment">// 1</span></span><br><span class="line">    value = <span class="keyword">yield</span> value + <span class="number">1</span></span><br><span class="line">    <span class="built_in">console</span>.log(value) <span class="comment">// 2</span></span><br><span class="line">    value = <span class="keyword">yield</span> value + <span class="number">1</span></span><br><span class="line">    <span class="built_in">console</span>.log(value) <span class="comment">// 3</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h6 id="异步任务运行器"><a href="#异步任务运行器" class="headerlink" title="异步任务运行器"></a>异步任务运行器</h6><p>由于 <code>yield</code> 表达式将它们的值传递给了任务运行器，这就意味着任意函数调用都必须返回一个值，并以某种方式标明该返回值是个异步操作调用，而任务运行器应当等待此操作。</p>
<p>此处是将返回值标明为异步操作的一种方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        callback(<span class="literal">null</span>, <span class="string">"Hi!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此例的目的是：任何打算让任务运行器调用的函数，都应当返回一个能够执行回调函数的函数。</p>
<p>虽然 <code>fetchData()</code> 函数是同步的，但你能延迟对回调函数的调用，从而轻易地将它改造为异步函数，就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            callback(<span class="literal">null</span>, <span class="string">"Hi!"</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合上面的例子，我们可以改造一下我们的任务运行器，当 <code>result.value</code> 是一个函数时我们就执行它，而不是仅仅将它传递给 <code>next()</code> 方法。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟异步操作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            callback(<span class="literal">null</span>, data)</span><br><span class="line">        &#125;, <span class="number">3000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">taskDef</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建迭代器</span></span><br><span class="line">    <span class="keyword">const</span> task = taskDef()</span><br><span class="line">    <span class="comment">// 启动任务</span></span><br><span class="line">    <span class="keyword">let</span> result = task.next()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归使用函数来保持对 `next()` 的调用</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!result.done) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> result.value === <span class="string">"function"</span>) &#123;</span><br><span class="line">                result.value(<span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(err) &#123;</span><br><span class="line">                        <span class="built_in">console</span>.log(err)</span><br><span class="line">                        <span class="keyword">return</span> </span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    result = task.next(data)</span><br><span class="line">                    step()</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                result = task.next(result.value)</span><br><span class="line">                step()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始执行</span></span><br><span class="line">    step()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="built_in">console</span>.log(value) <span class="comment">// 1</span></span><br><span class="line">    value = <span class="keyword">yield</span> fetchData(value + <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(value) <span class="comment">// 2</span></span><br><span class="line">    value = <span class="keyword">yield</span> fetchData(value + <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(value) <span class="comment">// 3</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>!&gt; 使用这种方法我们也可以进行异步函数的处理，不过这种方法也有它的缺点，我们无法确定返回的函数是否是异步的，而且返回的函数也必须要有回调方法。</p>
<!-- ### 总结
`Symbol.iterator` 符号被用于定义对象的默认迭代器。内置对象与自定义对象都可以使用这个符号，以提供一个能返回迭代器的方法。当 `Symbol.iterator` 在一个对象上存在时，该对象就会被认为是可迭代对象。 -->

]]></content>
  </entry>
  <entry>
    <title>函数</title>
    <url>/2019/12/16/js/fun/</url>
    <content><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h3 id="带参数默认值的函数"><a href="#带参数默认值的函数" class="headerlink" title="带参数默认值的函数"></a>带参数默认值的函数</h3><p>JS 函数的独特之处是可以接受任意数量的参数，而无视函数声明处的参数数量。这让定义的函数可以使用不同的参数数量来调用，调用时未提供的参数经常使用默认值来代替。</p>
<h6 id="在-ES5-中模拟参数默认值"><a href="#在-ES5-中模拟参数默认值" class="headerlink" title="在 ES5 中模拟参数默认值"></a>在 ES5 中模拟参数默认值</h6><p>我们可能会经常见到下面的方式来创建参数的默认值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url, timeout, callback</span>) </span>&#123;</span><br><span class="line">    timeout = <span class="number">3000</span></span><br><span class="line"></span><br><span class="line">    callback = callback || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(timeout)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的 <code>request</code> 函数中 <code>timeout</code> 和 <code>callback</code> 都是可选参数，因为他们都会在参数未被传值的情况下使用默认值。主要是因为 <strong>逻辑或运算符（||）</strong> 在左侧的值为假的情况下总会返回右侧的操作符。不过上面的方法存在 bug , 如果我们传入 <code>0</code> 、 <code>null</code> 或者 <code>false</code> 的话也会导致值会被替换掉。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">request(<span class="string">'/'</span>, <span class="number">0</span>) <span class="comment">// 3000</span></span><br><span class="line">request(<span class="string">'/'</span>, <span class="literal">null</span>) <span class="comment">// 3000</span></span><br><span class="line">request(<span class="string">'/'</span>, <span class="literal">false</span>) <span class="comment">// 3000</span></span><br></pre></td></tr></table></figure>

<p>在这种情况下可以使用 <code>typeof</code> 来检测参数的类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url, timeout, callback</span>) </span>&#123;</span><br><span class="line">    timeout = (<span class="keyword">typeof</span> timeout !== <span class="string">"undefined"</span>) ? timeout : <span class="number">3000</span></span><br><span class="line"></span><br><span class="line">    callback = (<span class="keyword">typeof</span> callback !== <span class="string">"undefined"</span>) ? callback : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(timeout)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">request(<span class="string">'/'</span>) <span class="comment">// 3000</span></span><br><span class="line">request(<span class="string">'/'</span>, <span class="number">0</span>) <span class="comment">// 0</span></span><br><span class="line">request(<span class="string">'/'</span>, <span class="literal">null</span>) <span class="comment">// null</span></span><br><span class="line">request(<span class="string">'/'</span>, <span class="literal">false</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>这是因为在函数的具名参数未被提供值时会默认是 <code>undefined</code>。虽然这种方法更加安全，但依然因为一个很简单的需求而书写了很多的代码。而 <code>ES6</code> 中为我们提供了更加简单的为参数提供默认值的方式。</p>
<h6 id="ES6-中的参数默认值"><a href="#ES6-中的参数默认值" class="headerlink" title="ES6 中的参数默认值"></a>ES6 中的参数默认值</h6><p>ES6中能更容易地为参数提供默认值，它使用了初始化的形式，可以在参数还未被正式传递进来时使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url, timeout = <span class="number">3000</span>, callback = function(</span>) </span>&#123;&#125;) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此函数也是只要求第一个参数始终被传递，而其他两个参数都有各自的默认值。但是这种写法比上面ES5的写法更加简洁，因为我们不需要再去额外的判断参数是否传递。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url, timeout = <span class="number">3000</span>, callback = function(</span>) </span>&#123;&#125;) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(timeout)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">request(<span class="string">'/'</span>) <span class="comment">// 3000</span></span><br><span class="line">request(<span class="string">'/'</span>, <span class="literal">undefined</span>) <span class="comment">// 3000</span></span><br><span class="line">request(<span class="string">'/'</span>, <span class="number">0</span>) <span class="comment">// 0</span></span><br><span class="line">request(<span class="string">'/'</span>, <span class="literal">null</span>) <span class="comment">// null</span></span><br><span class="line">request(<span class="string">'/'</span>, <span class="literal">false</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>?&gt; 可以看到当我们传递第二个参数为非 <code>undefined</code> 的值时，那么默认值不会被应用。</p>
<p>在函数声明中能指定任意一个参数的默认值，即使该参数排在未指定默认值的参数之前也是可以的。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url, timeout = <span class="number">3000</span>, callback</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(timeout)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">request(<span class="string">'/'</span>) <span class="comment">// 3000</span></span><br><span class="line">request(<span class="string">'/'</span>, <span class="literal">undefined</span>) <span class="comment">// 3000</span></span><br><span class="line">request(<span class="string">'/'</span>, <span class="number">0</span>) <span class="comment">// 0</span></span><br><span class="line">request(<span class="string">'/'</span>, <span class="literal">null</span>) <span class="comment">// null</span></span><br><span class="line">request(<span class="string">'/'</span>, <span class="literal">false</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h6 id="参数默认值如何影响-arguments-对象"><a href="#参数默认值如何影响-arguments-对象" class="headerlink" title="参数默认值如何影响 arguments 对象"></a>参数默认值如何影响 <strong>arguments</strong> 对象</h6><p><code>arguments</code> 对象会在使用参数默认值的时候有不同的表现。在ES5的非严格模式下，<code>arguments</code> 对象会反映出具名参数的变化。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixArgs</span>(<span class="params">first, second</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>])  <span class="comment">// true</span></span><br><span class="line">    <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>]) <span class="comment">// true</span></span><br><span class="line">    first = <span class="string">'c'</span></span><br><span class="line">    second = <span class="string">'d'</span></span><br><span class="line">    <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>])  <span class="comment">// true</span></span><br><span class="line">    <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>]) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mixArgs(<span class="string">'a'</span>, <span class="string">'b'</span>)</span><br></pre></td></tr></table></figure>

<p>?&gt; 可以看出在非严格模式下，<code>arguments</code> 总是会被更新来反映出具名参数的变化。因此当我们更改了 <code>first</code> 和 <code>second</code> 的值时，<code>arguments[0]</code> 和 <code>arguments[1]</code> 也会相应的更新。</p>
<p>在ES5的严格模式下，关于 <code>arguments</code> 对象的这种混乱情况被消除了，它不会再反映出具名参数的变化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixArgs</span>(<span class="params">first, second</span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>])  <span class="comment">// true</span></span><br><span class="line">    <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>]) <span class="comment">// true</span></span><br><span class="line">    first = <span class="string">'c'</span></span><br><span class="line">    second = <span class="string">'d'</span></span><br><span class="line">    <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>])  <span class="comment">// false</span></span><br><span class="line">    <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>]) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mixArgs(<span class="string">'a'</span>, <span class="string">'b'</span>)</span><br></pre></td></tr></table></figure>

<p>?&gt; 在严格模式下，我们再次修改 <code>first</code> 和 <code>second</code> 的值时，我们可以看到并不会再影响 <code>arguments</code> 了。</p>
<p>!&gt; 在ES6中，在使用参数默认值的函数中， <code>arguments</code> 对象的表现总是与 ES5 的严格模式一致，无论此时函数是否明确运行在严格模式下。参数默认值的存在触发了 <code>arguments</code> 对象与具名参数的分离。</p>
<h6 id="参数默认值表达式"><a href="#参数默认值表达式" class="headerlink" title="参数默认值表达式"></a>参数默认值表达式</h6><p>函数参数的默认值并没有要求一定是基本类型的值。一次我们也可以传入一个函数来产生参数的默认值。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2 = getValue(</span>)) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">10</span>)) <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>我们同时也可以将前面的参数作为后面参数的默认值。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2 = num1</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>)) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>?&gt; 上面的代码中，我们为两个参数都设置了默认值，意味着只传入第一个参数，会让两个参数获得相同的值，因此 <code>add(1)</code> 和 <code>add(1, 1)</code> 都会返回 2。也就是说我们实际上可以将前面声明的参数，作为默认值传递给后面的参数。</p>
<p>!&gt; 这里要注意，引用其他参数来作为参数的默认值时，仅能够引用前面的参数，因此前面的参数是不能使用后面的参数作为默认值的。详情可以参考 <code>let</code> 与 <code>const</code> 产生的暂时性死区。</p>
<h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><p>剩余参数（<strong>rest parameter</strong>）由三个点 （<code>...</code>）和一个紧跟着的具名参数指定，它会是包含传递给函数的其余参数的一个数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">num1, ...arr</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num1) <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">console</span>.log(arr)  <span class="comment">// [2, 3, 4, 5, 6]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pick(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<p>?&gt; 在上面的函数中 <code>arr</code> 是一个包含了 <code>num1</code> 之后的参数的剩余参数。它与包含了所有参数的 <code>arguments</code> 有所不同，后者不会把第一个参数也包含进去。</p>
<p>需要注意的是剩余参数有两个限制：</p>
<ol>
<li><p>一个函数里面只能有一个剩余参数，并且它必须被放在最后面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  语法错误：Rest parameter must be last formal parameter</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">num1, ...arr, num2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pick(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>剩余参数不能在对象字面量的 <code>setter</code> 属性中使用。这是因为对象字面量 <code>setter</code> 被限定只能使用单个参数；而剩余参数按照定义是不限制参数数量的，所以不能在此处使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123;</span><br><span class="line">    <span class="comment">// 语法错误：Setter function argument must not be a rest parameter</span></span><br><span class="line">    <span class="keyword">set</span> name(...value) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="函数构造器增强"><a href="#函数构造器增强" class="headerlink" title="函数构造器增强"></a>函数构造器增强</h3><p><code>Function</code> 构造器允许动态创建一个新函数。如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'num1'</span>, <span class="string">'num2'</span>, <span class="string">'return num1 + num2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>ES6增强了 <code>Function</code> 构造器的能力，允许我们使用默认参数以及剩余参数。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'num1 = 1'</span>, <span class="string">'num2 = 2'</span>, <span class="string">'return num1 + num2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add()) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'...num'</span>, <span class="string">'return num[0] + num[1]'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p>剩余参数允许我们把多个独立的参数合并到一个数组中，而扩展运算符则允许将一个数组进行分割，并将各个项作为分离的参数传给函数。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于 console.log(Math.max(1, 2, 3, 4, 5))</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...values)) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h3 id="ES6的名称属性"><a href="#ES6的名称属性" class="headerlink" title="ES6的名称属性"></a>ES6的名称属性</h3><p>ES6中给所有的函数都添加了自己的 <code>name</code> 属性值。</p>
<p>函数声明的情况下，<code>name</code> 属性返回一个函数声明的名称</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(doSomething.name) <span class="comment">// "doSomething"</span></span><br></pre></td></tr></table></figure>

<p>而匿名函数表达式的情况下，<code>name</code> 属性则是该函数所赋值的变量名称</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> doAnotherThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(doAnotherThing.name) <span class="comment">// doAnotherThing</span></span><br></pre></td></tr></table></figure>

<p>!&gt; 这里需要注意的一点是，当一个函数表达式赋值一个声明函数时，因为该函数表达式拥有自己的名称，该函数的名称将会是 <strong>函数表达式</strong> 声明的名称，因为此名称的优先级要高于赋值目标的变量名。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> doAnotherThing = <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(doAnotherThing.name) <span class="comment">// "doSomething"</span></span><br></pre></td></tr></table></figure>

<p>在使用 <code>bind</code> 所创建的函数将会在函数的名称前加上 <code>bound</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo.bind(<span class="literal">null</span>).name) <span class="comment">// "bound foo"</span></span><br></pre></td></tr></table></figure>

<p>当通过 get 和 set 访问器来存取属性时, “get” 或 “set” 会出现在函数名称前。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123; </span><br><span class="line">    <span class="keyword">get</span> foo() &#123;&#125;,</span><br><span class="line">    <span class="keyword">set</span> foo(x) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(o, <span class="string">"foo"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(descriptor.get.name) <span class="comment">// "get foo"</span></span><br><span class="line"><span class="built_in">console</span>.log(descriptor.set.name) <span class="comment">// "set foo"</span></span><br></pre></td></tr></table></figure>

<p>!&gt; <code>getter</code> 和 <code>setter</code> 函数都必须要用 <code>Object.getOwnPropertyDescriptor()</code> 来检索。</p>
<h3 id="明确函数双重作用"><a href="#明确函数双重作用" class="headerlink" title="明确函数双重作用"></a>明确函数双重作用</h3><p>在ES5以及更早版本中，函数根据是否使用 <code>new</code> 来调用而有双重用途。当使用 <code>new</code> 时，函数内部的 <code>this</code> 是一个新对象，并作为函数的返回值。</p>
<p>JS为函数提供了两个不同的内部方法： <code>[[Call]]</code> 与 <code>[[Construct]]</code> 。当函数未使用 <code>new</code> 来进行调用时， <code>[[Call]]</code> 方法会被执行，运行的是代码中显示的函数体。而当函数使用 <code>new</code> 进行调用时， <code>[[Construct]]</code> 方法则会被执行，负责创建一个被称为新目标的新的对象，并且使用该新目标作为 <code>this</code> 去执行函数体。拥有 <code>[[Construct]]</code> 方法的函数被称为构造器。</p>
<p>!&gt; 并不是所有函数都拥有 <code>[[Construct]]</code> 方法，因此不是所有函数都可以使用 <code>new</code> 来调用。在 <strong>箭头函数</strong>中，<strong>箭头函数</strong>就未拥有该方法。</p>
<h3 id="new-target-元属性"><a href="#new-target-元属性" class="headerlink" title="new.target 元属性"></a>new.target 元属性</h3><p>ES6 引入了 <code>new.target</code> 元属性。元属性指的是“非对象”（例如 <code>new</code> ）上的一个属性，并提供关联到它的目标的附加信息。当函数的 <code>[[Construct]]</code> 方法被调用时， <code>new.target</code> 会被填入 <code>new</code> 运算符的作用目标，该目标通常是新创建的对象实例的构造器，并且会成为函数体内部的 <code>this</code> 值。而若 <code>[[Call]]</code> 被执行， <code>new.target</code> 的值则会是 <code>undefined</code>。</p>
<p>我们可以通过检查 <code>new.target</code> 是否被定义，这个新的元属性就让你能安全地判断函数是否被使用 <code>new</code> 进行了调用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">new</span>.target !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"You must use new with Person."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="string">'奶糖'</span>)</span><br><span class="line"><span class="keyword">const</span> notAPrson = Person.call(person, <span class="string">'奶糖'</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>new.target</code>, <code>Person</code> 构造器会在未使用 <code>new</code> 调用时抛出错误。</p>
<p>我们也可以检查 <code>new.target</code> 是否被使用特定构造器进行了调用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">new</span>.target !== Person) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"You must use new with Person."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AnotherPerson</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="string">"奶糖"</span>)</span><br><span class="line"><span class="keyword">const</span> anotherPerson = <span class="keyword">new</span> AnotherPerson(<span class="string">"奶糖"</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数正如名称所示那样使用一个“箭头”（<code>=&gt;</code>）来定义，但它的行为在很多重要方面与传统的JS函数不同。</p>
<ul>
<li>没有 <code>this</code>、<code>super</code>、<code>arguments</code>，也没有 <code>new.target</code> 绑定：<code>this</code>、<code>super</code>、<code>arguments</code>、以及函数内部的 <code>new.target</code>的值的所在由最靠近的非箭头函数来决定。</li>
<li>不能被使用 <code>new</code> 调用：箭头函数没有 <code>[[Construct]]</code> 方法，因此不能被用为构造函数，使用 <code>new</code> 调用箭头函数会抛出错误。</li>
<li>没有原型：既然不能对箭头函数使用 <code>new</code> ，那么它也不需要原型，也就是没有 <code>prototype</code> 属性。</li>
<li>不能更改 <code>this</code>： <code>this</code> 的值在函数内部不能被修改，在函数的整个生命周期内其值会保持不变。</li>
<li>没有 <code>arguments</code> 对象：既然箭头函数没有 <code>arguments</code> 绑定，我们必须依赖于具名参数或剩余参数来访问函数的参数。</li>
<li>不允许重复的具名参数：箭头函数不允许拥有拥有重复的具名参数，无论是否在严格模式下；而相对来说，传统函数只有在严格模式下才禁止这种重复。</li>
</ul>
<h6 id="箭头函数语法"><a href="#箭头函数语法" class="headerlink" title="箭头函数语法"></a>箭头函数语法</h6><p>当接受单个参数时。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fun = <span class="function"><span class="params">value</span> =&gt;</span> value</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">const</span> fun = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当传递多个参数的时候</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fun = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">const</span> fun = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当包含多个语句的时候，我们需要将函数体用一对花括号进行包裹，并明确定义一个返回值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fun = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> num = num1 + num2</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">const</span> fun = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> num = num1 + num2</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="创建立即调用函数表达式"><a href="#创建立即调用函数表达式" class="headerlink" title="创建立即调用函数表达式"></a>创建立即调用函数表达式</h6><p>JS 中使用函数的一种流行方式是创建立即调用函数表达式（ immediately-invoked function<br>expression ， IIFE ）。 IIFE 允许你定义一个匿名函数并在未保存引用的情况下立刻调用它。</p>
<p>在ES5以及更早的版本中你可能会见到这种写法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'我的名字是'</span> + name</span><br><span class="line">&#125;(<span class="string">'zzzhim'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'我的名字是'</span> + name</span><br><span class="line">&#125;(<span class="string">'zzzhim'</span>)</span><br></pre></td></tr></table></figure>

<p>?&gt; 上面代码中当程序执行到上面的函数时，函数将会自执行并且返回一个字符串。</p>
<p>我们可以使用箭头函数来完成同样的效果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="params">name</span> =&gt;</span> <span class="string">'我的名字是'</span> + name)(<span class="string">'zzzhim'</span>)</span><br></pre></td></tr></table></figure>

<p>?&gt; 通过上面的代码我们可以看到使用箭头函数，我们可以达到同样的目的，并且代码更加简洁形象</p>
<p>| 使用传统函数时， (function(){/<em>函数体</em>/})() 与 (function(){/<em>函数体</em>/}())<br>这两种方式都是可行的。</p>
<p>| 但若使用箭头函数，则只有下面的写法是有效的： (() =&gt; {/<em>函数体</em>/})()</p>
<h3 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h3><p>在ES6中函数最有趣的改动或许就是一项引擎优化，它改变了尾部调用的系统。尾调用（<code>this call</code>）指的是调用函数的语句是另一个函数的最后语句。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doSomethingElse(); <span class="comment">// 尾调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ES6 在严格模式下力图为特定尾调用减少调用栈的大小（非严格模式的尾调用则保持不变）。当满足以下条件时，尾调用优化会清除当前栈帧并再次利用它，而不是为尾调用创建新的栈帧：</p>
<ol>
<li>尾调用不能引用当前栈帧中的变量（意味着该函数不能是闭包）；</li>
<li>进行尾调用的函数在尾调用返回结果后不能做额外操作；</li>
<li>尾调用的结果作为当前函数的返回值。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在特定参数被传入时，函数的默认参数允许我们更容易指定需要使用的值。而在ES6之前，这要求我们在函数内使用一些额外的代码检测才能实现默认参数。</p>
<p>剩余参数允许我们将余下的所有参数放入指定数组。使用真正的数组并让我们指定哪些参数需要被包含，使得剩余参数成为比 <code>arguments</code> 更为灵活的解决方案。</p>
<p>扩展运算符是剩余参数的好伙伴，允许我们在调用函数时将数组解构为分离的参数。在ES6之前我们想把数组的元素作为独立参数传给函数，只能有两种办法：手动指定或者使用 <code>apply()</code> 方法。</p>
<p>新增的 <code>name</code> 属性能帮我们在调试与执行方面更容易识别函数。</p>
<p>在ES6中，函数的行为被 <code>[[Call]]</code> 与 <code>[[Construct]]</code> 方法所定义，前者对应普通的函数执行，后者则对应使用了 <code>new</code> 的调用。 我们可以使用 <code>new.target</code> 元属性来判断函数被调用时是否使用了 <code>new</code> 。</p>
<p>ES6 函数的最大变化就是增加了箭头函数。箭头函数被设计用于替代匿名函数表达式，它拥<br>有更简洁的语法、词法级的 this 绑定，并且没有 arguments 对象。此外，箭头函数不能修<br>改它们的 this 绑定，因此不能被用作构造器。</p>
<p>尾调用优化允许某些函数的调用被优化，以保持更小的调用栈、使用更少的内存，并防止堆<br>栈溢出。当能进行安全优化时，它会由引擎自动应用。</p>
]]></content>
  </entry>
  <entry>
    <title>用模块封装代码</title>
    <url>/2019/12/16/js/modules/</url>
    <content><![CDATA[<h1 id="用模块封装代码"><a href="#用模块封装代码" class="headerlink" title="用模块封装代码"></a>用模块封装代码</h1><p>在 <strong>ES6</strong> 之前，一个应用的每个 <strong>JS</strong> 文件所定义的所有内容都由全局作用域共享。当应用变得非常复杂时，这会造成许多问题，例如命名冲突、安全问题等。<strong>ES6</strong> 的设计目标之一就是要解决作用域问题，让 <strong>JS</strong> 应用更加有条理，更容易维护。</p>
<h3 id="何为模块？"><a href="#何为模块？" class="headerlink" title="何为模块？"></a>何为模块？</h3><p>模块（<strong>Modules</strong>）是使用不同方法加载的 <strong>JS</strong> 文件（与 <strong>JS</strong> 原先的脚本加载方式相对）。这种不同模式很有必要，因为它与脚本（<strong>script</strong>） 有大大不同的语义：</p>
<ol>
<li>模块代码自动运行在严格模式下，并且没有任何办法跳出严格模式；</li>
<li>在模块的顶级作用域创建的变量，不会被自动添加到共享的全局作用域，它们只会在模块顶级作用域的内部存在；</li>
<li>模块顶级作用域的 <code>this</code> 值为 <code>undefined</code> ；</li>
<li>模块不允许在代码中使用 <strong>HTML</strong> 风格的注释（这是 <strong>JS</strong> 来自于早期浏览器的历史遗留特性）；</li>
<li>对于需要让模块外部代码访问的内容，模块必须导出它们；</li>
<li>允许模块从其他模块导入绑定。</li>
</ol>
<p>?&gt; 模块最重要的功能是可以按需导出与导入代码的能力，而不用将所有内容放在同一个文件内。</p>
<h3 id="基本的导出"><a href="#基本的导出" class="headerlink" title="基本的导出"></a>基本的导出</h3><p>想要把代码公开给其他模块，我们可以使用 <code>export</code> 关键字将代码导出给其他模块使用。最简单的方法就是把 <code>export</code> 放在函数、变量、类声明之前。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导出变量</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> age = <span class="number">23</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> color = <span class="string">"red"</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">"zzzhim"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出类</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">React</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length</span><br><span class="line">        <span class="keyword">this</span>.width = width</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个私有函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面被导出的函数或者类都有自己的名称，这是因为导出的函数声明与类声明必须要有名称。想要导出一个匿名函数或匿名类，需要使用 <code>default</code> 关键字（后面会提到）。</p>
<p>!&gt; 在模块中未被导出的 变量、函数、类，在模块外部都不可被访问，这是因为它们在模块内是私有的。</p>
<h3 id="基本的导入"><a href="#基本的导入" class="headerlink" title="基本的导入"></a>基本的导入</h3><p>我们可以在模块内使用 <code>import</code> 关键字来访问其他模块导出的功能。</p>
<p><code>import</code> 语句有两个部分，一是需要导入的标识符，二是需要导入的标识符的来源模块。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span></span><br></pre></td></tr></table></figure>

<p><code>import</code> 的花括号指明了从给定模块导入对应的绑定， <code>from</code> 关键字则指明了需要导入的模块。</p>
<p>?&gt; 当从模块导入了一个绑定时，该绑定表现的就像使用了 <code>const</code> 的定义。这意味着你不能再定义另一个同名变量（包括导入另一个同名绑定），也不能在对应的 <code>import</code> 语句之前使用此标识符（也就是要受到暂时性死区限制），更不能修改它的值。</p>
<h6 id="导入单个绑定"><a href="#导入单个绑定" class="headerlink" title="导入单个绑定"></a>导入单个绑定</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单个导入</span></span><br><span class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span></span><br></pre></td></tr></table></figure>

<h6 id="导入多个绑定"><a href="#导入多个绑定" class="headerlink" title="导入多个绑定"></a>导入多个绑定</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多个导入</span></span><br><span class="line"><span class="keyword">import</span> &#123; sum, React, age &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span></span><br></pre></td></tr></table></figure>

<h6 id="完全导入一个模块"><a href="#完全导入一个模块" class="headerlink" title="完全导入一个模块"></a>完全导入一个模块</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 完全导入</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> example <span class="keyword">from</span> <span class="string">"./example.js"</span></span><br></pre></td></tr></table></figure>

<p>在此例中，<code>example.js</code> 中所有导出的绑定都会被加载到一个名为 <code>example</code> 的对象中。这种导入格式被称为命名空间导入（<strong>namespace import</strong>），这是因为该 <code>example</code> 对象并不存在于 <code>example.js</code> 文件中，而是作为一个命名空间对象被创建使用。</p>
<p>?&gt; 无论你对同一个模块使用了多少次 <code>import</code> 语句，该模块都只会被执行一次。在导出模块的代码执行之后，已被实例化的模块就被保留在内存中，并随时都能被其他 <code>import</code> 所引用。</p>
<blockquote>
<p>你只能在模块的顶级作用域使用 <code>export</code> 。类似的，你不能在一个语句内部使用 <code>import</code> ，也只能将其用在顶级作用域。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (sum) &#123;</span><br><span class="line">    <span class="keyword">export</span> sum <span class="comment">// 语法错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tryImport</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span> <span class="comment">// 语法错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="重命名导出与导入"><a href="#重命名导出与导入" class="headerlink" title="重命名导出与导入"></a>重命名导出与导入</h6><p>假如我们想用不同的名称导出一个函数，我们可以使用 <code>as</code> 关键字来指定新的名称。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出函数</span></span><br><span class="line"><span class="keyword">export</span> &#123; sum <span class="keyword">as</span> add &#125;</span><br></pre></td></tr></table></figure>

<p>在此处 <code>sum</code> 是本地名称（<strong>local name</strong>），后者则是导出名称（<strong>exported name</strong>）。这意味着当另一个模块想要导入此函数时，需要使用 <code>add</code> 这个名称。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span></span><br></pre></td></tr></table></figure>

<p>如果模块导入函数时想使用另一个名称，同样也可以用 <code>as</code> 关键字：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; add <span class="keyword">as</span> sum &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> add) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h3 id="模块的默认值"><a href="#模块的默认值" class="headerlink" title="模块的默认值"></a>模块的默认值</h3><p>模块的默认值（<strong>default value</strong>）是使用 <code>default</code> 关键字所指定的单个变量、函数或类，在每个模块中只能设置一个默认导出，将 <code>default</code> 关键字用于多个导出会是语法错误。</p>
<h6 id="导出默认值"><a href="#导出默认值" class="headerlink" title="导出默认值"></a>导出默认值</h6><p>以下是使用 <code>default</code> 关键字的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导出默认值</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此模块中我们将一个函数作为默认值导出， <code>default</code> 关键字标明了这是一个默认导出。此函数不需要名称，因为它就代表了这个模块自身。</p>
<p>我们也可以这样指定一个默认的导出，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导出默认值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> sum</span><br></pre></td></tr></table></figure>

<h6 id="导入默认值"><a href="#导入默认值" class="headerlink" title="导入默认值"></a>导入默认值</h6><p>我们可以使用下列语法导入一个模块的默认值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入默认值</span></span><br><span class="line"><span class="keyword">import</span> sum <span class="keyword">from</span> <span class="string">"./example.js"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>对于即导出了默认值，又导出了非默认绑定的模块，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> color = <span class="string">"red"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出默认值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> sum</span><br></pre></td></tr></table></figure>

<p>我们可以使用这种方式导入非默认和默认值，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sum, &#123; color &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span></span><br></pre></td></tr></table></figure>

<h6 id="绑定的再导出"><a href="#绑定的再导出" class="headerlink" title="绑定的再导出"></a>绑定的再导出</h6><p>如果我们想把当前导入的模块再重新导出，只需这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sum, &#123; color &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; color &#125;</span><br></pre></td></tr></table></figure>

<p>当然我们也可以选择将一个值用不同名称导出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; color <span class="keyword">as</span> red &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span></span><br></pre></td></tr></table></figure>

<p>如果我们想将来自另一个模块的所有值完全导出，可以使用星号（ * ）模式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">"./example.js"</span></span><br></pre></td></tr></table></figure>

<h3 id="无绑定的导入"><a href="#无绑定的导入" class="headerlink" title="无绑定的导入"></a>无绑定的导入</h3><p>有些模块也许没有进行任何导出，可能我们只需要它做一些适配处理。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">doc, win</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> docEl = doc.documentElement,</span><br><span class="line">        resizeEvt = <span class="string">'orientationchange'</span> <span class="keyword">in</span> <span class="built_in">window</span> ? <span class="string">'orientationchange'</span> : <span class="string">'resize'</span>,</span><br><span class="line">        recalc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> clientWidth = docEl.clientWidth;</span><br><span class="line">            <span class="keyword">if</span> (!clientWidth) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span>(clientWidth&gt;= <span class="number">750</span>)&#123;</span><br><span class="line">                docEl.style.fontSize = <span class="string">'100px'</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                docEl.style.fontSize = <span class="number">100</span> * (clientWidth / <span class="number">750</span>) + <span class="string">'px'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!doc.addEventListener) <span class="keyword">return</span>;</span><br><span class="line">    win.addEventListener(resizeEvt, recalc, <span class="literal">false</span>);</span><br><span class="line">    doc.addEventListener(<span class="string">'DOMContentLoaded'</span>, recalc, <span class="literal">false</span>);</span><br><span class="line">    recalc();</span><br><span class="line">&#125;)(<span class="built_in">document</span>, <span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>

<p>我们只需要此代码在屏幕宽度变化时，做不同的适配。尽管我们并没有在该模块中做任何导出与导入，但它仍然是一个有效的模块。我们可以把它当做一个模块或者脚本使用。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"./example.js"</span></span><br></pre></td></tr></table></figure>

<p>由于它没有导出任何东西，我们可以使用此简化的导入语法来执行此模块的代码。</p>
<p>?&gt; 无绑定的导入经常被用于创建 <strong>polyfill</strong> 与 <strong>shim</strong> (也就是为新语法在旧环境中运行提供向下兼容的两种方式)。</p>
<h3 id="加载模块"><a href="#加载模块" class="headerlink" title="加载模块"></a>加载模块</h3><p>ES6 虽然定义了模块的语法，但是并未定义如何加载它们。。这是规范复杂性的一部分，这种复杂性对于实现环境来说是无法预知的。 ES6 未选择给所有 JS 环境努力创建一个有效的单一规范，而只对一个未定义的内部操作 <code>HostResolveImportedModule</code> 指定了语法以及抽象的加载机制。</p>
<h3 id="在-Web-浏览器中使用模块"><a href="#在-Web-浏览器中使用模块" class="headerlink" title="在 Web 浏览器中使用模块"></a>在 Web 浏览器中使用模块</h3><p>即使在 ES6 之前， web 浏览器都有多种方式在 web 应用中加载 JS 。这些可能的脚本加载选择是：</p>
<ol>
<li>使用 <code>&lt;script&gt;</code> 元素以及 <code>src</code> 属性来指定代码加载的位置，以便加载 JS 代码文件。</li>
<li>使用 <code>&lt;script&gt;</code> 元素但不使用 <code>src</code> 属性，来嵌入内联的 JS 代码。</li>
<li>加载 JS 代码文件并作为 <strong>Worker</strong> （例如 <strong>Web Worker</strong> 或 <strong>Service Worker</strong>）来执行。</li>
</ol>
<h6 id="在-script-标签中使用模块"><a href="#在-script-标签中使用模块" class="headerlink" title="在 script 标签中使用模块"></a>在 script 标签中使用模块</h6><p><code>&lt;script&gt;</code> 元素默认以脚本方式（而非模块）来加载 <strong>JS</strong> 文件，只要 <code>type</code> 属性缺失，或者 <code>type</code> 属性含有与 <strong>JS</strong> 对应的内容类型（如：<code>&quot;text/javascript&quot;</code>）。<code>&lt;script&gt;</code> 元素能够执行内联脚本，也能加载在 <code>src</code> 中指定的文件。为了支持模块，添加了 <code>&quot;module&quot;</code> 值作为 <code>type</code> 的选项。将 <code>type</code> 设置为 <code>&quot;module&quot;</code> ，就告诉了浏览器要将内联代码或是指定文件中的代码当做模块，而不是当作脚本。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载 js模块文件</span></span><br><span class="line">&lt;script type=<span class="string">"module"</span> src=<span class="string">"module.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">srcipt</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 包括内联模块</span></span><br><span class="line">&lt;script type=<span class="string">"module"</span>&gt;</span><br><span class="line">    <span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span></span><br><span class="line">    <span class="keyword">let</span> result = sum(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="Web-浏览器中的模块加载次序"><a href="#Web-浏览器中的模块加载次序" class="headerlink" title="Web 浏览器中的模块加载次序"></a>Web 浏览器中的模块加载次序</h6><p>模块相对脚本的独特之处在于：它们能使用 <code>import</code> 来指定必须要加载的其他文件，以保证正确执行。为了支持此功能， <code>&lt;script type=&quot;module&quot;&gt;</code> 总是表现得像是已经应用了 <code>defer</code> 属性。</p>
<p><code>defer</code> 属性是加载脚本文件时的可选项，但在加载模块文件时总是自动应用的。当 <strong>HTML</strong> 解析到拥有 <code>src</code> 属性的 <code>&lt;script type=&quot;module&quot;&gt;</code> 标签时，就会立即开始下载模块文件，但并不会执行它，直到整个网页文档全部解析完为止。这也就意味着模块会按照它们在 <strong>HTML</strong> 文件中出现的顺序依次执行。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个执行</span></span><br><span class="line">&lt;script type=<span class="string">"module"</span> src=<span class="string">"module1.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个执行</span></span><br><span class="line">&lt;script type=<span class="string">"module"</span>&gt;</span><br><span class="line">    <span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span></span><br><span class="line">    <span class="keyword">let</span> result = sum(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 第三个执行</span></span><br><span class="line"><span class="regexp">&lt;script type="module" src="module2.js"&gt;&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<p>所有模块无论是用 <code>&lt;script type=&quot;module&quot;&gt;</code> 显式包含的，还是用 <code>import</code> 隐式包含的，都会按照次序加载与执行。</p>
<p>前面的范例，完整的加载次序是：</p>
<ol>
<li>下载并解析 <code>module1.js</code>；</li>
<li>递归下载并解析在 <code>module1.js</code> 中使用 <code>import</code> 导入的资源；</li>
<li>解析内联模块；</li>
<li>递归下载并解析在内联模块中使用 <code>import</code> 导入的资源；</li>
<li>下载并解析 <code>module2.js</code>；</li>
<li>递归下载并解析在 <code>module2.js</code> 中使用 <code>import</code> 导入的资源；</li>
</ol>
<p>一旦加载完毕，直到页面文档被完整解析之前，都不会有任何代码被执行。在文档解析完毕后，会发生下列行为：</p>
<ol>
<li>递归执行 <code>module1.js</code> 导入的资源；</li>
<li>执行 <code>module1.js</code>；</li>
<li>递归执行内联模块导入的资源；</li>
<li>执行内联模块；</li>
<li>递归执行 <code>module2.js</code> 导入的资源；</li>
<li>执行 <code>module2.js</code>；</li>
</ol>
<blockquote>
<p><code>&lt;script type=&quot;module&quot;&gt;</code> 上的 <code>defer</code> 属性总是会被忽略，因为它已经应用了该属性。</p>
</blockquote>
<h6 id="Web-浏览器中的异步模块加载"><a href="#Web-浏览器中的异步模块加载" class="headerlink" title="Web 浏览器中的异步模块加载"></a>Web 浏览器中的异步模块加载</h6><p>当配合脚本使用时， <code>async</code> 会导致脚本文件在下载并解析完毕后就立即执行。但带有 <code>async</code> 的脚本在文档中的顺序却并不会影响脚本执行的次序，脚本总是会在下载完成后就立即执行，而无须等待包含它的文档解析完毕。</p>
<p><code>async</code> 属性也能同样被应用到模块上。在 <code>&lt;script type=&quot;module&quot;&gt;</code> 上使用 <code>async</code> 会导致模块的执行行为与脚本相似。唯一区别是模块中所有 <code>import</code> 导入的资源会在模块自身被执行前先下载。这保证了模块中所有需要的资源会在模块执行前被下载，你只是不能保证模块何时会执行。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不能保证哪个会先执行</span></span><br><span class="line">&lt;script type=<span class="string">"module"</span> <span class="keyword">async</span> src=<span class="string">"module1.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script type=<span class="string">"module"</span> <span class="keyword">async</span> src=<span class="string">"module2.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h6 id="将模块作为-Worker-加载"><a href="#将模块作为-Worker-加载" class="headerlink" title="将模块作为 Worker 加载"></a>将模块作为 Worker 加载</h6><p>为了支持模块加载， <strong>HTML</strong> 标准的开发者为 <strong>worker</strong> 构造器添加了第二个参数。此参数是一个有 <code>type</code> 属性的对象，该属性的默认值是 <code>&quot;script&quot;</code> 。你也可以将 <code>type</code> 设置为<code>&quot;module&quot;</code> 以便加载模块文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用模块方式加载 module.js</span></span><br><span class="line"><span class="keyword">let</span> worker = <span class="keyword">new</span> Worker(<span class="string">"module.js"</span>, &#123; <span class="attr">type</span>: <span class="string">"module"</span> &#125;)</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Promise与异步编程</title>
    <url>/2019/12/16/js/promise/</url>
    <content><![CDATA[<h1 id="Promise与异步编程"><a href="#Promise与异步编程" class="headerlink" title="Promise与异步编程"></a>Promise与异步编程</h1><p>JS 最强大的一方面就是它能及其轻易地处理异步编程。作为因互联网而生的语言，JS 从一开始就必须能够响应点击或按键之类的用户交互行为。Node.js 通过使用回调函数来代替事件，进一步推动了 JS 中的异步编程。</p>
<h3 id="异步编程背景"><a href="#异步编程背景" class="headerlink" title="异步编程背景"></a>异步编程背景</h3><p>JS 引擎建立在单线程事件循环的概念上。单线程（<strong>Single-threaded</strong>）意味着同一时刻只能执行一段代码，与 JAVA 或 C++ 这种允许同时执行多段不同代码的多线程语言形成了反差。</p>
<p>JS 引擎在同一时刻只能执行一段代码，所以引擎无须留意那些“可能”运行的代码。代码会被放置在作业队列（<strong>job queue</strong>）中，每当一段代码准备被执行，它就会被添加到作业队列。当 JS 引擎结束当前代码的执行后，事件循环就会执行队列中的下一个作业。事件循环（<strong>event loop</strong>）是 JS 引擎的一个内部处理线程，能监视代码的执行并管理作业队列。要记住既然是一个队列，作业就会从队列中的第一个开始，依次运行到最后一个。</p>
<h6 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h6><p>当用户点击一个按钮或按下键盘上的一个键时，一个事件（<strong>event</strong>）————例如 <code>onclick</code> ————就被触发了。该事件可能会对此交互进行响应，从而将一个新的作业添加到作业队列的尾部。这就是 JS 关于异步编程的最基本形式。事件处理程序代码直到事件发生后才会被执行，此时它会拥有合适的上下文。</p>
<h6 id="回调模式"><a href="#回调模式" class="headerlink" title="回调模式"></a>回调模式</h6><p>当 <strong>Node.js</strong> 被创建时，它通过普及回调函数编程模式提升了异步编程模型。回调函数模式类似于事件模型，因为异步代码也会在后面的一个时间点才执行。不同之处在于需要调用的函数（即回调函数）是作为参数传入的。</p>
<h3 id="Promise-基础"><a href="#Promise-基础" class="headerlink" title="Promise 基础"></a>Promise 基础</h3><p><strong>Promise</strong> 是为异步操作的结果所准备的占位符。函数可以返回一个 <strong>Promise</strong> ，而不必订阅一个事件或向函数传递一个回调参数。</p>
<h3 id="Promise-的生命周期"><a href="#Promise-的生命周期" class="headerlink" title="Promise 的生命周期"></a>Promise 的生命周期</h3><p>每个 <strong>Promise</strong> 都会经历一个短暂的生命周期，初始为 <strong>pending state</strong> ，这表示异步操作尚未结束。一个挂起的 <strong>Promise</strong> 也被认为是 <strong>unsettled</strong> 。一旦异步操作结束 <strong>Promise</strong> 就会被认为是 <strong>settled</strong> ， 并进入两种可能状态之一：</p>
<ol>
<li><strong>fulfilled</strong>：<strong>Promise</strong> 的异步操作已成功结束。</li>
<li><strong>rejected</strong>：<strong>Promise</strong> 的异步操作未成功结束，可能是一个错误，或有其他原因导致。</li>
</ol>
<p>内部的 <code>[[PromiseState]]</code> 属性会被设置为 <code>pending</code>、 <code>fulfilled</code> 或者 <code>rejected</code> ，以反映 <strong>Promise</strong> 的状态。该属性并未在 <strong>Promise</strong> 对象上被暴露出来，因此无法在编程方式判断 <strong>Promise</strong> 到底处于哪种状态。不过可以使用 <code>then()</code> 方法在 <strong>Promise</strong> 的状态改变时执行一些特定操作。</p>
<p><code>then()</code> 方法在所有的 <strong>Promise</strong> 上都存在，并且接受两个参数。第一个参数是 <strong>Promise</strong> 被完成时要调用的函数，与异步操作关联的任何附加数据都会被传入这个完成函数。第二个参数则是 <strong>Promise</strong> 被拒绝时要调用的函数，与完成函数相似，拒绝函数会被传入与拒绝相关联的任何附加数据。</p>
<p>用这种方式实现 <code>then()</code> 方法的任何对象都被称为一个 <strong>thenable</strong> 。所有的 <strong>Promise</strong> 都是 <strong>thenable</strong> ，反之则未必成立。</p>
<p><code>then()</code> 调用如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">1</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时监听 成功与失败</span></span><br><span class="line">promise.then(</span><br><span class="line">    data =&gt; &#123;</span><br><span class="line">        <span class="comment">// 完成</span></span><br><span class="line">        <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;,</span><br><span class="line">    err =&gt; &#123;</span><br><span class="line">        <span class="comment">// 拒绝</span></span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只监听成功</span></span><br><span class="line">promise.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 完成</span></span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只监听失败</span></span><br><span class="line">promise.then(<span class="literal">null</span>, err =&gt; &#123;</span><br><span class="line">    <span class="comment">// 拒绝</span></span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>Promise</strong> 也具有一个 <code>catch()</code> 方法，其行为等同于只传递拒绝处理函数给 <code>then()</code> 。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        reject(<span class="string">"error"</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只监听失败</span></span><br><span class="line">promise.then(<span class="literal">null</span>, err =&gt; &#123;</span><br><span class="line">    <span class="comment">// 拒绝</span></span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听失败</span></span><br><span class="line">promise.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 拒绝</span></span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>then()</code> 与 <code>catch()</code> 背后的意图是让你组合使用它们来正确处理异步操作的结果。</p>
<h3 id="创建未决的-Promise"><a href="#创建未决的-Promise" class="headerlink" title="创建未决的 Promise"></a>创建未决的 <strong>Promise</strong></h3><p>新的 <strong>Promise</strong> 使用 <code>Promise</code> 构造器来创建。此构造器接受单个参数：一个被称为执行器（<strong>executor</strong>）的函数，包含初始化 Promise 的代码。该执行器会被传递两个名为 <code>resolve()</code> 与 <code>reject()</code> 的函数作为参数。 <code>resolve()</code> 函数在执行器成功时调用，<code>reject()</code> 函数则表明执行器操作已失败。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promise</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            reject(err)</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            resolve(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">promise(<span class="literal">false</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"data1"</span>, data)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"err1"</span>, err)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">promise(<span class="built_in">Error</span>(<span class="number">1</span>))</span><br><span class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"data2"</span>, data)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"err2"</span>, err)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p>Promise 的执行器会立即执行，是同步的。调用 <code>resolve()</code> 触发的是一个异步操作。传递给 <code>then()</code> 与 <code>catch()</code> 的函数会异步地被执行，并且它们也被添加到了作业队列（先进队列再执行）。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h3 id="创建已决的-Promise"><a href="#创建已决的-Promise" class="headerlink" title="创建已决的 Promise"></a>创建已决的 Promise</h3><p>基于 <strong>Promise</strong> 执行器行为的动态本质， <code>Promise</code> 构造器就是创建未决的 <strong>Promise</strong> 的最好方式。但若你想让一个 <strong>Promise</strong> 代表一个已知的值，那么安排一个单纯传值给 <code>resolve()</code> 函数的作业并没有意义。相反，有两种方法可使用指定值来创建已决的 Promise。</p>
<h6 id="使用-Promise-resolve"><a href="#使用-Promise-resolve" class="headerlink" title="使用 Promise.resolve()"></a>使用 <strong>Promise.resolve()</strong></h6><p><code>Promise.resolve()</code> 方法接受单个参数并返回一个处于完成态的 <strong>Promise</strong> 。这意味着没有任何作业调度会发生，并且只需要向 <strong>Promise</strong> 添加一个或更多的完成处理函数来提取这个参数值。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)   <span class="comment">// 1</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="使用-Promise-reject"><a href="#使用-Promise-reject" class="headerlink" title="使用 Promise.reject()"></a>使用 Promise.reject()</h3><p>使用 <code>Promise.reject()</code> 方法来创建一个已拒绝的 <strong>Promise</strong> 。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="built_in">Promise</span>.reject(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">promise.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)   <span class="comment">// 1</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>若你传递一个 <code>Promise</code> 给 <code>Promise.resolve()</code> 或 <code>Promise.reject()</code> 方法，该 <code>Promise</code> 会不作修改原样返回。</p>
</blockquote>
<h3 id="执行器错误"><a href="#执行器错误" class="headerlink" title="执行器错误"></a>执行器错误</h3><p>如果在执行器内部抛出错误，那么 Promise 的拒绝处理函数就会被调用。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"error"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err) <span class="comment">// error</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在每个执行器之内并没有显式的 <code>try-catch</code> ，因此错误就被捕捉并传递给了拒绝处理函数。上述例子等价于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"error"</span>)</span><br><span class="line">    &#125;<span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        reject(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err) <span class="comment">// error</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="全局的-Promise-拒绝处理"><a href="#全局的-Promise-拒绝处理" class="headerlink" title="全局的 Promise 拒绝处理"></a>全局的 Promise 拒绝处理</h3><p><strong>Promise</strong> 最有争议的方面之一就是：当一个 <strong>Promise</strong> 被拒绝时若缺少拒绝处理函数，就会静默失败。</p>
<p>由于 <strong>Promise</strong> 的本质，判断一个 <strong>Promise</strong> 的拒绝是否已被处理并不直观。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> rejected = <span class="built_in">Promise</span>.reject(<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在此刻 rejected 不会被处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一段时间后……</span></span><br><span class="line">rejected.catch(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 现在 rejected 已经被处理了</span></span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>无论 <strong>Promise</strong> 是否已被解决，你都可以在任何时候调用 <code>then()</code> 或 <code>catch()</code> 并使它们正确工作，这导致我们很难准确知道一个 <strong>Promise</strong> 何时会被处理。</p>
<p>虽然下个版本的 ES 可能会处理此问题，不过浏览器与 Node.js 已经实施了变更来解决开发者<br>的这个痛点。/<em>这里只介绍 浏览器解决方案，Node.js会在node笔记中提到。</em>/</p>
<h3 id="浏览器的拒绝处理"><a href="#浏览器的拒绝处理" class="headerlink" title="浏览器的拒绝处理"></a>浏览器的拒绝处理</h3><p>浏览器能触发两个事件，来帮助识别未处理的拒绝。这两个事件会被 <code>window</code> 对象触发，并完全等效于 <strong>Node.js</strong> 的相关事件：</p>
<ul>
<li><code>unhandledrejection</code>：当一个 <strong>Promise</strong> 被拒绝、而在事件循环的一个轮次中没有任何拒绝处理函数被调用，该事件就会被触发。</li>
<li><code>rejectionHandled</code>：若一个 <strong>Promise</strong> 被拒绝、并在事件循环的一个轮次之后再有拒绝处理函数被调用，该事件就会被触发。</li>
</ul>
<p>浏览器事件的处理函数会接收到包含下列属性的一个对象：</p>
<ul>
<li><code>type</code>：事件的名称（ <code>&quot;unhandledrejection&quot;</code> 或 <code>&quot;rejectionhandled&quot;</code> ）；</li>
<li><code>promise</code>：被拒绝的 <strong>Promise</strong> 对象；</li>
<li><code>reason</code>：<strong>Promise</strong> 中的拒绝值（拒绝原因）。</li>
</ul>
<p>浏览器的实现中存在的另一个差异就是：拒绝值（ <code>reason</code> ）在两种事件中都可用。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> rejected = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onunhandledrejection = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.type) <span class="comment">// unhandledrejection</span></span><br><span class="line">    <span class="built_in">console</span>.log(event.reason.message) <span class="comment">// error</span></span><br><span class="line">    <span class="built_in">console</span>.log(rejected === event.promise) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onrejectionhandled = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.type) <span class="comment">// rejectionhandled</span></span><br><span class="line">    <span class="built_in">console</span>.log(event.reason.message) <span class="comment">// error</span></span><br><span class="line">    <span class="built_in">console</span>.log(rejected === event.promise) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rejected = <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"error"</span>))</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"setTimeout"</span>) <span class="comment">// setTimeout</span></span><br><span class="line">    rejected.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">&#125;, <span class="number">3000</span>)</span><br></pre></td></tr></table></figure>

<p>以下代码在浏览器中追踪未被处理的拒绝：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> possiblyUnhandledRejections = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当一个拒绝未被处理，将其添加到 Map</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onunhandledrejection = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    possiblyUnhandledRejections.set(event.promise, event.reason)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onrejectionhandled = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    possiblyUnhandledRejections.delete(event.promise, event.reason)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"循环处理"</span>)</span><br><span class="line">    possiblyUnhandledRejections.forEach(<span class="function">(<span class="params">reason, promise</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(reason.message ? reason.message : reason)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    possiblyUnhandledRejections.clear()</span><br><span class="line">&#125;, <span class="number">60000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> clear = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Promise</span>.reject(<span class="string">`index<span class="subst">$&#123;++index&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(index == <span class="number">5</span>) &#123;</span><br><span class="line">        clearInterval((clear))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<h3 id="串联-Promise"><a href="#串联-Promise" class="headerlink" title="串联 Promise"></a>串联 Promise</h3><p>每次对 <code>then()</code> 或 <code>catch()</code> 的调用实际上创建并返回了另一个 <code>Promise</code> ，仅当前一个 <code>Promise</code> 被完成或拒绝时，后一个 <code>Promise</code> 才会被决议。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="捕获错误"><a href="#捕获错误" class="headerlink" title="捕获错误"></a>捕获错误</h3><p>Promise 链允许你捕获前一个 Promise 的完成或拒绝处理函数中发生的错误。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"error1"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err) <span class="comment">// error1</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"error2"</span>)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err) <span class="comment">// error2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>链式 <code>Promise</code> 调用能察觉到链中其他 <code>Promise</code> 中的错误。</p>
<h3 id="在-Promise-链中返回值"><a href="#在-Promise-链中返回值" class="headerlink" title="在 Promise 链中返回值"></a>在 Promise 链中返回值</h3><p>Promise 链的另一个重要方面是能从一个 Promise 传递数据给下一个 Promise 的能力。我们只需要指定完成处理函数的返回值，以便沿着一个链继续传递数据。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data) <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> ++data</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data) <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> ++data</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data) <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">return</span> ++data</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data) <span class="comment">// 4</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="在-Promise-链中返回-Promise"><a href="#在-Promise-链中返回-Promise" class="headerlink" title="在 Promise 链中返回 Promise"></a>在 Promise 链中返回 Promise</h3><p>从完成或拒绝处理函数中返回一个基本类型值，能够在 Promise 之间传递数据，但如果我们返回的是一个 Promise 呢？那么需要采取一个额外步骤来决定如何处理。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">40</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data) <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> promise2</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data) <span class="comment">// 40</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上述的例子意味着，第二个完成处理函数会等到第一个完成处理函数返回的 <code>promise2</code> 执行完毕才会调用，第二个处理函数取到的值实际上是 <code>promise2</code> 完成后 <code>resolve</code> 的值。不过如果 <code>promise2</code> 是被拒绝了，情况会稍微有一点不同。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="number">40</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data) <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> promise2</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 不会被执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>由于 <code>promise2</code> 被拒绝了，第二个完成处理函数就永不被调用。不过你可以改为对其附加一个拒绝处理函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="number">40</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data) <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> promise2</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 不会被执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err) <span class="comment">// 40</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="响应多个-Promise"><a href="#响应多个-Promise" class="headerlink" title="响应多个 Promise"></a>响应多个 Promise</h3><p><strong>ES6</strong> 提供了能监视多个 <code>Promise</code> 的两个方法：<code>Promise.all()</code> 与 <code>Promise.race()</code> 。</p>
<h6 id="Promise-all-方法"><a href="#Promise-all-方法" class="headerlink" title="Promise.all() 方法"></a>Promise.all() 方法</h6><p><code>Promise.all()</code> 方法接收单个可迭代对象（如数组）作为参数，并返回一个 Promise。这个可迭代对象的元素都是 <code>Promise</code> ，只有在它们都完成后，所返回的 <strong>Promise</strong> 才会被完成。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    resolve(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">        resolve(<span class="number">2</span>)</span><br><span class="line">    &#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">    resolve(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise4 = <span class="built_in">Promise</span>.all([ promise1, promise2, promise3 ])</span><br><span class="line"></span><br><span class="line">promise4.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"----------------------"</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(data) <span class="comment">// 三秒后打印：[ 1, 2, 3 ]</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>但是如果传递给 <code>Promise.all()</code> 的任意 <strong>Promise</strong> 被拒绝了，那么方法所返回的 <strong>Promise</strong> 就会立刻被拒绝，而不必等待其他的 <strong>Promise</strong> 结束。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    resolve(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">        resolve(<span class="number">2</span>)</span><br><span class="line">    &#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">    reject(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise4 = <span class="built_in">Promise</span>.all([ promise1, promise2, promise3 ])</span><br><span class="line"></span><br><span class="line">promise4.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"----------------------"</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(err) <span class="comment">// 3</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>!&gt; 虽然 <code>promise4</code> 的拒绝函数立刻被调用了，但是 <code>promise2</code> 实际上还是会继续执行的。</p>
<h6 id="Promise-race-方法"><a href="#Promise-race-方法" class="headerlink" title="Promise.race() 方法"></a>Promise.race() 方法</h6><p>与等待所有 <strong>Promise</strong> 完成的 <code>Promise.all()</code> 方法不同，在来源 <strong>Promise</strong> 中任意一个被完成时， <code>Promise.race()</code> 方法所返回的 <strong>Promise</strong> 会立刻做出响应。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    resolve(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">        resolve(<span class="number">2</span>)</span><br><span class="line">    &#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">    resolve(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise4 = <span class="built_in">Promise</span>.race([ promise1, promise2, promise3 ])</span><br><span class="line"></span><br><span class="line">promise4.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"----------------------"</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(data) <span class="comment">// 1</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>简单来说传递给 <code>Promise.race()</code> 的 <strong>Promise</strong> 其实就像在赛跑一样，看哪个首先到重点。如果最先到达重点的 <code>Promise</code> 是被完成状态，则返回的新 <strong>Promise</strong> 也会被完成；如果是被拒绝的，则返回的也是被拒绝的。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">        resolve(<span class="number">1</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">        resolve(<span class="number">2</span>)</span><br><span class="line">    &#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">    reject(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise4 = <span class="built_in">Promise</span>.race([ promise1, promise2, promise3 ])</span><br><span class="line"></span><br><span class="line">promise4.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"----------------------"</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(err) <span class="comment">// 3</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="继承-Promise"><a href="#继承-Promise" class="headerlink" title="继承 Promise"></a>继承 Promise</h3><p>像其他内置类型一样，我们也可以将 <strong>Promise</strong> 作为一个派生类的基类。进行自定义的 <strong>Promise</strong> ，在内置的 <strong>Promise</strong> 的基础上扩展功能。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> <span class="keyword">extends</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用默认构造器</span></span><br><span class="line">    success(resolve, reject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(resolve, reject)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    failure(reject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.catch(reject)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise1.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data) <span class="comment">// 1</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise2 = MyPromise.resolve(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">promise2.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data) <span class="comment">// 2</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise3 = MyPromise.resolve(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">promise3.success(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data) <span class="comment">// 3</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="异步任务运行"><a href="#异步任务运行" class="headerlink" title="异步任务运行"></a>异步任务运行</h3><p>前面使用了生成器，实现了一个异步任务运行器，现在我们使用 <strong>Promise</strong> 改造一下。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">taskDef</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> task = taskDef()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = task.next()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!result.done) &#123;</span><br><span class="line">            <span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve(result.value)</span><br><span class="line"></span><br><span class="line">            promise.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(data)</span><br><span class="line">                result = task.next(data)</span><br><span class="line">                step()</span><br><span class="line">            &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(err)</span><br><span class="line">                result = task.throw(err)</span><br><span class="line">                step()</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    step()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iterator = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> content = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    content = <span class="keyword">yield</span> content + <span class="number">1</span></span><br><span class="line">    content = <span class="keyword">yield</span> <span class="keyword">new</span> <span class="built_in">Error</span>(content + <span class="number">1</span>)</span><br><span class="line">    content = <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(iterator)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// Error: 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>代理与反射接口</title>
    <url>/2019/12/16/js/proxy/</url>
    <content><![CDATA[<h1 id="代理与反射接口"><a href="#代理与反射接口" class="headerlink" title="代理与反射接口"></a>代理与反射接口</h1><!-- **ES5** 与 **ES6** 都推进了 **JS** 功能的公开。例如，**JS** 运行环境包含一些不可枚举、不可写入的对象属性，然而在 **ES5** 之前我们无法定义它们自己的不可枚举属性或者不可写入属性。 -->
<p><strong>ES6</strong> 为了让开发者能进一步接近 <strong>JS</strong> 引擎的能力，这些能力原先只存在于内置对象上。JS通过代理（<strong>proxy</strong>）暴露了在对象上的内部工作，代理是一种封装，能够拦截并改变 <strong>JS</strong> 引擎的底层操作。</p>
<!-- ### 数组的问题
在 **ES6** 之前， **JS** 的数组对象拥有特定的行为方式，无法被开发者在自定义对象中进行模拟。当 -->

<h3 id="代理与反射是什么？"><a href="#代理与反射是什么？" class="headerlink" title="代理与反射是什么？"></a>代理与反射是什么？</h3><p>通过调用 <code>new proxy()</code> ，我们可以创建一个代理用来代替另一个对象（被称为代理目标），这个代理对目标对象进行了虚拟，因此该代理与该目标对象表面上可以被当作同一个对象来对待。</p>
<p>代理允许你拦截在目标对象上的底层操作，而这原本是 <strong>JS</strong> 引擎的内部能力。拦截行为使用了一个能够响应特定操作的函数（被称为陷阱）。</p>
<p>被 <code>Reflect</code> 对象所代表的反射接口，是给底层操作提供默认行为的方法的集合，这些操作是能够被代理重写的。每个代理陷阱都有一个对应的反射方法，每个方法都与对应的陷阱函数同名，并且接收的参数也与之一致。并且接收的参数也与之一致。下表总结了这些行为：</p>
<blockquote>
<p><img src="/img.png" alt="Reflect"> </p>
</blockquote>
<h3 id="创建一个简单的代理"><a href="#创建一个简单的代理" class="headerlink" title="创建一个简单的代理"></a>创建一个简单的代理</h3><p>当使用 <code>Proxy</code> 构造器来创建一个代理时，需要传递两个参数：目标对象以及一个处理器（<strong>handler</strong>），后者是定义了一个或多个陷阱函数的对象。如果未提供陷阱函数，代理会对所有操作采取默认行为。</p>
<p>为了创建一个仅进行传递的代理，你需要使用不包含任何陷阱函数的处理器：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;&#125;)</span><br><span class="line"></span><br><span class="line">proxy.name = <span class="string">"proxy"</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name)  <span class="comment">// proxy</span></span><br><span class="line"><span class="built_in">console</span>.log(target.name) <span class="comment">// proxy</span></span><br><span class="line"></span><br><span class="line">proxy.name = <span class="string">"target"</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name)  <span class="comment">// target</span></span><br><span class="line"><span class="built_in">console</span>.log(target.name) <span class="comment">// target</span></span><br></pre></td></tr></table></figure>

<p>该例中的 <code>proxy</code> 代理对象进行的所有操作最终都会传递给 <code>target</code> 目标对象。因此当我们为 <code>proxy</code> 代理对象添加 <code>name</code> 属性时，<code>target</code> 目标对象也会进行相应的变化。当然，缺少陷阱函数的代理没有什么用处，但是如果我们为它定义一个陷阱函数呢？</p>
<h3 id="使用-set-陷阱函数验证属性值"><a href="#使用-set-陷阱函数验证属性值" class="headerlink" title="使用 set 陷阱函数验证属性值"></a>使用 set 陷阱函数验证属性值</h3><p>假如我们想要创建一个对象，并且规定该对象的属性值必须是数值，这就意味着我们每次新增属性的时候都要进行验证，并且在属性值不为数值类型的时候抛出错误。</p>
<p>我们可以使用 <code>set</code> 陷阱函数来重写设置属性值时的默认行为，该陷阱函数能接受四个参数：</p>
<ol>
<li><code>trapTarget</code>：将接收属性的对象（即代理的目标对象）；</li>
<li><code>key</code>：需要写入的属性的键（字符串类型或符号类型）；</li>
<li><code>value</code>：将被写入属性的值；</li>
<li><code>receiver</code>：操作发生的对象（通常是代理对象）；</li>
</ol>
<p><code>Reflect.set()</code> 是 <code>set</code> 陷阱函数对应的反射方法，同时也是 <code>set</code> 操作的默认行为。<br><code>Reflect.set()</code> 方法与 <code>set</code> 陷阱函数一样，能接受这四个参数，让该方法能在陷阱函数内部被方便使用。。该陷阱函数需要在属性被设置完成的情况下返回 <code>true</code> ，否则就要返回 <code>false</code>，而 <code>Reflect.set()</code> 也会基于操作是否成功而返回相应的结果。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">    name: <span class="string">"target"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="keyword">set</span>(trapTarget, key, value, receiver) &#123;</span><br><span class="line">        <span class="comment">// 忽略已有属性，避免影响它们</span></span><br><span class="line">        <span class="keyword">if</span>(!trapTarget.hasOwnProperty(key)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isNaN</span>(value)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Property must be a number."</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加属性</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(trapTarget, key, value, receiver)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个新属性，且添加的属性值为 number 类型</span></span><br><span class="line">proxy.count = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.count)  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(target.count) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为已存在属性 name 赋值一个非数值类型的值</span></span><br><span class="line">proxy.name = <span class="string">"name"</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name)  <span class="comment">// name</span></span><br><span class="line"><span class="built_in">console</span>.log(target.name) <span class="comment">// name</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出错误</span></span><br><span class="line">proxy.num = <span class="string">"num"</span></span><br></pre></td></tr></table></figure>

<p>这段代码定义了一个代理陷阱，用于对 <code>target</code> 对象新增属性的值进行验证。此代码只验证新增属性的值，当我们为新增值添加一个非 <code>Number</code> 类型的值时，会抛出错误。</p>
<p>使用 <code>set</code> 代理陷阱允许我们在写入属性值的时候进行拦截，而 <code>get</code> 代理陷阱则允许我们在读取属性值的时候进行拦截。</p>
<h3 id="使用-get-陷阱函数进行对象外形验证"><a href="#使用-get-陷阱函数进行对象外形验证" class="headerlink" title="使用 get 陷阱函数进行对象外形验证"></a>使用 get 陷阱函数进行对象外形验证</h3><p><strong>JS</strong> 语言有趣但有时却令人困惑的特性之一，就是读取对象不存在的属性时并不会抛出错误，而是会把 <code>undefined</code> 当作该属性的值。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>对象外形（<strong>Object Shape</strong>）指的是对象已有的属性与方法的集合。使用 <code>get</code> 陷阱函数，该陷阱函数会在读取属性时被调用，即使该属性在对象中并不存在，它能接受三个参数：</p>
<ol>
<li><code>trapTarget</code>：将接收属性的对象（即代理的目标对象）；</li>
<li><code>key</code>：需要读取的属性的键（字符串类型或符号类型）；</li>
<li><code>receiver</code>：操作发生的对象（通常是代理对象）；</li>
</ol>
<p><code>Reflect.get()</code> 方法同样接收这三个参数，并且默认会返回属性的值。</p>
<p>我们可以通过 <code>get</code> 陷阱函数与 <code>Reflect.get()</code> 方法在目标属性不存在时抛出错误。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">    name: <span class="string">"target"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="keyword">get</span>(tarpTarget, key, receiver) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(key <span class="keyword">in</span> receiver)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Property "</span> + key + <span class="string">" doesn't exist."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(tarpTarget, key, receiver)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name) <span class="comment">// target</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// nme 属性不存在抛出错误</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.nme)</span><br></pre></td></tr></table></figure>

<p>在此处的例子中我们使用了 <code>in</code> 来判断 <code>receiver</code> 是否存在对应的属性，之所以使用 <code>receiver</code> 并没有使用 <code>tarpTarget</code>，而是用了 <code>in</code> ，这是因为 <code>receiver</code> 本身就是拥有一个 <code>has</code> 陷阱函数的代理对象，在此处使用 <code>trapTarget</code> 会跳过 <code>has</code> 陷阱函数数，并可能给你一个错误的结果。</p>
<h3 id="使用-has-陷阱函数隐藏属性"><a href="#使用-has-陷阱函数隐藏属性" class="headerlink" title="使用 has 陷阱函数隐藏属性"></a>使用 has 陷阱函数隐藏属性</h3><p><code>in</code> 运算符用于判定指定对象中是否存在某个属性，如果对象的属性名与指定的字符串或符号值想匹配，那么 <code>in</code> 运算符应当返回 <code>true</code>，无论该属性是对象自身的属性还是其原型的属性。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    name: <span class="string">"zzzhim"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">Object</span>.create(obj1)</span><br><span class="line"></span><br><span class="line">obj2.sex = <span class="string">"男"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> obj2) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"sex"</span> <span class="keyword">in</span> obj2)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>has</code> 陷阱函数会在使用 <code>in</code> 运算符的情况下被调用，并且会被传入两个参数：</p>
<ol>
<li><code>trapTarget</code>：需要读取属性的对象（即代理的目标对象）；</li>
<li><code>key</code>：需要检查的属性的键（字符串类型或者符号类型）；</li>
</ol>
<p><code>Reflect.has()</code> 方法接受与之相同的参数，并向 <code>in</code> 运算符返回默认的响应结果。使用 <code>has</code> 陷阱函数以及 <code>Reflect.has()</code> 方法，允许你修改部分属性在接受 <code>in</code> 检测时的行为，但保留其他属性的默认行为。</p>
<p>如下，我们想要隐藏某个属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">    name: <span class="string">"target"</span>,</span><br><span class="line">    value: <span class="number">23</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    has(trapTarget, key) &#123;</span><br><span class="line">        <span class="keyword">if</span>(key === <span class="string">"value"</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.has(trapTarget, key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"value"</span> <span class="keyword">in</span> proxy)    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> proxy)     <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"toString"</span> <span class="keyword">in</span> proxy) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"valueOf"</span> <span class="keyword">in</span> proxy)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>我们使用 <code>has</code> 陷阱函数检测 <code>key</code> 的值是否为 <code>&quot;value&quot;</code>。如果是，则返回 <code>false</code>，否则返回默认结果。</p>
<h3 id="使用-deleteProperty-陷阱函数避免属性被删除"><a href="#使用-deleteProperty-陷阱函数避免属性被删除" class="headerlink" title="使用 deleteProperty 陷阱函数避免属性被删除"></a>使用 deleteProperty 陷阱函数避免属性被删除</h3><p><code>delete</code> 运算符能够从指定对象上删除一个属性，在删除成功时返回 <code>true</code> ，否则返回 <code>false</code>。如果试图用 <code>delete</code> 运算符去删除一个不可配置的属性，在严格模式下将会抛出错误；非严格模式下只是单纯返回 <code>false</code>。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">    name: <span class="string">"target"</span>,</span><br><span class="line">    value: <span class="number">23</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(target, <span class="string">"name"</span>, &#123;</span><br><span class="line">    configurable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"value"</span> <span class="keyword">in</span> target) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = <span class="keyword">delete</span> target.value;</span><br><span class="line"><span class="built_in">console</span>.log(result1) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"value"</span> <span class="keyword">in</span> target) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 严格模式下抛错</span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="keyword">delete</span> target.name</span><br><span class="line"><span class="built_in">console</span>.log(result2) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> target) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>deleteProperty</code> 陷阱函数会在使用 <code>delete</code> 运算符去删除对象属性时下被调用，并且会被传入两个参数：</p>
<ol>
<li><code>tarpTarget</code>：需要删除属性的对象（即代理的目标对象）；</li>
<li><code>key</code>：需要删除的属性的键（字符串类型或者符号类型）；</li>
</ol>
<p><code>Reflect.deleteProperty()</code> 方法也接受这两个参数，并提供了 <code>deleteProperty</code> 陷阱函数的默认实现。我们可以结合 <code>Reflect.deleteProperty()</code> 方法以及 <code>deleteProperty</code> 陷阱函数，来修改 <code>delete</code> 运算符的行为。</p>
<p>如下，我们使用它们确保 <code>value</code> 属性不能被删除：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">    name: <span class="string">"target"</span>,</span><br><span class="line">    value: <span class="number">23</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    deleteProperty(trapTarget, key) &#123;</span><br><span class="line">        <span class="keyword">if</span>(key === <span class="string">"value"</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.deleteProperty(trapTarget, key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试删除 value 属性</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"value"</span> <span class="keyword">in</span> proxy)   <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> result1 = <span class="keyword">delete</span> proxy.value</span><br><span class="line"><span class="built_in">console</span>.log(result1)            <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"value"</span> <span class="keyword">in</span> proxy)   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试删除 proxy.name</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> proxy)    <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="keyword">delete</span> proxy.name</span><br><span class="line"><span class="built_in">console</span>.log(result2)            <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> proxy)    <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>这段代码允许我们在严格模式下保护属性避免其被删除，并且不会抛出错误。</p>
<h3 id="原型代理的陷阱函数"><a href="#原型代理的陷阱函数" class="headerlink" title="原型代理的陷阱函数"></a>原型代理的陷阱函数</h3><p>代理允许通过 <code>setPrototypeOf</code> 与 <code>getPrototypeOf</code> 陷阱函数来对这两个方法的操作进行拦截。<code>Object</code> 对象上的这两个方法都会调用代理中对应名称的陷阱函数，从而允许你改变这两个方法的行为。</p>
<p>由于存在着两个陷阱函数与原型代理相关联，因此分别有一组方法对应着每个陷阱函数。</p>
<p><code>setPrototypeOf</code> 陷阱函数接受两个参数：</p>
<ol>
<li><code>tarpTarget</code>：需要设置原型的对象（即代理的目标对象）；</li>
<li><code>proto</code>：被用作原型的对象；</li>
</ol>
<p><code>Object.setPrototypeOf()</code> 方法与 <code>Reflect.setPrototypeOf()</code> 方法会被传入相同的参数。另一方面， <code>getPrototypeOf</code> 陷阱函数只接受 <code>trapTarget</code> 参数， <code>Object.getPrototypeOf()</code> 方法与 <code>Reflect.getPrototypeOf()</code> 方法也是如此。</p>
<blockquote>
<p>原文的例子如下：<br>下面这个例子通过返回 <code>null</code> 隐藏了代理对象的原型，并且使得该原型不可被修改：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    getPrototypeOf(trapTarget) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    setPrototypeOf(trapTarget, proto) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> targetProto = <span class="built_in">Object</span>.getPrototypeOf(target);</span><br><span class="line"><span class="keyword">let</span> proxyProto = <span class="built_in">Object</span>.getPrototypeOf(proxy);</span><br><span class="line"><span class="built_in">console</span>.log(targetProto === <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(proxyProto === <span class="built_in">Object</span>.prototype); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(proxyProto); <span class="comment">// null</span></span><br><span class="line"><span class="comment">// 成功</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(target, &#123;&#125;);</span><br><span class="line"><span class="comment">// 抛出错误</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(proxy, &#123;&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当我试图在控制台执行原文的例子时，Chrome浏览器会抛出 <code>&#39;getPrototypeOf&#39; on proxy: trap returned neither object nor null</code> ，原因是因为在 <code>getPrototypeOf</code> 返回了一个 <code>null</code>，具体为什么会抛出错误，我也没有找到原因。因此我在上述例子中稍微做了一些修改：</p>
</blockquote>
<p>下面的例子通过返回原型为 <code>null</code> 的空对象，隐藏了代理对象的原型，并且使得该原型不可被修改：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    getPrototypeOf(trapTarget) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    setPrototypeOf(trapTarget, proto) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxyProto = <span class="built_in">Object</span>.getPrototypeOf(proxy)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxyProto) <span class="comment">// 原型为 `null` 的空对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出错误</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(proxy, &#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>如果我们想在两个陷阱函数中使用默认的行为，那么只需调用 <code>Reflect</code> 对象上的相应方法。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    getPrototypeOf(trapTarget) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.getPrototypeOf(trapTarget)</span><br><span class="line">    &#125;,</span><br><span class="line">    setPrototypeOf(trapTarget, proto) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.setPrototypeOf(trapTarget, proto)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> targetProto = <span class="built_in">Object</span>.getPrototypeOf(target)</span><br><span class="line"><span class="keyword">let</span> proxyProto =  <span class="built_in">Object</span>.getPrototypeOf(proxy)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(targetProto === <span class="built_in">Object</span>.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(proxyProto === <span class="built_in">Object</span>.prototype)  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(target, &#123;&#125;)</span><br><span class="line"><span class="comment">// 同样成功</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(proxy, &#123;&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="两组方法的不同之处"><a href="#两组方法的不同之处" class="headerlink" title="两组方法的不同之处"></a>两组方法的不同之处</h3><p><code>Reflect.getPrototypeOf()</code> 和 <code>Reflect.setPrototypeOf</code> 虽然看起来与 <code>Object.getPrototypeOf()</code> 和 <code>Object.setPrototypeOf</code> 很相似，但它们两个之间仍然有着显著差异。</p>
<p>首先 <code>Object.getPrototypeOf()</code> 和 <code>Object.setPrototypeOf</code> 属于高级操作，从产生之初便已提供给开发者使用；而 <code>Reflect.getPrototypeOf()</code> 和 <code>Reflect.setPrototypeOf</code> 属于底层操作，允许开发者访问 <code>[[GetPrototypeOf]]</code> 与 <code>[[SetPrototypeOf]]</code> 这两个原先仅供语言内部使用的操作。</p>
<p><code>Reflect.getPrototypeOf()</code> 方法是对内部的 <code>[[GetPrototypeOf]]</code> 操作的封装（并且附加了一些输入验证），而 <code>Reflect.setPrototypeOf()</code> 方法与 <code>[[SetPrototypeOf]]</code> 操作之间也有类似的关系。</p>
<p>虽然 <code>Object</code> 对象上的同名方法也调用了 <code>[[GetPrototypeOf]]</code> 与 <code>[[SetPrototypeOf]]</code> ，但它们在调用这两个操作之前添加了一些步骤、并检查返回值，以决定如何行动。</p>
<p><code>Reflect.getPrototypeOf()</code> 方法在接收到的参数不是一个对象时会抛出错误，而 <code>Object.getPrototypeOf()</code> 则会在操作之前先将参数值转换为一个对象。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> result = <span class="built_in">Object</span>.getPrototypeOf(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result === <span class="built_in">Number</span>.prototype) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛错</span></span><br><span class="line"><span class="built_in">Reflect</span>.getPrototypeOf(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><code>Reflect.setPrototypeOf()</code> 方法方法返回一个布尔值用于表示操作是否已成功，成功时返回 <code>true</code> ，失败时返回 <code>false</code>； <code>Object.setPrototypeOf()</code> 方法的操作失败时，它会抛出错误。<code>Object.setPrototypeOf()</code> 方法会将传入的第一个参数作为自身的返回值，因此并不适合用来实现 <code>setPrototypeOf</code> 代理陷阱的默认行为。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target1 = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> result1 = <span class="built_in">Object</span>.setPrototypeOf(target1, &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result1 === target1) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> target2 = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> result2 = <span class="built_in">Reflect</span>.setPrototypeOf(target2, &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result2 === target2) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(result2) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="对象可扩展性的陷阱函数"><a href="#对象可扩展性的陷阱函数" class="headerlink" title="对象可扩展性的陷阱函数"></a>对象可扩展性的陷阱函数</h3><p>ES5 通过 <code>Object.preventExtensions()</code> 与 <code>Object.isExtensible()</code> 方法给对象增加了可扩展<br>性。</p>
<p>ES6 通过 <code>preventExtensions</code> 与 <code>isExtensible</code> 陷阱函数允许代理拦截对于底层对象的方法调用。这两个陷阱函数都接受名为 <code>trapTarget</code> 的单个参数，此参数代表方法在哪个对象上被调用。同时 <code>Reflect</code> 上面也存在对应的  <code>Reflect.preventExtensions()</code> 与 <code>Reflect.isExtensible()</code> 方法，用于实现默认的行为。这两个方法都返回布尔值，因此它们可以在对应的陷阱函数内直接使用。</p>
<blockquote>
<p><code>Object.isExtensible()</code> 方法判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）。</p>
<p><code>Object.preventExtensions()</code> 方法让一个对象变的不可扩展，也就是永远不能再添加新的属性。</p>
</blockquote>
<h6 id="两个基本范例"><a href="#两个基本范例" class="headerlink" title="两个基本范例"></a>两个基本范例</h6><p>下列代码实现了 <code>isExtensible</code> 与 <code>preventExtensions</code> 陷阱函数的默认行为。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    isExtensible(trapTarget) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.isExtensible(trapTarget)</span><br><span class="line">    &#125;,</span><br><span class="line">    preventExtensions(trapTarget) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.preventExtensions(trapTarget)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(target)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(proxy)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常运行</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(target, <span class="string">"name"</span>, &#123; <span class="attr">value</span>: <span class="string">"zzzhim"</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让对象变得不可扩展</span></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(proxy)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(target)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(proxy)) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出错误：Cannot define property value, object is not extensible</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(target, <span class="string">"value"</span>, &#123; <span class="attr">value</span>: <span class="number">111</span> &#125;)</span><br></pre></td></tr></table></figure>

<p>我们也可以在 <code>preventExtensions</code> 陷阱函数上返回 <code>false</code>，来让代理上的 <code>Object.preventExtensions()</code> 操作失败。如下：</p>
<blockquote>
<p>原文代码如下：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    isExtensible(trapTarget) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.isExtensible(trapTarget)</span><br><span class="line">    &#125;,</span><br><span class="line">    preventExtensions(trapTarget) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(target)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(proxy)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(proxy)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(target)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(proxy)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>此代码在 <code>Chrome</code> 和 <code>FireFox</code> 执行时分别会抛出 <code>&#39;preventExtensions&#39; on proxy: trap returned falsish at Function.preventExtensions</code> 和 <code>proxy preventExtensions handler returned false</code> 错误。</p>
</blockquote>
<p>!&gt; <code>Object.isExtensible()</code> 方法与 <code>Reflect.isExtensible()</code> 方法几乎一样，只在接收到的参数不是一个对象时才有例外。此时 <code>Object.isExtensible()</code> 总是会返回 <code>false</code> ，而 <code>Reflect.isExtensible()</code> 则会抛出一个错误。</p>
<h3 id="属性描述符的陷阱函数"><a href="#属性描述符的陷阱函数" class="headerlink" title="属性描述符的陷阱函数"></a>属性描述符的陷阱函数</h3><p>ES5 的最重要的特征之一就是引入了 <code>Object.defineProperty()</code> 方法用于定义属性的特征，它能让我们直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并且能让属性变成只读或是不可枚举的。我们还可以利用 <code>Object.getOwnPropertyDescriptor()</code> 方法检索这些特性。</p>
<p>代理允许我们使用 <code>defineProperty</code> 与 <code>getOwnPropertyDescriptor</code> 陷阱函数，来分别拦截对于 <code>Object.defineProperty()</code> 与 <code>Object.getOwnPropertyDescriptor()</code>。</p>
<p><code>defineProperty</code> 陷阱函数接受下列三个参数：</p>
<ol>
<li><code>trapTarget</code> ：需要被定义属性的对象（即代理的目标对象）；</li>
<li><code>key</code> ：属性的键（字符串类型或符号类型）；</li>
<li><code>descriptor</code> ：为该属性准备的描述符对象。</li>
</ol>
<p><code>defineProperty</code> 陷阱函数要求你在操作成功时返回 <code>true</code> ，否则返回 <code>false</code> 。 <code>getOwnPropertyDescriptor</code> 陷阱函数则只接受 <code>trapTarget</code> 与 <code>key</code> 这两个参数，并会返回对应的描述符。 <code>Reflect.defineProperty()</code> 与 <code>Reflect.getOwnPropertyDescriptor()</code> 方法作为上述陷阱函数的对应方法，接受与之相同的参数。</p>
<p>此代码实现了每个陷阱函数的默认行为，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    defineProperty(trapTarget, key, descriptor) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.defineProperty(trapTarget, key, descriptor)</span><br><span class="line">    &#125;,</span><br><span class="line">    getOwnPropertyDescriptor(trapTarget, key) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.getOwnPropertyDescriptor(trapTarget, key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(proxy, <span class="string">"name"</span>, &#123;</span><br><span class="line">    value: <span class="string">"zzzhim"</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name) <span class="comment">// "zzzhim"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="string">"name"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(descriptor.value) <span class="comment">// "zzzhim"</span></span><br></pre></td></tr></table></figure>

<h3 id="阻止-Object-defineProperty"><a href="#阻止-Object-defineProperty" class="headerlink" title="阻止 Object.defineProperty()"></a>阻止 Object.defineProperty()</h3><p><code>defineProperty</code> 陷阱函数要求你返回一个布尔值用于表示操作是否已成功。当它返回 <code>true</code> 时， <code>Object.defineProperty()</code> 会正常执行；如果它返回 <code>false</code> ，则会抛出错误。我们可以利用这个特性，来限制可以被 <code>Object.defineProperty()</code> 的属性。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    defineProperty(trapTarget, key, descriptor) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> key === <span class="string">"symbol"</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.defineProperty(trapTarget, key, descriptor)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> symbol = <span class="built_in">Symbol</span>(<span class="string">"name"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出错误</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(proxy, symbol, &#123;</span><br><span class="line">    value: <span class="string">"zzzhim"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当 <code>key</code> 值为 <code>Symbol</code> 类型时，我们在 <code>defineProperty</code> 陷阱函数中返回 <code>false</code>，导致程序抛出错误。</p>
<blockquote>
<p>你可以让陷阱函数返回 <code>true</code> ，同时不去调用 <code>Reflect.defineProperty()</code> 方法，这样 <code>Object.defineProperty()</code> 就会静默失败，如此便可在未实际去定义属性的情况下抑制运行错误。</p>
</blockquote>
<h3 id="描述符对象的限制"><a href="#描述符对象的限制" class="headerlink" title="描述符对象的限制"></a>描述符对象的限制</h3><p>为了确保 <code>Object.defineProperty()</code> 与 <code>Object.getOwnPropertyDescriptor()</code> 方法的行为一致，传递给 <code>defineProperty</code> 陷阱函数的描述符对象必须是正规的。出于同一原因， <code>getOwnPropertyDescriptor</code> 陷阱函数返回的对象也始终需要被验证。</p>
<p>任意对象都能作为 <code>Object,defineProperty()</code> 方法的第三个参数；然而能够传递给 <code>defineProperty</code> 陷阱函数的描述对象参数，则只有 <code>enumerable</code>、 <code>configurable</code> 、 <code>value</code> 、 <code>writable</code> 、 <code>get</code> 与 <code>set</code> 这些属性。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    defineProperty(trapTarget, key, descriptor) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(descriptor) <span class="comment">// 描述对象输出 &#123;&#123; value: value &#125;&#125; 并没有 name 属性</span></span><br><span class="line">        <span class="keyword">return</span>  <span class="built_in">Reflect</span>.defineProperty(trapTarget, key, descriptor)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(proxy, <span class="string">"name"</span>, &#123;</span><br><span class="line">    value: <span class="string">"value"</span>,</span><br><span class="line">    name: <span class="string">"zzzhim"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>getOwnPropertyDescriptor</code> 陷阱函数有一个微小差异，要求返回值必须是 <code>null</code> 、 <code>undefined</code> ，或者是一个对象。当返回值是一个对象时，只允许该对象拥有 <code>enumerable</code>、 <code>configurable</code> 、 <code>value</code> 、 <code>writable</code> 、 <code>get</code> 与 <code>set</code> 这些属性。如果返回的对象包含了不被许可的自有属性，则程序会抛出错误。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    getOwnPropertyDescriptor(trapTarget, key) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            name: <span class="string">"zzzhim"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛错</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="string">"name"</span>)</span><br></pre></td></tr></table></figure>

<p>?&gt; <code>Object.getOwnPropertyDescriptor()</code> 的返回值总是拥有可信任的结构，无论是否使用了代理。</p>
<h3 id="重复的描述符方法"><a href="#重复的描述符方法" class="headerlink" title="重复的描述符方法"></a>重复的描述符方法</h3><h6 id="defineProperty-方法"><a href="#defineProperty-方法" class="headerlink" title="defineProperty() 方法"></a>defineProperty() 方法</h6><p><code>Object.defineProperty()</code> 方法与 <code>Reflect.defineProperty()</code> 方法几乎一模一样，只是返回值有区别。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> result1 = <span class="built_in">Object</span>.defineProperty(target, <span class="string">"name"</span>, &#123; <span class="attr">value</span>: <span class="string">"target"</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(target === result1) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="built_in">Reflect</span>.defineProperty(target, <span class="string">"name"</span>, &#123; <span class="attr">value</span>: <span class="string">"target"</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result2) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>?&gt; 如上，前者返回的是调用它时的第一个参数，而后者在操作成功时返回 <code>true</code> 、失败时返回 <code>false</code>。</p>
<h6 id="getOwnPropertyDescriptor-方法"><a href="#getOwnPropertyDescriptor-方法" class="headerlink" title="getOwnPropertyDescriptor() 方法"></a>getOwnPropertyDescriptor() 方法</h6><p><code>Object.getOwnPropertyDescriptor()</code> 方法会在接收的第一个参数是基本类型值时，将该参数转化为对象。而 <code>Reflect.getOwnPropertyDescriptor()</code> 方法则会在第一个参数是基本类型值的时候抛出错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> descriptor1 = <span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="number">2</span>, <span class="string">"name"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(descriptor1) <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 抛出错误</span></span><br><span class="line"><span class="keyword">let</span> descriptor2 = <span class="built_in">Reflect</span>.getOwnPropertyDescriptor(<span class="number">2</span>, <span class="string">"name"</span>)</span><br></pre></td></tr></table></figure>

<h3 id="ownKeys-陷阱函数"><a href="#ownKeys-陷阱函数" class="headerlink" title="ownKeys 陷阱函数"></a>ownKeys 陷阱函数</h3><p><code>ownKeys</code> 代理陷阱拦截了内部方法 <code>[[OwnPropertyKeys]]</code> ，并允许你返回一个数组用于重写该行为。返回的这个数组会被用于四个方法：</p>
<ol>
<li><code>Object.keys()</code> 方法；</li>
<li><code>Object.getOwnPropertyNames()</code> 方法；</li>
<li><code>Object.getOwnPropertySymbols()</code> 方法；</li>
<li><code>Object.assign()</code> 方法；</li>
</ol>
<p>?&gt; 其中 <code>Object.assign()</code> 方法会使用该数组来决定哪些属性会被复制。</p>
<p><code>ownKeys</code> 陷阱函数的默认行为由 <code>Reflect.ownKeys()</code> 方法实现，会返回一个由全部自有属性的键构成的数组，无论键的类型是字符串还是符号。</p>
<p><code>Object.getOwnPropertyNames()</code> 方法与 <code>Object.keys()</code> 方法会将符号值从该数组中过滤出去；</p>
<p><code>Object.getOwnPropertySymbols()</code> 会将字符串值过滤掉；</p>
<p><code>Object.assign()</code> 方法会使用数组中所有的字符串值与符号值；</p>
<p><code>ownKeys</code> 陷阱函数接受单个参数，即目标对象，同时必须返回一个数组或者一个类数组对象，不合要求的返回值会导致错误。我们可以使用 <code>ownKeys</code> 陷阱函数去过滤特定的属性，以避免这些属性被 <code>Object.keys()</code> 方法，<code>Object.getOwnPropertyNames()</code> 、<code>Object.getOwnPropertySymbols()</code> 、<code>Object.assign()</code>方法使用。</p>
<p>如下，我们过滤掉名为 <code>name</code> 的属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    ownKeys(trapTarget) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.ownKeys(trapTarget).filter(<span class="function"><span class="params">key</span> =&gt;</span> key !== <span class="string">"name"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">proxy.name = <span class="string">"zzzhim"</span></span><br><span class="line">proxy.age = <span class="number">23</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(proxy)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(keys) <span class="comment">// [ age ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> names = <span class="built_in">Object</span>.getOwnPropertyNames(proxy)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(names) <span class="comment">// [ age ]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>ownKeys</code> 陷阱函数也能影响 <code>for-in</code> 循环，因为这种循环调用了陷阱函数来决定哪些值能够被用在循环内。</p>
</blockquote>
<h3 id="使用-apply-与-construct-陷阱函数的函数代理"><a href="#使用-apply-与-construct-陷阱函数的函数代理" class="headerlink" title="使用 apply 与 construct 陷阱函数的函数代理"></a>使用 apply 与 construct 陷阱函数的函数代理</h3><p>在所有的代理陷阱中，只有 <code>apply</code> 与 <code>construct</code> 要求代理目标对象必须是一个函数。</p>
<p>之前提到过，函数拥有两个内部方法：<code>[[Call]]</code> 与 <code>[[Construct]]</code> ，前者会在函数被直接调用时执行，而后者会在函数被使用 <code>new</code> 运算符调用时执行。<code>[[Call]]</code> 会在函数被直接调用时执行，而后者会在函数被使用 <code>new</code> 运算符调用时执行。</p>
<p><code>apply</code> 与 <code>construct</code> 陷阱函数对应着这两个内部方法，并允许我们对其进行重写。当不使用 <code>new</code> 去调用一个函数时， <code>apply</code> 陷阱函数会接收到下列三个参数（<code>Reflect.apply()</code> 也会接收这些参数）：</p>
<ol>
<li><code>trapTarget</code>：被执行的函数（即代理的目标对象）；</li>
<li><code>thisArg</code>：调用过程中函数内部的 <code>this</code> 值；</li>
<li><code>argumentsList</code>：被传递给函数的参数数组；</li>
</ol>
<p>当使用 <code>new</code> 去执行函数时，<code>construct</code> 陷阱函数会被调用并接收到下列两个参数：</p>
<ol>
<li><code>trapTarget</code>：被执行的函数（即代理的目标对象）；</li>
<li><code>argumentsList</code>：被传递给函数的参数数组；</li>
</ol>
<p><code>Reflect.construct()</code> 方法同样会接收到这两个参数，还会收到可选的第三个参数 <code>newTarget</code>，如果提供了此参数，则它就指定了函数内部的 <code>new.target</code> 值。</p>
<p><code>apply</code> 与 <code>construct</code>陷阱函数结合起来就能够完全控制任意目标对象函数的行为。</p>
<p>模拟函数的默认行为，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> targetFun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">23</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(targetFun, &#123;</span><br><span class="line">    apply(trapTarget, thisArg, argumentsList) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(trapTarget, thisArg, argumentsList)</span><br><span class="line">    &#125;,</span><br><span class="line">    construct(trapTarget, argumentsList) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.construct(trapTarget, argumentsList)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用了函数的代理，其目标对象会被视为函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> proxy) <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy()) <span class="comment">// 23</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> proxy()</span><br><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> proxy) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> targetFun) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="验证函数的参数"><a href="#验证函数的参数" class="headerlink" title="验证函数的参数"></a>验证函数的参数</h3><p><code>apply</code> 与 <code>construct</code> 陷阱函数在函数的执行方式上开启了很多的可能性。</p>
<p>如下，我们可以通过 <code>apply</code> 陷阱函数保证参数必须是数值类型，并且函数不能使用 <code>new</code> 调用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params">...values</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(values)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sumProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(sum, &#123;</span><br><span class="line">    apply(trapTarget, thisArg, argumentsList) &#123;</span><br><span class="line">        argumentsList.forEach(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> value !== <span class="string">"number"</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"All arguments must be numbers."</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(trapTarget, thisArg, argumentsList)</span><br><span class="line">    &#125;,</span><br><span class="line">    construct(trapTarget, argumentsList) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"This function can't be called with new."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sumProxy(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)) <span class="comment">// [ 1, 2, 3, 4 ]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sumProxy(<span class="string">"1"</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">"4"</span>)) <span class="comment">// 抛错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newSum = <span class="keyword">new</span> sumProxy()  <span class="comment">// 抛错</span></span><br></pre></td></tr></table></figure>

<p>相反的，你也可以限制函数必须使用 <code>new</code> 运算符调用，同时确保它的参数都是数值。</p>
<h3 id="调用构造器而无须使用-new"><a href="#调用构造器而无须使用-new" class="headerlink" title="调用构造器而无须使用 new"></a>调用构造器而无须使用 new</h3><p>前面介绍了我们可以通过 <code>new.target</code> 来判断函数是否使用了 <code>new</code>。就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Numbers</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">new</span>.target === <span class="string">"undefined"</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"This function must be called with new."</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.values = values</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> Numbers(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(instance.values) <span class="comment">// [ 1, 2, 3 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出错误</span></span><br><span class="line">Numbers(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>上面的这个例子，<code>Numbers</code> 函数必须要使用 <code>new</code> 才能够正常执行，在用户不知情的情况下，通常会造成不必要的错误。我们可以使用 <code>apply</code> 陷阱函数来规避必须使用 <code>new</code> 调用这个限制，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Numbers</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">new</span>.target === <span class="string">"undefined"</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"This function must be called with new."</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.values = values</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(Numbers, &#123;</span><br><span class="line">    apply(trapTarget, thisArg, argumentsList) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.construct(trapTarget, argumentsList)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance1 = <span class="keyword">new</span> proxy(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(instance1.values) <span class="comment">// [ 1, 2, 3 ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance2 = proxy(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(instance2.values) <span class="comment">// [ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure>

<p><code>proxy</code> 函数允许我们调用 <code>Numbers</code> 并且无须使用 <code>new</code> ，并且这种调用方式的效果与使用 <code>new</code> 是完全一致的。</p>
<h3 id="可被调用的类构造器"><a href="#可被调用的类构造器" class="headerlink" title="可被调用的类构造器"></a>可被调用的类构造器</h3><p>前面说明了构造器必须始终使用 <code>new</code> 来调用，原因是类构造器的内部方法 <code>[[Call]]</code> 被明确要求抛出错误。然而代理可以拦截对于 <code>[[Call]]</code> 方法的调用，意味着我们可以借助代理创建一个可以被直接调用的类构造器。</p>
<p>如下，我们想让类构造器不使用 <code>new</code> 的情况下也能够正常工作，我们可以使用 <code>apply</code> 陷阱函数来创建一个新的实例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PersonProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(Person, &#123;</span><br><span class="line">    apply(trapTarget, thisArg, argumentsList) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> trapTarget(...argumentsList)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = PersonProxy(<span class="string">"zzzhim"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.name) <span class="comment">// zzzhim</span></span><br><span class="line"><span class="built_in">console</span>.log(obj <span class="keyword">instanceof</span> Person) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="可被撤销的代理"><a href="#可被撤销的代理" class="headerlink" title="可被撤销的代理"></a>可被撤销的代理</h3><p>代理在被创建之后，通常就不能再从目标对象上被解绑了。我之前使用的例子都是使用了不可被撤销的代理。</p>
<p>有些情况下我们可能想要撤销一个代理使它不能够再被使用。我们可以使用 <code>Proxy.revocable()</code> 方法来创建一个可被撤销的代理，该方法接收的参数与 <code>Proxy</code> 构造器相同：</p>
<ol>
<li><code>proxy</code>：可被撤销的代理对象；</li>
<li><code>revoke</code>：用于撤销代理的函数；</li>
</ol>
<p>当 <code>revoke()</code> 函数被调用后，就不能再对该 <code>proxy</code> 对象进行更多操作，任何与该代理对象交互的意图都会触发代理的陷阱函数，从而抛出一个错误。</p>
<p>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    name: <span class="string">"zzzhim"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; proxy, revoke &#125; = <span class="built_in">Proxy</span>.revocable(target, &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name) <span class="comment">// zzzhim</span></span><br><span class="line"></span><br><span class="line">revoke()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出错误</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name)</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>字符串与正则表达式</title>
    <url>/2019/12/16/js/stringAndRegExp/</url>
    <content><![CDATA[<h1 id="字符串与正则表达式"><a href="#字符串与正则表达式" class="headerlink" title="字符串与正则表达式"></a>字符串与正则表达式</h1><p>建议读一下这篇文章：<a href="http://www.fmddlmyy.cn/text6.html" target="_blank" rel="noopener">谈谈Unicode编码，简要解释UCS、UTF、BMP、BOM等名词</a></p>
<h3 id="新增的一些方法"><a href="#新增的一些方法" class="headerlink" title="新增的一些方法"></a>新增的一些方法</h3><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt" target="_blank" rel="noopener">codePointAt()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint" target="_blank" rel="noopener">String.fromCodePoint()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize" target="_blank" rel="noopener">normalize()</a></li>
</ul>
<h3 id="正则表达式u标志"><a href="#正则表达式u标志" class="headerlink" title="正则表达式u标志"></a>正则表达式<strong>u</strong>标志</h3><ul>
<li>当切换到<strong>u</strong>标志的时候，使用unicode码的模式进行匹配。</li>
<li>当切换到<strong>y</strong>标志的时候，使用“粘性”搜索,匹配从目标字符串的当前位置开始，可以使用y标志。</li>
</ul>
<h3 id="识别字符串是否存在于其它字符串中的方法"><a href="#识别字符串是否存在于其它字符串中的方法" class="headerlink" title="识别字符串是否存在于其它字符串中的方法"></a>识别字符串是否存在于其它字符串中的方法</h3><ul>
<li><strong>includes()</strong> 方法，在给定文本存在于字符串中的任意位置时会返回 <code>true</code>，否则返回 <code>false</code>。</li>
<li><strong>startsWith()</strong> 方法，在给定文本出现在字符串起始处时返回 <code>true</code>，否则返回 <code>false</code>。</li>
<li><strong>endsWith()</strong> 方法，在给定文本出现在字符串结尾处时返回 <code>true</code>，否则返回 <code>false</code>。</li>
</ul>
<p>以上的方法都接受两个参数：第一个参数搜索的文本，以及可选的搜索起始位置索引。<br>当提供了第二个参数的时候，<code>includes()</code>和<code>startsWith()</code>方法会从该索引位置开始尝试匹配；而<code>endsWith()</code>方法会将字符串长度减去该参数，以此为起点开始尝试匹配。<br>当不提供第二个参数的时候，<code>includes()</code>和<code>startsWith()</code>方法会从字符串起始处开始查找，而<code>endsWith()</code>方法则从尾部开始。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">"Hello world !"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.includes(<span class="string">'world'</span>))   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(str.startsWith(<span class="string">'Hello'</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(str.endsWith(<span class="string">'!'</span>))       <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.includes(<span class="string">'a'</span>))       <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(str.startsWith(<span class="string">'!'</span>))     <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(str.endsWith(<span class="string">'Hello'</span>))   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.startsWith(<span class="string">"o"</span>, <span class="number">4</span>))  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(str.endsWith(<span class="string">"o"</span>, <span class="number">8</span>))    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(str.includes(<span class="string">"o"</span>, <span class="number">8</span>))    <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="repeat-方法"><a href="#repeat-方法" class="headerlink" title="repeat() 方法"></a>repeat() 方法</h3><p><code>repeat()</code> 方法，它接受一个参数作为字符串的重复次数，返回一个将初始字符串重复指定次数的新字符串。如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'x'</span>.repeat(<span class="number">4</span>))        <span class="comment">// xxxx</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'你好'</span>.repeat(<span class="number">4</span>))     <span class="comment">// 你好你好你好你好</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'zzzhim'</span>.repeat(<span class="number">4</span>))  <span class="comment">// zzzhimzzzhimzzzhimzzzhim</span></span><br></pre></td></tr></table></figure>

<h3 id="flags属性"><a href="#flags属性" class="headerlink" title="flags属性"></a>flags属性</h3><p>ES6新增了 <code>flags</code> 属性用于配合 <code>source</code> 属性，让标志的获取变得更容易。这两个属性均为只有 <code>getter</code> 的原型访问器属性，因此都是只读的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/ab/g</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(reg.source) <span class="comment">// ab</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.flags)  <span class="comment">// g</span></span><br></pre></td></tr></table></figure>

<h3 id="模板字面量"><a href="#模板字面量" class="headerlink" title="模板字面量"></a>模板字面量</h3><p>模板字面量 是允许嵌入表达式的字符串字面量。让我们可以通过使用模板字面量的方式进行多行字符串和字符串插值功能。</p>
<h6 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h6><p>模板字面量是使用 <strong>反引号(``)</strong> 来代替普通字符串中的双引号和单引号。<br>模板字符串可以通过 <strong>(`${}`)</strong> 来插入变量和表达式等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="string">'world'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">`Hello <span class="subst">$&#123;a&#125;</span>!`</span></span><br><span class="line"><span class="keyword">const</span> str1 = <span class="string">`1 + 2 = <span class="subst">$&#123;<span class="number">1</span> + <span class="number">2</span>&#125;</span>`</span></span><br><span class="line"><span class="built_in">console</span>.log(str)  <span class="comment">// Hello world!</span></span><br><span class="line"><span class="built_in">console</span>.log(str1) <span class="comment">// 1 + 2 = 3</span></span><br></pre></td></tr></table></figure>

<h6 id="标签化模板"><a href="#标签化模板" class="headerlink" title="标签化模板"></a>标签化模板</h6><p>一个模板标签（ template tag ）能对模板字面量进行转换并返回最终的字符串值，标签在模板的起始处被指定，即在第一个 ` 之前。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">literals, ...substitutions</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">''</span></span><br><span class="line">    <span class="keyword">let</span> len = literals.length &gt; substitutions.length ? literals.length : substitutions.length</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个字符串</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        str += literals[i] ? literals[i] : <span class="string">''</span></span><br><span class="line">        str += substitutions[i] ? substitutions[i] : <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">'world'</span></span><br><span class="line"><span class="keyword">let</span> message = tag<span class="string">`Hello <span class="subst">$&#123;str&#125;</span>! 您<span class="subst">$&#123;<span class="string">'好'</span>&#125;</span>啊!`</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(message) <span class="comment">// "Hello world! 您好啊!"</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ES6添加了完整的Unicode支持，同时也添加了操作字符串的一些新方法，正则表达式也同样引入了许多功能。<br>模板字面量的添加使得我们在组合字符串与变量的时候变得更加容易拼接与操作。并且通过模板我们可以创建接收模板字面量片段作为参数的函数，可以使用它们来返回合适的字符串。</p>
]]></content>
  </entry>
  <entry>
    <title>符号（Symbol）与符号（Symbol）属性</title>
    <url>/2019/12/16/js/symbol/</url>
    <content><![CDATA[<h1 id="符号（Symbol）与符号（Symbol）属性"><a href="#符号（Symbol）与符号（Symbol）属性" class="headerlink" title="符号（Symbol）与符号（Symbol）属性"></a>符号（Symbol）与符号（Symbol）属性</h1><p>在 JS 已有的基本类型之外，ES6 引入了一种新的基本数据类型： <strong>符号（<code>Symbol</code>）</strong> 。</p>
<p><code>Symbol()</code> 函数会返回 <strong>Symbol</strong> 类型的值，该类型具有静态属性和静态方法。它的静态属性会暴露几个内建的成员对象；它的静态方法会暴露全局的 <strong>symbol</strong> 注册，且类似于内建对象类，但作为构造函数来说它并不完整，因为它不支持语法：<code>new Symbol()</code>。</p>
<p>?&gt; 每个 <code>Symbol()</code> 返回的 <strong>symbol</strong> 值都是唯一的。一个 <strong>symbol</strong> 值能作为对象属性的标识符；这也是 <strong>symbol</strong>存在的意义。</p>
<h3 id="创建符号值"><a href="#创建符号值" class="headerlink" title="创建符号值"></a>创建符号值</h3><p>符号没有字面量形式，这在 <strong>JS</strong> 的基本类型中是独一无二的。想要创建一个 <strong>symbol</strong> 值，我们可以使用全局函数 <strong>Symbol()</strong> 来创建。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> firstName = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> person = &#123;&#125;</span><br><span class="line"></span><br><span class="line">person[firstName] = <span class="string">'反芹菜联盟盟主'</span></span><br><span class="line"><span class="built_in">console</span>.log(person[firstName]) <span class="comment">// 反芹菜联盟盟主</span></span><br></pre></td></tr></table></figure>

<p>通过上面的方法我们创建了一个名叫 <code>firstName</code> 的符号类型的变量，并将它作为了 <code>person</code> 对象的一个属性，而每次访问该属性都要使用这个符号值。</p>
<h6 id="符号描述"><a href="#符号描述" class="headerlink" title="符号描述"></a>符号描述</h6><p><code>Symbol()</code> 函数还可以接受一个额外的参数用于描述符号值，但是该描述不能用来访问对应属性，但是可以用于调试。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="built_in">Symbol</span>(<span class="string">'name'</span>)</span><br><span class="line"><span class="keyword">const</span> person = &#123;&#125;</span><br><span class="line"></span><br><span class="line">person[name] = <span class="string">'反芹菜联盟盟主'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person[name]) <span class="comment">// 反芹菜联盟盟主</span></span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// Symbol(name)</span></span><br></pre></td></tr></table></figure>

<p>符号的描述信息会被储存在内部属性 <code>[[Description]]</code> 中，当我们显式或者隐式调用时，该属性都会被读取。</p>
<p>当我们使用 <code>console.log()</code> 打印 <code>name</code> 符号时， <code>console.log()</code> 就隐式调用了 <code>name</code> 变量的 <code>toString()</code> 方法了。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="built_in">Symbol</span>(<span class="string">'name'</span>)</span><br><span class="line"><span class="keyword">const</span> str = name.toString()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str)  <span class="comment">// Symbol(name)</span></span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// Symbol(name)</span></span><br></pre></td></tr></table></figure>

<p>?&gt; 除了使用 <code>toString()</code> 方法，目前还没有其他办法可以从代码中直接访问 <code>[[Description]]</code> 属性。</p>
<h3 id="识别符号值"><a href="#识别符号值" class="headerlink" title="识别符号值"></a>识别符号值</h3><p>由于符号是基本类型的值，因此我们可以使用 <code>typeof</code> 运算符来判断一个变量是否为符号。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> symbol = <span class="built_in">Symbol</span>(<span class="string">'test symbol'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> symbol === <span class="string">'symbol'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="使用符号值"><a href="#使用符号值" class="headerlink" title="使用符号值"></a>使用符号值</h3><p>我们可以再任意能够使用 <strong>需计算属性名</strong> 的场合使用符号。此外还可以在 <code>Object.defineProperty()</code> 或者 <code>Object.defineProperties()</code> 调用中使用它。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="built_in">Symbol</span>(<span class="string">'name'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用需计算属性名</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    [name]: <span class="string">'反芹菜联盟盟主1'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让该属性变为只读</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, name, &#123;</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> restName = <span class="built_in">Symbol</span>(<span class="string">'name'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(person, &#123;</span><br><span class="line">    [restName]: &#123;</span><br><span class="line">        value: <span class="string">'反芹菜联盟盟主2'</span>,</span><br><span class="line">        writable: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person[name])       <span class="comment">// 反芹菜联盟盟主1</span></span><br><span class="line"><span class="built_in">console</span>.log(person[restName])   <span class="comment">// 反芹菜联盟盟主2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">Object.defineProperty()</a> 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties" target="_blank" rel="noopener">Object.defineProperties()</a> 方法直接在一个对象上定义新的属性或修改现有属性，并返回该对象。</p>
</blockquote>
<h3 id="共享符号值"><a href="#共享符号值" class="headerlink" title="共享符号值"></a>共享符号值</h3><p>假如我们想要在不同的代码段中使用同一个 <strong>符号值</strong> ，例如在两个不同的对象类型中使用同一个 <strong>符号属性</strong> ，用来表示一个唯一标识符。为此，ES6 为我们提供了 <strong>“全局符号注册表”</strong> 供我们在任意时间点进行访问。</p>
<p>想要创建 <strong>共享符号值</strong> ，应该使用 <code>Symbol.for()</code> 方法而不是 <code>Symbol()</code> 方法。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> id = <span class="built_in">Symbol</span>.for(<span class="string">'id'</span>)</span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line">obj[id] = <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj[id]) <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">console</span>.log(id)      <span class="comment">// Symbol(id)</span></span><br></pre></td></tr></table></figure>

<p>?&gt; <code>Symbol.for()</code> 方法仅接受单个字符串类型的参数，作为目标符号值的标识符，同时此参数也会成为该符号的描述信息。</p>
<p><code>Symbol.for()</code> 方法创建前，会首先搜索 <strong>全局符号注册表</strong> ，看看是否存在一个键值为 <code>id</code> 的 <strong>符号值</strong> 。如果存在就会返回已存在的 <strong>符号值</strong> ；否则创建一个新的 <strong>符号值</strong> 。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> id1 = <span class="built_in">Symbol</span>.for(<span class="string">'id'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    [id1]: <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj[id1]) <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">console</span>.log(id1)      <span class="comment">// Symbol(id)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> id2 = <span class="built_in">Symbol</span>.for(<span class="string">'id'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(id1 === id2) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[id2]) <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">console</span>.log(id2)      <span class="comment">// Symbol(id)</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>id1</code> 和 <code>id2</code> 包含同一个 <strong>符号值</strong> ，在第一次调用 <code>Symbol.for(&#39;id&#39;)</code> 时创建了这个 <strong>符号值</strong> ，而第二次调用在 <strong>全局符号注册表</strong> 检测到此 <strong>符号值</strong> 以创建，则返回了已存在的 <strong>符号值</strong> 。</p>
<h3 id="Symbol-keyFor"><a href="#Symbol-keyFor" class="headerlink" title="Symbol.keyFor()"></a>Symbol.keyFor()</h3><p>从 <strong>全局symbol注册表</strong> 中，根据 <strong>符号值</strong> 检索出对应的键值。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> id = <span class="built_in">Symbol</span>.for(<span class="string">'id'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(id)) <span class="comment">// id</span></span><br></pre></td></tr></table></figure>

<h3 id="符号值的转换"><a href="#符号值的转换" class="headerlink" title="符号值的转换"></a>符号值的转换</h3><p>类型转换是 <strong>JS</strong> 语言重要的一部分，能够非常灵活地将一种数据类型转换为另一种。然而符号类型在进行转换时非常不灵活，因为其他类型缺乏与符号值的合理等价，尤其是符号值无法被转换为字符串或数值。</p>
<p>因为符号值无法被转换为字符串或数值，也就以为着当我们把 <strong>符号（<code>Symbol</code>）</strong> 与字符串进行连接或者对其使用数学运算符都会导致其发生错误。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> id = <span class="built_in">Symbol</span>.for(<span class="string">'id'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出错误：Cannot convert a Symbol value to a string</span></span><br><span class="line"><span class="keyword">const</span> str = id + <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> symbol = <span class="built_in">Symbol</span>.for(<span class="string">'number'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出错误：Cannot convert a Symbol value to a number</span></span><br><span class="line"><span class="keyword">const</span> num = symbol + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>?&gt; 虽然说不能够对 <strong>符号</strong> 使用数学运算符，不过使用逻辑运算符是不会导致错误的，因为符号值在逻辑运算符中会被认为等价于 <code>true</code> （就像 <strong>JS</strong> 中其他的非空值一样）。</p>
<h3 id="检索符号属性"><a href="#检索符号属性" class="headerlink" title="检索符号属性"></a>检索符号属性</h3><p>想要检索对象的所有属性名称可以使用 <code>Object.keys()</code> 与 <code>Object.getOwnPropertyNames()</code>。</p>
<blockquote>
<p><code>Object.keys()</code> 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 <code>for...in</code> 循环遍历该对象时返回的顺序一致 。如果对象的键-值都不可枚举，那么将返回由键组成的数组。</p>
<p><code>Object.getOwnPropertyNames()</code>方法返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。</p>
</blockquote>
<p>上面的两种方法都不能返回符号类型的属性，以保持它们在 <strong>ES5</strong>的功能不发生变化。为了让我们可以检索对象的符号类型属性，<strong>ES6</strong> 新增了 <code>Object.getOwnPropertySymbols()</code> 方法。</p>
<blockquote>
<p><code>Object.getOwnPropertySymbols()</code> 方法返回一个给定对象自身的所有 Symbol 属性的数组。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> symbol = <span class="built_in">Symbol</span>.for(<span class="string">'id'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    a: <span class="string">'aaa'</span>,</span><br><span class="line">    [symbol]: <span class="number">123</span>,</span><br><span class="line">    b: <span class="string">'bbb'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = <span class="built_in">Object</span>.getOwnPropertySymbols(obj)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.length)  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>])      <span class="comment">// Symbol(id)</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[arr[<span class="number">0</span>]]) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中 <code>obj</code> 对象有2个普通属性和一个 <code>Symbol</code> 属性，我们使用 <code>Object.getOwnPropertySymbols()</code> 方法返回的数组，则只包含了它的符号值。</p>
<p>所有对象初始化情况下都不包含任何自由符号类型属性，但对象可以从它们的原型上继承符合类型属性。<strong>ES6</strong> 预定义了一些此类属性，它们被称为“知名符合”。</p>
<h3 id="使用知名符号暴露内部方法"><a href="#使用知名符号暴露内部方法" class="headerlink" title="使用知名符号暴露内部方法"></a>使用知名符号暴露内部方法</h3><p><strong>ES6</strong> 允许使用符号类型的原型属性来定义某些对象的基础行为。</p>
<p><strong>ES6</strong> 定义了“知名符号”来代表 JS 中一些公共行为，而这些行为此前被认为只能是内部操作。<br>每一个知名符号都对应全局 <code>Symbol</code> 对象的一个属性，例如 <code>Symbol.create</code> 。</p>
<p>这些知名符号下面会介绍一部分：</p>
<p>迭代 <code>symbols</code></p>
<blockquote>
<p><code>Symbol.iterator</code>：一个返回一个对象默认迭代器的方法。被 <code>for...of</code> 使用。</p>
<p><code>Symbol.asyncIterator</code>: 一个返回对象默认的异步迭代器的方法。被 for await of 使用。</p>
</blockquote>
<p>正则表达式 symbols</p>
<blockquote>
<p><code>Symbol.match</code>：一个用于对字符串进行匹配的方法，也用于确定一个对象是否可以作为正则表达式使用。被 <code>String.prototype.match()</code> 使用。</p>
<p><code>Symbol.replace</code>：一个替换匹配字符串的子串的方法. 被 <code>String.prototype.replace()</code> 使用。</p>
<p><code>Symbol.search</code>： 一个返回一个字符串中与正则表达式相匹配的索引的方法。被<code>String.prototype.search()</code> 使用。</p>
<p><code>Symbol.split</code>： 一个在匹配正则表达式的索引处拆分一个字符串的方法.。被 <code>String.prototype.split()</code> 使用。</p>
</blockquote>
<p>其他 symbols</p>
<blockquote>
<p><code>Symbol.hasInstance</code>： 一个确定一个构造器对象识别的对象是否为它的实例的方法。被 <code>instanceof</code> 使用。</p>
<p><code>Symbol.isConcatSpreadable</code>： 一个布尔值，表明一个对象是否应该 <code>flattened</code> 为它的数组元素。被 <code>Array.prototype.concat()</code> 使用。</p>
<p><code>Symbol.unscopables</code>： 拥有和继承属性名的一个对象的值被排除在与环境绑定的相关对象外。</p>
<p><code>Symbol.species</code>： 一个用于创建派生对象的构造器函数。</p>
<p><code>Symbol.toPrimitive</code>： 一个将对象转化为基本数据类型的方法。</p>
<p><code>Symbol.toStringTag</code>：用于对象的默认描述的字符串值。被 <code>Object.prototype.toString()</code> 使用。</p>
</blockquote>
<h6 id="Symbol-hasInstance"><a href="#Symbol-hasInstance" class="headerlink" title="Symbol.hasInstance"></a><code>Symbol.hasInstance</code></h6><p>每个函数都具有一个 <code>Symbol.hasInstance</code> 方法，用来判断指定对象是否为本函数的一个实例。这个方法定义在 <code>Function.prototype</code> 上，因此所有函数都继承了面对 <code>instanceof</code> 运算符时的默认行为。 <code>Symbol.hasInstance</code> 属性自身是不可写入、不可配置、不可枚举的，从而保证它不会被错误地重写。</p>
<p><code>Symbol.hasInstance</code> 方法只接受单个参数，即需要检测的值。如果该值是本函数的一个实例，则返回 <code>true</code>。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 上面的代码等价于：</span></span><br><span class="line"><span class="built_in">Array</span>[<span class="built_in">Symbol</span>.hasInstance]([]) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>ES6 从本质上将 <code>instanceof</code> 运算符重定义为上述方法调用的简写语法，这样使用 <code>instanceof</code> 便会触发一次方法调用，实际上允许你改变该运算符的工作。</p>
<p>我们可以自定义一个函数，使得任意对象都不会被判断为该函数的一个实例。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// no thing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注释此段代码则结果为 true</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Fun, <span class="built_in">Symbol</span>.hasInstance, &#123;</span><br><span class="line">    value(v) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> Fun()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj <span class="keyword">instanceof</span> Fun) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Object.defineProperty()</code> 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。</p>
</blockquote>
<h6 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a><code>Symbol.isConcatSpreadable</code></h6><p>内置的 <code>Symbol.isConcatSpreadable</code> 符号用于配置某对象作为 <code>Array.prototype.concat()</code> 方法的参数时是否展开其数组元素。</p>
<p>默认情况下 <code>Array.prototype.concat()</code> 会展开自身元素连接到结果中。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ]</span><br><span class="line"><span class="keyword">const</span> arr2 = [ <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr3 = arr1.concat(arr2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr3) <span class="comment">// [ 1, 2, 3, 4, 5 ]</span></span><br></pre></td></tr></table></figure>

<p>当我们设置了 <code>Symbol.isConcatSpreadable</code> 属性为 <code>false</code> 时，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ]</span><br><span class="line"><span class="keyword">const</span> arr2 = [ <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line"></span><br><span class="line">arr2[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr3 = arr1.concat(arr2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr3) <span class="comment">// [ 1, 2, 3, [ 4, 5 ] ]</span></span><br></pre></td></tr></table></figure>

<p>对于类数组 (array-like)对象，默认不展开。期望展开其元素用于连接，需要设置 <code>Symbol.isConcatSpreadable</code> 为 <code>true</code> ：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ]</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.isConcatSpreadable]: <span class="literal">true</span>,</span><br><span class="line">    length: <span class="number">2</span>,</span><br><span class="line">    <span class="number">0</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr3 = arr1.concat(obj)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr3) <span class="comment">// [ 1, 2, 3, 4, 5 ]</span></span><br></pre></td></tr></table></figure>

<p>设置 <code>Symbol.isConcatSpreadable</code> 为 <code>false</code>，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ]</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.isConcatSpreadable]: <span class="literal">false</span>,</span><br><span class="line">    length: <span class="number">2</span>,</span><br><span class="line">    <span class="number">0</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr3 = arr1.concat(obj)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr3) <span class="comment">// [ 1, 2, 3, &#123; 0: 4, 1: 5, length: 2, Symbol(Symbol.isConcatSpreadable): false &#125;]</span></span><br></pre></td></tr></table></figure>

<h6 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h6><p><code>Symbol.toPrimitive</code> 是一个内置的 <code>Symbol</code> 值，它是作为对象的函数值属性存在的，当一个对象转换为对应的原始值时，会调用此函数。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.toPrimitive]: <span class="function"><span class="keyword">function</span>(<span class="params">hint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hint == <span class="string">'number'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj / <span class="number">2</span>) <span class="comment">// 21</span></span><br></pre></td></tr></table></figure>

<h6 id="Symbol-toStringTag"><a href="#Symbol-toStringTag" class="headerlink" title="Symbol.toStringTag"></a>Symbol.toStringTag</h6><p><code>Symbol.toStringTag</code> 是一个内置 <code>symbol</code>，它通常作为对象的属性键使用，对应的属性值应该为字符串类型，这个字符串用来表示该对象的自定义类型标签，通常只有内置的 <code>Object.prototype.toString()</code> 方法会去读取这个标签并把它包含在自己的返回值里。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// no thing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat.prototype[<span class="built_in">Symbol</span>.toStringTag] = <span class="string">"Cat"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> Cat()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cat.toString())</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(cat))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>除非进行了特殊指定，否则所有对象都会从 <code>Object.prototype</code> 继承 <code>Symbol.toStringTag</code> 属性，其默认的属性值是字符串 <code>&quot;Object&quot;</code></p>
</blockquote>
<h6 id="Symbol-match"><a href="#Symbol-match" class="headerlink" title="Symbol.match"></a>Symbol.match</h6><p><code>Symbol.match</code> 指定了匹配的是正则表达式而不是字符串。 <code>String.prototype.match()</code> 方法会调用此函数。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/foo/</span></span><br><span class="line"></span><br><span class="line">reg[<span class="built_in">Symbol</span>.match] = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'/foo/'</span>.startsWith(reg)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'/123foo123/'</span>.endsWith(reg)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>如果将 <code>Symbol.match</code> 置为 <code>false</code>，使用 <code>match</code> 属性的表达式检查会认为该象不是正则表达式对象。<code>startsWith</code> 和 <code>endsWith</code> 方法将不会抛出 <code>TypeError</code>。</p>
<p>我们也可以使用 <code>Symbol.match</code> 定义一个正则表达式对象。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reg = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.match]: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.length &gt; <span class="number">6</span> ? <span class="string">'长度大于6'</span> : <span class="string">'长度小于6'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> len1 = <span class="string">'Hello world'</span></span><br><span class="line"><span class="keyword">const</span> len2 = <span class="string">'Hello'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(len1.match(reg)) <span class="comment">// 长度大于6</span></span><br><span class="line"><span class="built_in">console</span>.log(len2.match(reg)) <span class="comment">// 长度小于6</span></span><br></pre></td></tr></table></figure>

<h6 id="Symbol-replace"><a href="#Symbol-replace" class="headerlink" title="Symbol.replace"></a>Symbol.replace</h6><p><code>Symbol.replace</code> 这个属性指定了当一个字符串替换所匹配字符串时所调用的方法。<code>String.prototype.replace()</code> 方法会调用此方法。</p>
<p>我们也可以使用 <code>Symbol.replace</code> 定义一个正则表达式对象。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reg = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.replace]: <span class="function"><span class="keyword">function</span>(<span class="params">value, replacement</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.length === <span class="number">11</span> ? replacement + value.substring(<span class="number">11</span>) : value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> len1 = <span class="string">'Hello world'</span></span><br><span class="line"><span class="keyword">const</span> len2 = <span class="string">'Hello'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(len1.replace(reg, <span class="string">'12345'</span>)) <span class="comment">// 12345</span></span><br><span class="line"><span class="built_in">console</span>.log(len2.replace(reg, <span class="string">'12345'</span>)) <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure>

<h6 id="Symbol-search"><a href="#Symbol-search" class="headerlink" title="Symbol.search"></a>Symbol.search</h6><p><code>Symbol.search</code> 指定了一个搜索方法，这个方法接受用户输入的正则表达式，返回该正则表达式在字符串中匹配到的下标，这个方法由以下的方法来调用 <code>String.prototype.search()</code>。</p>
<p>我们也可以使用 <code>Symbol.search</code> 定义一个正则表达式对象。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reg = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.search]: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.length &gt; <span class="number">10</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> len1 = <span class="string">'Hello world'</span></span><br><span class="line"><span class="keyword">const</span> len2 = <span class="string">'Hello'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(len1.search(reg)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(len2.search(reg)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h6 id="Symbol-split"><a href="#Symbol-split" class="headerlink" title="Symbol.split"></a>Symbol.split</h6><p><code>Symbol.split</code> 指向 一个正则表达式的索引处分割字符串的方法。 这个方法通过 <code>String.prototype.split()</code> 调用。</p>
<p>我们也可以使用 <code>Symbol.split</code> 定义一个正则表达式对象。如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reg = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.split]: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.length &gt; <span class="number">10</span> ? [] : [value]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> len1 = <span class="string">'Hello world'</span></span><br><span class="line"><span class="keyword">const</span> len2 = <span class="string">'Hello'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(len1.split(reg)) <span class="comment">// []</span></span><br><span class="line"><span class="built_in">console</span>.log(len2.split(reg)) <span class="comment">// [ Hello ]</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>符号（<code>Symbol</code>）是 <strong>JS</strong> 新引入的基本类型值，可以使用它创建不可枚举的属性，并且这些属性不使用符号的情况下是无法访问的。</p>
<p>虽然符号类型不可以创建真正的私有属性，但它们很难被修改，当我们创建一个不想被用户修改的方法时，可以去使用符号。</p>
<p>为符号添加描述，可以更加容易判断它的作用。使用全局符号注册，允许我们在不同的代码段使用同一个符号值。</p>
<p><code>Object.keys()</code> 或 <code>Object.getOwnPropertyNames()</code> 不会返回符号值，因此 ES6 新增了一个<code>Object.getOwnPropertySymbols()</code> 方法，允许检索符号类型的对象属性。而你依然可以使用 <code>Object.defineProperty()</code> 与 <code>Object.defineProperties()</code> 方法对符号类型的属性进行修改。</p>
<p>“知名符号”使用了全局符号常量（例如 <code>Symbol.hasInstance</code> ），为常规对象定义了一些功<br>能，而这些功能原先仅限内部使用。这些符号按规范使用 <code>Symbol</code>. 的前缀，允许开发者通过<br>多种方式去修改常规对象的行为/<em>不过一般情况下也用不到这些方法，个人觉得了解一下即可</em>/。</p>
]]></content>
  </entry>
</search>
